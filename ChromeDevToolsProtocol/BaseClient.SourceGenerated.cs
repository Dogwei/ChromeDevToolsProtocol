#pragma warning disable
namespace ChromeDevToolsProtocol
{
    public partial class BaseClient
    {
        private AccessibilityDomain? accessibility;
        private AnimationDomain? animation;
        private AuditsDomain? audits;
        private BackgroundServiceDomain? backgroundService;
        private BrowserDomain? browser;
        private CSSDomain? cSS;
        private CacheStorageDomain? cacheStorage;
        private CastDomain? cast;
        private DOMDomain? dOM;
        private DOMDebuggerDomain? dOMDebugger;
        private EventBreakpointsDomain? eventBreakpoints;
        private DOMSnapshotDomain? dOMSnapshot;
        private DOMStorageDomain? dOMStorage;
        private DatabaseDomain? database;
        private DeviceOrientationDomain? deviceOrientation;
        private EmulationDomain? emulation;
        private HeadlessExperimentalDomain? headlessExperimental;
        private IODomain? iO;
        private IndexedDBDomain? indexedDB;
        private InputDomain? input;
        private InspectorDomain? inspector;
        private LayerTreeDomain? layerTree;
        private LogDomain? log;
        private MemoryDomain? memory;
        private NetworkDomain? network;
        private OverlayDomain? overlay;
        private PageDomain? page;
        private PerformanceDomain? performance;
        private PerformanceTimelineDomain? performanceTimeline;
        private SecurityDomain? security;
        private ServiceWorkerDomain? serviceWorker;
        private StorageDomain? storage;
        private SystemInfoDomain? systemInfo;
        private TargetDomain? target;
        private TetheringDomain? tethering;
        private TracingDomain? tracing;
        private FetchDomain? fetch;
        private WebAudioDomain? webAudio;
        private WebAuthnDomain? webAuthn;
        private MediaDomain? media;
        private ConsoleDomain? console;
        private DebuggerDomain? debugger;
        private HeapProfilerDomain? heapProfiler;
        private ProfilerDomain? profiler;
        private RuntimeDomain? runtime;
        private SchemaDomain? schema;
        /// <summary>
        /// </summary>
        [Experimental]
        public AccessibilityDomain Accessibility
        {
            get
            {
                return accessibility ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public AnimationDomain Animation
        {
            get
            {
                return animation ??= new(this);

            }

        }
        /// <summary>
        /// Audits domain allows investigation of page violations and possible improvements.
        /// </summary>
        [Experimental]
        public AuditsDomain Audits
        {
            get
            {
                return audits ??= new(this);

            }

        }
        /// <summary>
        /// Defines events for background web platform features.
        /// </summary>
        [Experimental]
        public BackgroundServiceDomain BackgroundService
        {
            get
            {
                return backgroundService ??= new(this);

            }

        }
        /// <summary>
        /// The Browser domain defines methods and events for browser managing.
        /// </summary>
        public BrowserDomain Browser
        {
            get
            {
                return browser ??= new(this);

            }

        }
        /// <summary>
        /// This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
        /// have an associated `id` used in subsequent operations on the related object. Each object type has
        /// a specific `id` structure, and those are not interchangeable between objects of different kinds.
        /// CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
        /// can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
        /// subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
        /// </summary>
        [Experimental]
        public CSSDomain CSS
        {
            get
            {
                return cSS ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public CacheStorageDomain CacheStorage
        {
            get
            {
                return cacheStorage ??= new(this);

            }

        }
        /// <summary>
        /// A domain for interacting with Cast, Presentation API, and Remote Playback API
        /// functionalities.
        /// </summary>
        [Experimental]
        public CastDomain Cast
        {
            get
            {
                return cast ??= new(this);

            }

        }
        /// <summary>
        /// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
        /// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
        /// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
        /// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
        /// and never sends the same node twice. It is client's responsibility to collect information about
        /// the nodes that were sent to the client.<p>Note that `iframe` owner elements will return
        /// corresponding document elements as their child nodes.</p>
        /// </summary>
        public DOMDomain DOM
        {
            get
            {
                return dOM ??= new(this);

            }

        }
        /// <summary>
        /// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
        /// execution will stop on these operations as if there was a regular breakpoint set.
        /// </summary>
        public DOMDebuggerDomain DOMDebugger
        {
            get
            {
                return dOMDebugger ??= new(this);

            }

        }
        /// <summary>
        /// EventBreakpoints permits setting breakpoints on particular operations and
        /// events in targets that run JavaScript but do not have a DOM.
        /// JavaScript execution will stop on these operations as if there was a regular
        /// breakpoint set.
        /// </summary>
        [Experimental]
        public EventBreakpointsDomain EventBreakpoints
        {
            get
            {
                return eventBreakpoints ??= new(this);

            }

        }
        /// <summary>
        /// This domain facilitates obtaining document snapshots with DOM, layout, and style information.
        /// </summary>
        [Experimental]
        public DOMSnapshotDomain DOMSnapshot
        {
            get
            {
                return dOMSnapshot ??= new(this);

            }

        }
        /// <summary>
        /// Query and modify DOM storage.
        /// </summary>
        [Experimental]
        public DOMStorageDomain DOMStorage
        {
            get
            {
                return dOMStorage ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public DatabaseDomain Database
        {
            get
            {
                return database ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public DeviceOrientationDomain DeviceOrientation
        {
            get
            {
                return deviceOrientation ??= new(this);

            }

        }
        /// <summary>
        /// This domain emulates different environments for the page.
        /// </summary>
        public EmulationDomain Emulation
        {
            get
            {
                return emulation ??= new(this);

            }

        }
        /// <summary>
        /// This domain provides experimental commands only supported in headless mode.
        /// </summary>
        [Experimental]
        public HeadlessExperimentalDomain HeadlessExperimental
        {
            get
            {
                return headlessExperimental ??= new(this);

            }

        }
        /// <summary>
        /// Input/Output operations for streams produced by DevTools.
        /// </summary>
        public IODomain IO
        {
            get
            {
                return iO ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public IndexedDBDomain IndexedDB
        {
            get
            {
                return indexedDB ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        public InputDomain Input
        {
            get
            {
                return input ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public InspectorDomain Inspector
        {
            get
            {
                return inspector ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public LayerTreeDomain LayerTree
        {
            get
            {
                return layerTree ??= new(this);

            }

        }
        /// <summary>
        /// Provides access to log entries.
        /// </summary>
        public LogDomain Log
        {
            get
            {
                return log ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public MemoryDomain Memory
        {
            get
            {
                return memory ??= new(this);

            }

        }
        /// <summary>
        /// Network domain allows tracking network activities of the page. It exposes information about http,
        /// file, data and other requests and responses, their headers, bodies, timing, etc.
        /// </summary>
        public NetworkDomain Network
        {
            get
            {
                return network ??= new(this);

            }

        }
        /// <summary>
        /// This domain provides various functionality related to drawing atop the inspected page.
        /// </summary>
        [Experimental]
        public OverlayDomain Overlay
        {
            get
            {
                return overlay ??= new(this);

            }

        }
        /// <summary>
        /// Actions and events related to the inspected page belong to the page domain.
        /// </summary>
        public PageDomain Page
        {
            get
            {
                return page ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        public PerformanceDomain Performance
        {
            get
            {
                return performance ??= new(this);

            }

        }
        /// <summary>
        /// Reporting of performance timeline events, as specified in
        /// https://w3c.github.io/performance-timeline/#dom-performanceobserver.
        /// </summary>
        [Experimental]
        public PerformanceTimelineDomain PerformanceTimeline
        {
            get
            {
                return performanceTimeline ??= new(this);

            }

        }
        /// <summary>
        /// Security
        /// </summary>
        public SecurityDomain Security
        {
            get
            {
                return security ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public ServiceWorkerDomain ServiceWorker
        {
            get
            {
                return serviceWorker ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public StorageDomain Storage
        {
            get
            {
                return storage ??= new(this);

            }

        }
        /// <summary>
        /// The SystemInfo domain defines methods and events for querying low-level system information.
        /// </summary>
        [Experimental]
        public SystemInfoDomain SystemInfo
        {
            get
            {
                return systemInfo ??= new(this);

            }

        }
        /// <summary>
        /// Supports additional targets discovery and allows to attach to them.
        /// </summary>
        public TargetDomain Target
        {
            get
            {
                return target ??= new(this);

            }

        }
        /// <summary>
        /// The Tethering domain defines methods and events for browser port binding.
        /// </summary>
        [Experimental]
        public TetheringDomain Tethering
        {
            get
            {
                return tethering ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public TracingDomain Tracing
        {
            get
            {
                return tracing ??= new(this);

            }

        }
        /// <summary>
        /// A domain for letting clients substitute browser's network layer with client code.
        /// </summary>
        public FetchDomain Fetch
        {
            get
            {
                return fetch ??= new(this);

            }

        }
        /// <summary>
        /// This domain allows inspection of Web Audio API.
        /// https://webaudio.github.io/web-audio-api/
        /// </summary>
        [Experimental]
        public WebAudioDomain WebAudio
        {
            get
            {
                return webAudio ??= new(this);

            }

        }
        /// <summary>
        /// This domain allows configuring virtual authenticators to test the WebAuthn
        /// API.
        /// </summary>
        [Experimental]
        public WebAuthnDomain WebAuthn
        {
            get
            {
                return webAuthn ??= new(this);

            }

        }
        /// <summary>
        /// This domain allows detailed inspection of media elements
        /// </summary>
        [Experimental]
        public MediaDomain Media
        {
            get
            {
                return media ??= new(this);

            }

        }
        /// <summary>
        /// This domain is deprecated - use Runtime or Log instead.
        /// </summary>
        [Obsolete]
        public ConsoleDomain Console
        {
            get
            {
                return console ??= new(this);

            }

        }
        /// <summary>
        /// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
        /// breakpoints, stepping through execution, exploring stack traces, etc.
        /// </summary>
        public DebuggerDomain Debugger
        {
            get
            {
                return debugger ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public HeapProfilerDomain HeapProfiler
        {
            get
            {
                return heapProfiler ??= new(this);

            }

        }
        /// <summary>
        /// </summary>
        public ProfilerDomain Profiler
        {
            get
            {
                return profiler ??= new(this);

            }

        }
        /// <summary>
        /// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
        /// Evaluation results are returned as mirror object that expose object type, string representation
        /// and unique identifier that can be used for further object reference. Original objects are
        /// maintained in memory unless they are either explicitly released or are released along with the
        /// other objects in their object group.
        /// </summary>
        public RuntimeDomain Runtime
        {
            get
            {
                return runtime ??= new(this);

            }

        }
        /// <summary>
        /// This domain is deprecated.
        /// </summary>
        [Obsolete]
        public SchemaDomain Schema
        {
            get
            {
                return schema ??= new(this);

            }

        }
        public partial void RaiseEvent(string domainName, string eventName, Span<byte> messageBytes)
        {
            switch (domainName)
            {
                case "Accessibility": accessibility?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Animation": animation?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Audits": audits?.RaiseEvent(eventName, messageBytes);
                    break;
                case "BackgroundService": backgroundService?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Browser": browser?.RaiseEvent(eventName, messageBytes);
                    break;
                case "CSS": cSS?.RaiseEvent(eventName, messageBytes);
                    break;
                case "CacheStorage": cacheStorage?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Cast": cast?.RaiseEvent(eventName, messageBytes);
                    break;
                case "DOM": dOM?.RaiseEvent(eventName, messageBytes);
                    break;
                case "DOMDebugger": dOMDebugger?.RaiseEvent(eventName, messageBytes);
                    break;
                case "EventBreakpoints": eventBreakpoints?.RaiseEvent(eventName, messageBytes);
                    break;
                case "DOMSnapshot": dOMSnapshot?.RaiseEvent(eventName, messageBytes);
                    break;
                case "DOMStorage": dOMStorage?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Database": database?.RaiseEvent(eventName, messageBytes);
                    break;
                case "DeviceOrientation": deviceOrientation?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Emulation": emulation?.RaiseEvent(eventName, messageBytes);
                    break;
                case "HeadlessExperimental": headlessExperimental?.RaiseEvent(eventName, messageBytes);
                    break;
                case "IO": iO?.RaiseEvent(eventName, messageBytes);
                    break;
                case "IndexedDB": indexedDB?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Input": input?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Inspector": inspector?.RaiseEvent(eventName, messageBytes);
                    break;
                case "LayerTree": layerTree?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Log": log?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Memory": memory?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Network": network?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Overlay": overlay?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Page": page?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Performance": performance?.RaiseEvent(eventName, messageBytes);
                    break;
                case "PerformanceTimeline": performanceTimeline?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Security": security?.RaiseEvent(eventName, messageBytes);
                    break;
                case "ServiceWorker": serviceWorker?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Storage": storage?.RaiseEvent(eventName, messageBytes);
                    break;
                case "SystemInfo": systemInfo?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Target": target?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Tethering": tethering?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Tracing": tracing?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Fetch": fetch?.RaiseEvent(eventName, messageBytes);
                    break;
                case "WebAudio": webAudio?.RaiseEvent(eventName, messageBytes);
                    break;
                case "WebAuthn": webAuthn?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Media": media?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Console": console?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Debugger": debugger?.RaiseEvent(eventName, messageBytes);
                    break;
                case "HeapProfiler": heapProfiler?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Profiler": profiler?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Runtime": runtime?.RaiseEvent(eventName, messageBytes);
                    break;
                case "Schema": schema?.RaiseEvent(eventName, messageBytes);
                    break;
                default: RaiseUnknownEvent(domainName, eventName, messageBytes);
                    break;

            }

        }

    }
    public class AccessibilityDomain : BaseDomain
    {
        public AccessibilityDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Accessibility";

            }

        }
        /// <summary>
        /// The loadComplete event mirrors the load complete event sent by the browser to assistive
        /// technology when the web page has finished loading.
        /// </summary>
        [Experimental]
        public event EventHandler<LoadCompleteParams>? LoadComplete;
        /// <summary>
        /// The nodesUpdated event is sent every time a previously requested node has changed the in tree.
        /// </summary>
        [Experimental]
        public event EventHandler<NodesUpdatedParams>? NodesUpdated;
        /// <summary>
        /// Disables the accessibility domain.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
        /// This turns on accessibility for the page, which can impact performance until accessibility is disabled.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
        /// </summary>
        [Experimental]
        public async ValueTask<GetPartialAXTreeResult> GetPartialAXTreeAsync(GetPartialAXTreeParams getPartialAXTreeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getPartialAXTreeParams, cancellationToken);

        }
        /// <summary>
        /// Fetches the entire accessibility tree for the root Document
        /// </summary>
        [Experimental]
        public async ValueTask<GetFullAXTreeResult> GetFullAXTreeAsync(GetFullAXTreeParams getFullAXTreeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getFullAXTreeParams, cancellationToken);

        }
        /// <summary>
        /// Fetches the root node.
        /// Requires `enable()` to have been called previously.
        /// </summary>
        [Experimental]
        public async ValueTask<GetRootAXNodeResult> GetRootAXNodeAsync(GetRootAXNodeParams getRootAXNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getRootAXNodeParams, cancellationToken);

        }
        /// <summary>
        /// Fetches a node and all ancestors up to and including the root.
        /// Requires `enable()` to have been called previously.
        /// </summary>
        [Experimental]
        public async ValueTask<GetAXNodeAndAncestorsResult> GetAXNodeAndAncestorsAsync(GetAXNodeAndAncestorsParams getAXNodeAndAncestorsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getAXNodeAndAncestorsParams, cancellationToken);

        }
        /// <summary>
        /// Fetches a particular accessibility node by AXNodeId.
        /// Requires `enable()` to have been called previously.
        /// </summary>
        [Experimental]
        public async ValueTask<GetChildAXNodesResult> GetChildAXNodesAsync(GetChildAXNodesParams getChildAXNodesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getChildAXNodesParams, cancellationToken);

        }
        /// <summary>
        /// Query a DOM node's accessibility subtree for accessible name and role.
        /// This command computes the name and role for all nodes in the subtree, including those that are
        /// ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
        /// node is specified, or the DOM node does not exist, the command returns an error. If neither
        /// `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
        /// </summary>
        [Experimental]
        public async ValueTask<QueryAXTreeResult> QueryAXTreeAsync(QueryAXTreeParams queryAXTreeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(queryAXTreeParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "loadComplete": RaiseEvent(LoadComplete, messageBytes);
                    break;
                case "nodesUpdated": RaiseEvent(NodesUpdated, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class LoadCompleteParams
        {
            /// <summary>
            /// New document root node.
            /// </summary>
            public AccessibilityDomain.AXNode Root
            {
                get; set;
            }

        }
        public class NodesUpdatedParams
        {
            /// <summary>
            /// Updated node data.
            /// </summary>
            public AccessibilityDomain.AXNode[] Nodes
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Accessibility.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Accessibility.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetPartialAXTreeParams : IMethodParams<GetPartialAXTreeParams, GetPartialAXTreeResult>
        {
            public string GetMethod()
            {
                return "Accessibility.getPartialAXTree";

            }
            /// <summary>
            /// Identifier of the node to get the partial accessibility tree for.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node to get the partial accessibility tree for.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper to get the partial accessibility tree for.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Whether to fetch this nodes ancestors, siblings and children. Defaults to true.
            /// </summary>
            public bool? FetchRelatives
            {
                get; set;
            }

        }
        public class GetPartialAXTreeResult
        {
            /// <summary>
            /// The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
            /// children, if requested.
            /// </summary>
            public AccessibilityDomain.AXNode[] Nodes
            {
                get; set;
            }

        }
        public class GetFullAXTreeParams : IMethodParams<GetFullAXTreeParams, GetFullAXTreeResult>
        {
            public string GetMethod()
            {
                return "Accessibility.getFullAXTree";

            }
            /// <summary>
            /// The maximum depth at which descendants of the root node should be retrieved.
            /// If omitted, the full tree is returned.
            /// </summary>
            public int? Depth
            {
                get; set;
            }
            /// <summary>
            /// The frame for whose document the AX tree should be retrieved.
            /// If omited, the root frame is used.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }
        public class GetFullAXTreeResult
        {
            /// <summary>
            /// </summary>
            public AccessibilityDomain.AXNode[] Nodes
            {
                get; set;
            }

        }
        public class GetRootAXNodeParams : IMethodParams<GetRootAXNodeParams, GetRootAXNodeResult>
        {
            public string GetMethod()
            {
                return "Accessibility.getRootAXNode";

            }
            /// <summary>
            /// The frame in whose document the node resides.
            /// If omitted, the root frame is used.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }
        public class GetRootAXNodeResult
        {
            /// <summary>
            /// </summary>
            public AccessibilityDomain.AXNode Node
            {
                get; set;
            }

        }
        public class GetAXNodeAndAncestorsParams : IMethodParams<GetAXNodeAndAncestorsParams, GetAXNodeAndAncestorsResult>
        {
            public string GetMethod()
            {
                return "Accessibility.getAXNodeAndAncestors";

            }
            /// <summary>
            /// Identifier of the node to get.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node to get.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper to get.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class GetAXNodeAndAncestorsResult
        {
            /// <summary>
            /// </summary>
            public AccessibilityDomain.AXNode[] Nodes
            {
                get; set;
            }

        }
        public class GetChildAXNodesParams : IMethodParams<GetChildAXNodesParams, GetChildAXNodesResult>
        {
            public string GetMethod()
            {
                return "Accessibility.getChildAXNodes";

            }
            /// <summary>
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// The frame in whose document the node resides.
            /// If omitted, the root frame is used.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }
        public class GetChildAXNodesResult
        {
            /// <summary>
            /// </summary>
            public AccessibilityDomain.AXNode[] Nodes
            {
                get; set;
            }

        }
        public class QueryAXTreeParams : IMethodParams<QueryAXTreeParams, QueryAXTreeResult>
        {
            public string GetMethod()
            {
                return "Accessibility.queryAXTree";

            }
            /// <summary>
            /// Identifier of the node for the root to query.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node for the root to query.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper for the root to query.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Find nodes with this computed name.
            /// </summary>
            public string? AccessibleName
            {
                get; set;
            }
            /// <summary>
            /// Find nodes with this computed role.
            /// </summary>
            public string? Role
            {
                get; set;
            }

        }
        public class QueryAXTreeResult
        {
            /// <summary>
            /// A list of `Accessibility.AXNode` matching the specified attributes,
            /// including nodes that are ignored for accessibility.
            /// </summary>
            public AccessibilityDomain.AXNode[] Nodes
            {
                get; set;
            }

        }
        /// <summary>
        /// Enum of possible property types.
        /// </summary>
        public enum AXValueType
        {
            [EnumValue("boolean")]
            Boolean = 1,
            [EnumValue("tristate")]
            Tristate = 2,
            [EnumValue("booleanOrUndefined")]
            BooleanOrUndefined = 3,
            [EnumValue("idref")]
            Idref = 4,
            [EnumValue("idrefList")]
            IdrefList = 5,
            [EnumValue("integer")]
            Integer = 6,
            [EnumValue("node")]
            Node = 7,
            [EnumValue("nodeList")]
            NodeList = 8,
            [EnumValue("number")]
            Number = 9,
            [EnumValue("string")]
            String = 10,
            [EnumValue("computedString")]
            ComputedString = 11,
            [EnumValue("token")]
            Token = 12,
            [EnumValue("tokenList")]
            TokenList = 13,
            [EnumValue("domRelation")]
            DomRelation = 14,
            [EnumValue("role")]
            Role = 15,
            [EnumValue("internalRole")]
            InternalRole = 16,
            [EnumValue("valueUndefined")]
            ValueUndefined = 17,

        }
        /// <summary>
        /// Enum of possible property sources.
        /// </summary>
        public enum AXValueSourceType
        {
            [EnumValue("attribute")]
            Attribute = 1,
            [EnumValue("implicit")]
            Implicit = 2,
            [EnumValue("style")]
            Style = 3,
            [EnumValue("contents")]
            Contents = 4,
            [EnumValue("placeholder")]
            Placeholder = 5,
            [EnumValue("relatedElement")]
            RelatedElement = 6,

        }
        /// <summary>
        /// Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
        /// </summary>
        public enum AXValueNativeSourceType
        {
            [EnumValue("description")]
            Description = 1,
            [EnumValue("figcaption")]
            Figcaption = 2,
            [EnumValue("label")]
            Label = 3,
            [EnumValue("labelfor")]
            Labelfor = 4,
            [EnumValue("labelwrapped")]
            Labelwrapped = 5,
            [EnumValue("legend")]
            Legend = 6,
            [EnumValue("rubyannotation")]
            Rubyannotation = 7,
            [EnumValue("tablecaption")]
            Tablecaption = 8,
            [EnumValue("title")]
            Title = 9,
            [EnumValue("other")]
            Other = 10,

        }
        /// <summary>
        /// A single source for a computed AX property.
        /// </summary>
        public class AXValueSource
        {
            /// <summary>
            /// What type of source this is.
            /// </summary>
            public AccessibilityDomain.AXValueSourceType Type
            {
                get; set;
            }
            /// <summary>
            /// The value of this property source.
            /// </summary>
            public AccessibilityDomain.AXValue? Value
            {
                get; set;
            }
            /// <summary>
            /// The name of the relevant attribute, if any.
            /// </summary>
            public string? Attribute
            {
                get; set;
            }
            /// <summary>
            /// The value of the relevant attribute, if any.
            /// </summary>
            public AccessibilityDomain.AXValue? AttributeValue
            {
                get; set;
            }
            /// <summary>
            /// Whether this source is superseded by a higher priority source.
            /// </summary>
            public bool? Superseded
            {
                get; set;
            }
            /// <summary>
            /// The native markup source for this value, e.g. a <label> element.
            /// </summary>
            public AccessibilityDomain.AXValueNativeSourceType? NativeSource
            {
                get; set;
            }
            /// <summary>
            /// The value, such as a node or node list, of the native source.
            /// </summary>
            public AccessibilityDomain.AXValue? NativeSourceValue
            {
                get; set;
            }
            /// <summary>
            /// Whether the value for this property is invalid.
            /// </summary>
            public bool? Invalid
            {
                get; set;
            }
            /// <summary>
            /// Reason for the value being invalid, if it is.
            /// </summary>
            public string? InvalidReason
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class AXRelatedNode
        {
            /// <summary>
            /// The BackendNodeId of the related DOM node.
            /// </summary>
            public int BackendDOMNodeId
            {
                get; set;
            }
            /// <summary>
            /// The IDRef value provided, if any.
            /// </summary>
            public string? Idref
            {
                get; set;
            }
            /// <summary>
            /// The text alternative of this node in the current context.
            /// </summary>
            public string? Text
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class AXProperty
        {
            /// <summary>
            /// The name of this property.
            /// </summary>
            public AccessibilityDomain.AXPropertyName Name
            {
                get; set;
            }
            /// <summary>
            /// The value of this property.
            /// </summary>
            public AccessibilityDomain.AXValue Value
            {
                get; set;
            }

        }
        /// <summary>
        /// A single computed AX property.
        /// </summary>
        public class AXValue
        {
            /// <summary>
            /// The type of this value.
            /// </summary>
            public AccessibilityDomain.AXValueType Type
            {
                get; set;
            }
            /// <summary>
            /// The computed value of this property.
            /// </summary>
            public object? Value
            {
                get; set;
            }
            /// <summary>
            /// One or more related nodes, if applicable.
            /// </summary>
            public AccessibilityDomain.AXRelatedNode[]? RelatedNodes
            {
                get; set;
            }
            /// <summary>
            /// The sources which contributed to the computation of this property.
            /// </summary>
            public AccessibilityDomain.AXValueSource[]? Sources
            {
                get; set;
            }

        }
        /// <summary>
        /// Values of AXProperty name:
        /// - from 'busy' to 'roledescription': states which apply to every AX node
        /// - from 'live' to 'root': attributes which apply to nodes in live regions
        /// - from 'autocomplete' to 'valuetext': attributes which apply to widgets
        /// - from 'checked' to 'selected': states which apply to widgets
        /// - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
        /// </summary>
        public enum AXPropertyName
        {
            [EnumValue("busy")]
            Busy = 1,
            [EnumValue("disabled")]
            Disabled = 2,
            [EnumValue("editable")]
            Editable = 3,
            [EnumValue("focusable")]
            Focusable = 4,
            [EnumValue("focused")]
            Focused = 5,
            [EnumValue("hidden")]
            Hidden = 6,
            [EnumValue("hiddenRoot")]
            HiddenRoot = 7,
            [EnumValue("invalid")]
            Invalid = 8,
            [EnumValue("keyshortcuts")]
            Keyshortcuts = 9,
            [EnumValue("settable")]
            Settable = 10,
            [EnumValue("roledescription")]
            Roledescription = 11,
            [EnumValue("live")]
            Live = 12,
            [EnumValue("atomic")]
            Atomic = 13,
            [EnumValue("relevant")]
            Relevant = 14,
            [EnumValue("root")]
            Root = 15,
            [EnumValue("autocomplete")]
            Autocomplete = 16,
            [EnumValue("hasPopup")]
            HasPopup = 17,
            [EnumValue("level")]
            Level = 18,
            [EnumValue("multiselectable")]
            Multiselectable = 19,
            [EnumValue("orientation")]
            Orientation = 20,
            [EnumValue("multiline")]
            Multiline = 21,
            [EnumValue("readonly")]
            Readonly = 22,
            [EnumValue("required")]
            Required = 23,
            [EnumValue("valuemin")]
            Valuemin = 24,
            [EnumValue("valuemax")]
            Valuemax = 25,
            [EnumValue("valuetext")]
            Valuetext = 26,
            [EnumValue("checked")]
            Checked = 27,
            [EnumValue("expanded")]
            Expanded = 28,
            [EnumValue("modal")]
            Modal = 29,
            [EnumValue("pressed")]
            Pressed = 30,
            [EnumValue("selected")]
            Selected = 31,
            [EnumValue("activedescendant")]
            Activedescendant = 32,
            [EnumValue("controls")]
            Controls = 33,
            [EnumValue("describedby")]
            Describedby = 34,
            [EnumValue("details")]
            Details = 35,
            [EnumValue("errormessage")]
            Errormessage = 36,
            [EnumValue("flowto")]
            Flowto = 37,
            [EnumValue("labelledby")]
            Labelledby = 38,
            [EnumValue("owns")]
            Owns = 39,

        }
        /// <summary>
        /// A node in the accessibility tree.
        /// </summary>
        public class AXNode
        {
            /// <summary>
            /// Unique identifier for this node.
            /// </summary>
            public string NodeId
            {
                get; set;
            }
            /// <summary>
            /// Whether this node is ignored for accessibility
            /// </summary>
            public bool Ignored
            {
                get; set;
            }
            /// <summary>
            /// Collection of reasons why this node is hidden.
            /// </summary>
            public AccessibilityDomain.AXProperty[]? IgnoredReasons
            {
                get; set;
            }
            /// <summary>
            /// This `Node`'s role, whether explicit or implicit.
            /// </summary>
            public AccessibilityDomain.AXValue? Role
            {
                get; set;
            }
            /// <summary>
            /// This `Node`'s Chrome raw role.
            /// </summary>
            public AccessibilityDomain.AXValue? ChromeRole
            {
                get; set;
            }
            /// <summary>
            /// The accessible name for this `Node`.
            /// </summary>
            public AccessibilityDomain.AXValue? Name
            {
                get; set;
            }
            /// <summary>
            /// The accessible description for this `Node`.
            /// </summary>
            public AccessibilityDomain.AXValue? Description
            {
                get; set;
            }
            /// <summary>
            /// The value for this `Node`.
            /// </summary>
            public AccessibilityDomain.AXValue? Value
            {
                get; set;
            }
            /// <summary>
            /// All other properties
            /// </summary>
            public AccessibilityDomain.AXProperty[]? Properties
            {
                get; set;
            }
            /// <summary>
            /// ID for this node's parent.
            /// </summary>
            public string? ParentId
            {
                get; set;
            }
            /// <summary>
            /// IDs for each of this node's child nodes.
            /// </summary>
            public string[]? ChildIds
            {
                get; set;
            }
            /// <summary>
            /// The backend ID for the associated DOM node, if any.
            /// </summary>
            public int? BackendDOMNodeId
            {
                get; set;
            }
            /// <summary>
            /// The frame ID for the frame associated with this nodes document.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }

    }
    public class AnimationDomain : BaseDomain
    {
        public AnimationDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Animation";

            }

        }
        /// <summary>
        /// Event for when an animation has been cancelled.
        /// </summary>
        public event EventHandler<AnimationCanceledParams>? AnimationCanceled;
        /// <summary>
        /// Event for each animation that has been created.
        /// </summary>
        public event EventHandler<AnimationCreatedParams>? AnimationCreated;
        /// <summary>
        /// Event for animation that has been started.
        /// </summary>
        public event EventHandler<AnimationStartedParams>? AnimationStarted;
        /// <summary>
        /// Disables animation domain notifications.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables animation domain notifications.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Returns the current time of the an animation.
        /// </summary>
        public async ValueTask<GetCurrentTimeResult> GetCurrentTimeAsync(GetCurrentTimeParams getCurrentTimeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCurrentTimeParams, cancellationToken);

        }
        /// <summary>
        /// Gets the playback rate of the document timeline.
        /// </summary>
        public async ValueTask<GetPlaybackRateResult> GetPlaybackRateAsync(GetPlaybackRateParams getPlaybackRateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getPlaybackRateParams, cancellationToken);

        }
        /// <summary>
        /// Releases a set of animations to no longer be manipulated.
        /// </summary>
        public async ValueTask<ReleaseAnimationsResult> ReleaseAnimationsAsync(ReleaseAnimationsParams releaseAnimationsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(releaseAnimationsParams, cancellationToken);

        }
        /// <summary>
        /// Gets the remote object of the Animation.
        /// </summary>
        public async ValueTask<ResolveAnimationResult> ResolveAnimationAsync(ResolveAnimationParams resolveAnimationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resolveAnimationParams, cancellationToken);

        }
        /// <summary>
        /// Seek a set of animations to a particular time within each animation.
        /// </summary>
        public async ValueTask<SeekAnimationsResult> SeekAnimationsAsync(SeekAnimationsParams seekAnimationsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(seekAnimationsParams, cancellationToken);

        }
        /// <summary>
        /// Sets the paused state of a set of animations.
        /// </summary>
        public async ValueTask<SetPausedResult> SetPausedAsync(SetPausedParams setPausedParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPausedParams, cancellationToken);

        }
        /// <summary>
        /// Sets the playback rate of the document timeline.
        /// </summary>
        public async ValueTask<SetPlaybackRateResult> SetPlaybackRateAsync(SetPlaybackRateParams setPlaybackRateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPlaybackRateParams, cancellationToken);

        }
        /// <summary>
        /// Sets the timing of an animation node.
        /// </summary>
        public async ValueTask<SetTimingResult> SetTimingAsync(SetTimingParams setTimingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setTimingParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "animationCanceled": RaiseEvent(AnimationCanceled, messageBytes);
                    break;
                case "animationCreated": RaiseEvent(AnimationCreated, messageBytes);
                    break;
                case "animationStarted": RaiseEvent(AnimationStarted, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class AnimationCanceledParams
        {
            /// <summary>
            /// Id of the animation that was cancelled.
            /// </summary>
            public string Id
            {
                get; set;
            }

        }
        public class AnimationCreatedParams
        {
            /// <summary>
            /// Id of the animation that was created.
            /// </summary>
            public string Id
            {
                get; set;
            }

        }
        public class AnimationStartedParams
        {
            /// <summary>
            /// Animation that was started.
            /// </summary>
            public AnimationDomain.Animation Animation
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Animation.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Animation.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetCurrentTimeParams : IMethodParams<GetCurrentTimeParams, GetCurrentTimeResult>
        {
            public string GetMethod()
            {
                return "Animation.getCurrentTime";

            }
            /// <summary>
            /// Id of animation.
            /// </summary>
            public string Id
            {
                get; set;
            }

        }
        public class GetCurrentTimeResult
        {
            /// <summary>
            /// Current time of the page.
            /// </summary>
            public double CurrentTime
            {
                get; set;
            }

        }
        public class GetPlaybackRateParams : IMethodParams<GetPlaybackRateParams, GetPlaybackRateResult>
        {
            public string GetMethod()
            {
                return "Animation.getPlaybackRate";

            }

        }
        public class GetPlaybackRateResult
        {
            /// <summary>
            /// Playback rate for animations on page.
            /// </summary>
            public double PlaybackRate
            {
                get; set;
            }

        }
        public class ReleaseAnimationsParams : IMethodParams<ReleaseAnimationsParams, ReleaseAnimationsResult>
        {
            public string GetMethod()
            {
                return "Animation.releaseAnimations";

            }
            /// <summary>
            /// List of animation ids to seek.
            /// </summary>
            public string[] Animations
            {
                get; set;
            }

        }
        public class ReleaseAnimationsResult
        {

        }
        public class ResolveAnimationParams : IMethodParams<ResolveAnimationParams, ResolveAnimationResult>
        {
            public string GetMethod()
            {
                return "Animation.resolveAnimation";

            }
            /// <summary>
            /// Animation id.
            /// </summary>
            public string AnimationId
            {
                get; set;
            }

        }
        public class ResolveAnimationResult
        {
            /// <summary>
            /// Corresponding remote object.
            /// </summary>
            public RuntimeDomain.RemoteObject RemoteObject
            {
                get; set;
            }

        }
        public class SeekAnimationsParams : IMethodParams<SeekAnimationsParams, SeekAnimationsResult>
        {
            public string GetMethod()
            {
                return "Animation.seekAnimations";

            }
            /// <summary>
            /// List of animation ids to seek.
            /// </summary>
            public string[] Animations
            {
                get; set;
            }
            /// <summary>
            /// Set the current time of each animation.
            /// </summary>
            public double CurrentTime
            {
                get; set;
            }

        }
        public class SeekAnimationsResult
        {

        }
        public class SetPausedParams : IMethodParams<SetPausedParams, SetPausedResult>
        {
            public string GetMethod()
            {
                return "Animation.setPaused";

            }
            /// <summary>
            /// Animations to set the pause state of.
            /// </summary>
            public string[] Animations
            {
                get; set;
            }
            /// <summary>
            /// Paused state to set to.
            /// </summary>
            public bool Paused
            {
                get; set;
            }

        }
        public class SetPausedResult
        {

        }
        public class SetPlaybackRateParams : IMethodParams<SetPlaybackRateParams, SetPlaybackRateResult>
        {
            public string GetMethod()
            {
                return "Animation.setPlaybackRate";

            }
            /// <summary>
            /// Playback rate for animations on page
            /// </summary>
            public double PlaybackRate
            {
                get; set;
            }

        }
        public class SetPlaybackRateResult
        {

        }
        public class SetTimingParams : IMethodParams<SetTimingParams, SetTimingResult>
        {
            public string GetMethod()
            {
                return "Animation.setTiming";

            }
            /// <summary>
            /// Animation id.
            /// </summary>
            public string AnimationId
            {
                get; set;
            }
            /// <summary>
            /// Duration of the animation.
            /// </summary>
            public double Duration
            {
                get; set;
            }
            /// <summary>
            /// Delay of the animation.
            /// </summary>
            public double Delay
            {
                get; set;
            }

        }
        public class SetTimingResult
        {

        }
        /// <summary>
        /// Animation instance.
        /// </summary>
        public class Animation
        {
            /// <summary>
            /// `Animation`'s id.
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s internal paused state.
            /// </summary>
            public bool PausedState
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s play state.
            /// </summary>
            public string PlayState
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s playback rate.
            /// </summary>
            public double PlaybackRate
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s start time.
            /// </summary>
            public double StartTime
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s current time.
            /// </summary>
            public double CurrentTime
            {
                get; set;
            }
            /// <summary>
            /// Animation type of `Animation`.
            /// </summary>
            /// <value>
            /// CSSTransition,CSSAnimation,WebAnimation
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// `Animation`'s source animation node.
            /// </summary>
            public AnimationDomain.AnimationEffect? Source
            {
                get; set;
            }
            /// <summary>
            /// A unique ID for `Animation` representing the sources that triggered this CSS
            /// animation/transition.
            /// </summary>
            public string? CssId
            {
                get; set;
            }

        }
        /// <summary>
        /// AnimationEffect instance
        /// </summary>
        public class AnimationEffect
        {
            /// <summary>
            /// `AnimationEffect`'s delay.
            /// </summary>
            public double Delay
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s end delay.
            /// </summary>
            public double EndDelay
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s iteration start.
            /// </summary>
            public double IterationStart
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s iterations.
            /// </summary>
            public double Iterations
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s iteration duration.
            /// </summary>
            public double Duration
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s playback direction.
            /// </summary>
            public string Direction
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s fill mode.
            /// </summary>
            public string Fill
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s target node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s keyframes.
            /// </summary>
            public AnimationDomain.KeyframesRule? KeyframesRule
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s timing function.
            /// </summary>
            public string Easing
            {
                get; set;
            }

        }
        /// <summary>
        /// Keyframes Rule
        /// </summary>
        public class KeyframesRule
        {
            /// <summary>
            /// CSS keyframed animation's name.
            /// </summary>
            public string? Name
            {
                get; set;
            }
            /// <summary>
            /// List of animation keyframes.
            /// </summary>
            public AnimationDomain.KeyframeStyle[] Keyframes
            {
                get; set;
            }

        }
        /// <summary>
        /// Keyframe Style
        /// </summary>
        public class KeyframeStyle
        {
            /// <summary>
            /// Keyframe's time offset.
            /// </summary>
            public string Offset
            {
                get; set;
            }
            /// <summary>
            /// `AnimationEffect`'s timing function.
            /// </summary>
            public string Easing
            {
                get; set;
            }

        }

    }
    public class AuditsDomain : BaseDomain
    {
        public AuditsDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Audits";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<IssueAddedParams>? IssueAdded;
        /// <summary>
        /// Returns the response body and size if it were re-encoded with the specified settings. Only
        /// applies to images.
        /// </summary>
        public async ValueTask<GetEncodedResponseResult> GetEncodedResponseAsync(GetEncodedResponseParams getEncodedResponseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getEncodedResponseParams, cancellationToken);

        }
        /// <summary>
        /// Disables issues domain, prevents further issues from being reported to the client.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables issues domain, sends the issues collected so far to the client by means of the
        /// `issueAdded` event.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Runs the contrast check for the target page. Found issues are reported
        /// using Audits.issueAdded event.
        /// </summary>
        public async ValueTask<CheckContrastResult> CheckContrastAsync(CheckContrastParams checkContrastParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(checkContrastParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "issueAdded": RaiseEvent(IssueAdded, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class IssueAddedParams
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.InspectorIssue Issue
            {
                get; set;
            }

        }
        public class GetEncodedResponseParams : IMethodParams<GetEncodedResponseParams, GetEncodedResponseResult>
        {
            public string GetMethod()
            {
                return "Audits.getEncodedResponse";

            }
            /// <summary>
            /// Identifier of the network request to get content for.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// The encoding to use.
            /// </summary>
            /// <value>
            /// webp,jpeg,png
            /// </value>
            public string Encoding
            {
                get; set;
            }
            /// <summary>
            /// The quality of the encoding (0-1). (defaults to 1)
            /// </summary>
            public double? Quality
            {
                get; set;
            }
            /// <summary>
            /// Whether to only return the size information (defaults to false).
            /// </summary>
            public bool? SizeOnly
            {
                get; set;
            }

        }
        public class GetEncodedResponseResult
        {
            /// <summary>
            /// The encoded body as a base64 string. Omitted if sizeOnly is true. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? Body
            {
                get; set;
            }
            /// <summary>
            /// Size before re-encoding.
            /// </summary>
            public int OriginalSize
            {
                get; set;
            }
            /// <summary>
            /// Size after re-encoding.
            /// </summary>
            public int EncodedSize
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Audits.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Audits.enable";

            }

        }
        public class EnableResult
        {

        }
        public class CheckContrastParams : IMethodParams<CheckContrastParams, CheckContrastResult>
        {
            public string GetMethod()
            {
                return "Audits.checkContrast";

            }
            /// <summary>
            /// Whether to report WCAG AAA level issues. Default is false.
            /// </summary>
            public bool? ReportAAA
            {
                get; set;
            }

        }
        public class CheckContrastResult
        {

        }
        /// <summary>
        /// Information about a cookie that is affected by an inspector issue.
        /// </summary>
        public class AffectedCookie
        {
            /// <summary>
            /// The following three properties uniquely identify a cookie
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Path
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Domain
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about a request that is affected by an inspector issue.
        /// </summary>
        public class AffectedRequest
        {
            /// <summary>
            /// The unique request id.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? Url
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the frame affected by an inspector issue.
        /// </summary>
        public class AffectedFrame
        {
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum CookieExclusionReason
        {
            [EnumValue("ExcludeSameSiteUnspecifiedTreatedAsLax")]
            ExcludeSameSiteUnspecifiedTreatedAsLax = 1,
            [EnumValue("ExcludeSameSiteNoneInsecure")]
            ExcludeSameSiteNoneInsecure = 2,
            [EnumValue("ExcludeSameSiteLax")]
            ExcludeSameSiteLax = 3,
            [EnumValue("ExcludeSameSiteStrict")]
            ExcludeSameSiteStrict = 4,
            [EnumValue("ExcludeInvalidSameParty")]
            ExcludeInvalidSameParty = 5,
            [EnumValue("ExcludeSamePartyCrossPartyContext")]
            ExcludeSamePartyCrossPartyContext = 6,

        }
        /// <summary>
        /// </summary>
        public enum CookieWarningReason
        {
            [EnumValue("WarnSameSiteUnspecifiedCrossSiteContext")]
            WarnSameSiteUnspecifiedCrossSiteContext = 1,
            [EnumValue("WarnSameSiteNoneInsecure")]
            WarnSameSiteNoneInsecure = 2,
            [EnumValue("WarnSameSiteUnspecifiedLaxAllowUnsafe")]
            WarnSameSiteUnspecifiedLaxAllowUnsafe = 3,
            [EnumValue("WarnSameSiteStrictLaxDowngradeStrict")]
            WarnSameSiteStrictLaxDowngradeStrict = 4,
            [EnumValue("WarnSameSiteStrictCrossDowngradeStrict")]
            WarnSameSiteStrictCrossDowngradeStrict = 5,
            [EnumValue("WarnSameSiteStrictCrossDowngradeLax")]
            WarnSameSiteStrictCrossDowngradeLax = 6,
            [EnumValue("WarnSameSiteLaxCrossDowngradeStrict")]
            WarnSameSiteLaxCrossDowngradeStrict = 7,
            [EnumValue("WarnSameSiteLaxCrossDowngradeLax")]
            WarnSameSiteLaxCrossDowngradeLax = 8,
            [EnumValue("WarnAttributeValueExceedsMaxSize")]
            WarnAttributeValueExceedsMaxSize = 9,

        }
        /// <summary>
        /// </summary>
        public enum CookieOperation
        {
            [EnumValue("SetCookie")]
            SetCookie = 1,
            [EnumValue("ReadCookie")]
            ReadCookie = 2,

        }
        /// <summary>
        /// This information is currently necessary, as the front-end has a difficult
        /// time finding a specific cookie. With this, we can convey specific error
        /// information without the cookie.
        /// </summary>
        public class CookieIssueDetails
        {
            /// <summary>
            /// If AffectedCookie is not set then rawCookieLine contains the raw
            /// Set-Cookie header string. This hints at a problem where the
            /// cookie line is syntactically or semantically malformed in a way
            /// that no valid cookie could be created.
            /// </summary>
            public AuditsDomain.AffectedCookie? Cookie
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? RawCookieLine
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.CookieWarningReason[] CookieWarningReasons
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.CookieExclusionReason[] CookieExclusionReasons
            {
                get; set;
            }
            /// <summary>
            /// Optionally identifies the site-for-cookies and the cookie url, which
            /// may be used by the front-end as additional context.
            /// </summary>
            public AuditsDomain.CookieOperation Operation
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? SiteForCookies
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? CookieUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedRequest? Request
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum MixedContentResolutionStatus
        {
            [EnumValue("MixedContentBlocked")]
            MixedContentBlocked = 1,
            [EnumValue("MixedContentAutomaticallyUpgraded")]
            MixedContentAutomaticallyUpgraded = 2,
            [EnumValue("MixedContentWarning")]
            MixedContentWarning = 3,

        }
        /// <summary>
        /// </summary>
        public enum MixedContentResourceType
        {
            [EnumValue("AttributionSrc")]
            AttributionSrc = 1,
            [EnumValue("Audio")]
            Audio = 2,
            [EnumValue("Beacon")]
            Beacon = 3,
            [EnumValue("CSPReport")]
            CSPReport = 4,
            [EnumValue("Download")]
            Download = 5,
            [EnumValue("EventSource")]
            EventSource = 6,
            [EnumValue("Favicon")]
            Favicon = 7,
            [EnumValue("Font")]
            Font = 8,
            [EnumValue("Form")]
            Form = 9,
            [EnumValue("Frame")]
            Frame = 10,
            [EnumValue("Image")]
            Image = 11,
            [EnumValue("Import")]
            Import = 12,
            [EnumValue("Manifest")]
            Manifest = 13,
            [EnumValue("Ping")]
            Ping = 14,
            [EnumValue("PluginData")]
            PluginData = 15,
            [EnumValue("PluginResource")]
            PluginResource = 16,
            [EnumValue("Prefetch")]
            Prefetch = 17,
            [EnumValue("Resource")]
            Resource = 18,
            [EnumValue("Script")]
            Script = 19,
            [EnumValue("ServiceWorker")]
            ServiceWorker = 20,
            [EnumValue("SharedWorker")]
            SharedWorker = 21,
            [EnumValue("Stylesheet")]
            Stylesheet = 22,
            [EnumValue("Track")]
            Track = 23,
            [EnumValue("Video")]
            Video = 24,
            [EnumValue("Worker")]
            Worker = 25,
            [EnumValue("XMLHttpRequest")]
            XMLHttpRequest = 26,
            [EnumValue("XSLT")]
            XSLT = 27,

        }
        /// <summary>
        /// </summary>
        public class MixedContentIssueDetails
        {
            /// <summary>
            /// The type of resource causing the mixed content issue (css, js, iframe,
            /// form,...). Marked as optional because it is mapped to from
            /// blink::mojom::RequestContextType, which will be replaced
            /// by network::mojom::RequestDestination
            /// </summary>
            public AuditsDomain.MixedContentResourceType? ResourceType
            {
                get; set;
            }
            /// <summary>
            /// The way the mixed content issue is being resolved.
            /// </summary>
            public AuditsDomain.MixedContentResolutionStatus ResolutionStatus
            {
                get; set;
            }
            /// <summary>
            /// The unsafe http url causing the mixed content issue.
            /// </summary>
            public string InsecureURL
            {
                get; set;
            }
            /// <summary>
            /// The url responsible for the call to an unsafe url.
            /// </summary>
            public string MainResourceURL
            {
                get; set;
            }
            /// <summary>
            /// The mixed content request.
            /// Does not always exist (e.g. for unsafe form submission urls).
            /// </summary>
            public AuditsDomain.AffectedRequest? Request
            {
                get; set;
            }
            /// <summary>
            /// Optional because not every mixed content issue is necessarily linked to a frame.
            /// </summary>
            public AuditsDomain.AffectedFrame? Frame
            {
                get; set;
            }

        }
        /// <summary>
        /// Enum indicating the reason a response has been blocked. These reasons are
        /// refinements of the net error BLOCKED_BY_RESPONSE.
        /// </summary>
        public enum BlockedByResponseReason
        {
            [EnumValue("CoepFrameResourceNeedsCoepHeader")]
            CoepFrameResourceNeedsCoepHeader = 1,
            [EnumValue("CoopSandboxedIFrameCannotNavigateToCoopPage")]
            CoopSandboxedIFrameCannotNavigateToCoopPage = 2,
            [EnumValue("CorpNotSameOrigin")]
            CorpNotSameOrigin = 3,
            [EnumValue("CorpNotSameOriginAfterDefaultedToSameOriginByCoep")]
            CorpNotSameOriginAfterDefaultedToSameOriginByCoep = 4,
            [EnumValue("CorpNotSameSite")]
            CorpNotSameSite = 5,

        }
        /// <summary>
        /// Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
        /// code. Currently only used for COEP/COOP, but may be extended to include
        /// some CSP errors in the future.
        /// </summary>
        public class BlockedByResponseIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedRequest Request
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedFrame? ParentFrame
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedFrame? BlockedFrame
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.BlockedByResponseReason Reason
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum HeavyAdResolutionStatus
        {
            [EnumValue("HeavyAdBlocked")]
            HeavyAdBlocked = 1,
            [EnumValue("HeavyAdWarning")]
            HeavyAdWarning = 2,

        }
        /// <summary>
        /// </summary>
        public enum HeavyAdReason
        {
            [EnumValue("NetworkTotalLimit")]
            NetworkTotalLimit = 1,
            [EnumValue("CpuTotalLimit")]
            CpuTotalLimit = 2,
            [EnumValue("CpuPeakLimit")]
            CpuPeakLimit = 3,

        }
        /// <summary>
        /// </summary>
        public class HeavyAdIssueDetails
        {
            /// <summary>
            /// The resolution status, either blocking the content or warning.
            /// </summary>
            public AuditsDomain.HeavyAdResolutionStatus Resolution
            {
                get; set;
            }
            /// <summary>
            /// The reason the ad was blocked, total network or cpu or peak cpu.
            /// </summary>
            public AuditsDomain.HeavyAdReason Reason
            {
                get; set;
            }
            /// <summary>
            /// The frame that was blocked.
            /// </summary>
            public AuditsDomain.AffectedFrame Frame
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum ContentSecurityPolicyViolationType
        {
            [EnumValue("kInlineViolation")]
            KInlineViolation = 1,
            [EnumValue("kEvalViolation")]
            KEvalViolation = 2,
            [EnumValue("kURLViolation")]
            KURLViolation = 3,
            [EnumValue("kTrustedTypesSinkViolation")]
            KTrustedTypesSinkViolation = 4,
            [EnumValue("kTrustedTypesPolicyViolation")]
            KTrustedTypesPolicyViolation = 5,
            [EnumValue("kWasmEvalViolation")]
            KWasmEvalViolation = 6,

        }
        /// <summary>
        /// </summary>
        public class SourceCodeLocation
        {
            /// <summary>
            /// </summary>
            public string? ScriptId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int ColumnNumber
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class ContentSecurityPolicyIssueDetails
        {
            /// <summary>
            /// The url not included in allowed sources.
            /// </summary>
            public string? BlockedURL
            {
                get; set;
            }
            /// <summary>
            /// Specific directive that is violated, causing the CSP issue.
            /// </summary>
            public string ViolatedDirective
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsReportOnly
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.ContentSecurityPolicyViolationType ContentSecurityPolicyViolationType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedFrame? FrameAncestor
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.SourceCodeLocation? SourceCodeLocation
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int? ViolatingNodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum SharedArrayBufferIssueType
        {
            [EnumValue("TransferIssue")]
            TransferIssue = 1,
            [EnumValue("CreationIssue")]
            CreationIssue = 2,

        }
        /// <summary>
        /// Details for a issue arising from an SAB being instantiated in, or
        /// transferred to a context that is not cross-origin isolated.
        /// </summary>
        public class SharedArrayBufferIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.SourceCodeLocation SourceCodeLocation
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsWarning
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.SharedArrayBufferIssueType Type
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum TwaQualityEnforcementViolationType
        {
            [EnumValue("kHttpError")]
            KHttpError = 1,
            [EnumValue("kUnavailableOffline")]
            KUnavailableOffline = 2,
            [EnumValue("kDigitalAssetLinks")]
            KDigitalAssetLinks = 3,

        }
        /// <summary>
        /// </summary>
        public class TrustedWebActivityIssueDetails
        {
            /// <summary>
            /// The url that triggers the violation.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.TwaQualityEnforcementViolationType ViolationType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int? HttpStatusCode
            {
                get; set;
            }
            /// <summary>
            /// The package name of the Trusted Web Activity client app. This field is
            /// only used when violation type is kDigitalAssetLinks.
            /// </summary>
            public string? PackageName
            {
                get; set;
            }
            /// <summary>
            /// The signature of the Trusted Web Activity client app. This field is only
            /// used when violation type is kDigitalAssetLinks.
            /// </summary>
            public string? Signature
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class LowTextContrastIssueDetails
        {
            /// <summary>
            /// </summary>
            public int ViolatingNodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ViolatingNodeSelector
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double ContrastRatio
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double ThresholdAA
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double ThresholdAAA
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string FontSize
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string FontWeight
            {
                get; set;
            }

        }
        /// <summary>
        /// Details for a CORS related issue, e.g. a warning or error related to
        /// CORS RFC1918 enforcement.
        /// </summary>
        public class CorsIssueDetails
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.CorsErrorStatus CorsErrorStatus
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsWarning
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedRequest Request
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.SourceCodeLocation? Location
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? InitiatorOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.IPAddressSpace? ResourceIPAddressSpace
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.ClientSecurityState? ClientSecurityState
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum AttributionReportingIssueType
        {
            [EnumValue("PermissionPolicyDisabled")]
            PermissionPolicyDisabled = 1,
            [EnumValue("AttributionSourceUntrustworthyOrigin")]
            AttributionSourceUntrustworthyOrigin = 2,
            [EnumValue("AttributionUntrustworthyOrigin")]
            AttributionUntrustworthyOrigin = 3,
            [EnumValue("InvalidHeader")]
            InvalidHeader = 4,

        }
        /// <summary>
        /// Details for issues around "Attribution Reporting API" usage.
        /// Explainer: https://github.com/WICG/attribution-reporting-api
        /// </summary>
        public class AttributionReportingIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.AttributionReportingIssueType ViolationType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedFrame? Frame
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedRequest? Request
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int? ViolatingNodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? InvalidParameter
            {
                get; set;
            }

        }
        /// <summary>
        /// Details for issues about documents in Quirks Mode
        /// or Limited Quirks Mode that affects page layouting.
        /// </summary>
        public class QuirksModeIssueDetails
        {
            /// <summary>
            /// If false, it means the document's mode is "quirks"
            /// instead of "limited-quirks".
            /// </summary>
            public bool IsLimitedQuirksMode
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int DocumentNodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string LoaderId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class NavigatorUserAgentIssueDetails
        {
            /// <summary>
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.SourceCodeLocation? Location
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum GenericIssueErrorType
        {
            [EnumValue("CrossOriginPortalPostMessageError")]
            CrossOriginPortalPostMessageError = 1,

        }
        /// <summary>
        /// Depending on the concrete errorType, different properties are set.
        /// </summary>
        public class GenericIssueDetails
        {
            /// <summary>
            /// Issues with the same errorType are aggregated in the frontend.
            /// </summary>
            public AuditsDomain.GenericIssueErrorType ErrorType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum DeprecationIssueType
        {
            [EnumValue("AuthorizationCoveredByWildcard")]
            AuthorizationCoveredByWildcard = 1,
            [EnumValue("CanRequestURLHTTPContainingNewline")]
            CanRequestURLHTTPContainingNewline = 2,
            [EnumValue("ChromeLoadTimesConnectionInfo")]
            ChromeLoadTimesConnectionInfo = 3,
            [EnumValue("ChromeLoadTimesFirstPaintAfterLoadTime")]
            ChromeLoadTimesFirstPaintAfterLoadTime = 4,
            [EnumValue("ChromeLoadTimesWasAlternateProtocolAvailable")]
            ChromeLoadTimesWasAlternateProtocolAvailable = 5,
            [EnumValue("CookieWithTruncatingChar")]
            CookieWithTruncatingChar = 6,
            [EnumValue("CrossOriginAccessBasedOnDocumentDomain")]
            CrossOriginAccessBasedOnDocumentDomain = 7,
            [EnumValue("CrossOriginWindowAlert")]
            CrossOriginWindowAlert = 8,
            [EnumValue("CrossOriginWindowConfirm")]
            CrossOriginWindowConfirm = 9,
            [EnumValue("CSSSelectorInternalMediaControlsOverlayCastButton")]
            CSSSelectorInternalMediaControlsOverlayCastButton = 10,
            [EnumValue("DeprecationExample")]
            DeprecationExample = 11,
            [EnumValue("DocumentDomainSettingWithoutOriginAgentClusterHeader")]
            DocumentDomainSettingWithoutOriginAgentClusterHeader = 12,
            [EnumValue("EventPath")]
            EventPath = 13,
            [EnumValue("ExpectCTHeader")]
            ExpectCTHeader = 14,
            [EnumValue("GeolocationInsecureOrigin")]
            GeolocationInsecureOrigin = 15,
            [EnumValue("GeolocationInsecureOriginDeprecatedNotRemoved")]
            GeolocationInsecureOriginDeprecatedNotRemoved = 16,
            [EnumValue("GetUserMediaInsecureOrigin")]
            GetUserMediaInsecureOrigin = 17,
            [EnumValue("HostCandidateAttributeGetter")]
            HostCandidateAttributeGetter = 18,
            [EnumValue("IdentityInCanMakePaymentEvent")]
            IdentityInCanMakePaymentEvent = 19,
            [EnumValue("InsecurePrivateNetworkSubresourceRequest")]
            InsecurePrivateNetworkSubresourceRequest = 20,
            [EnumValue("LegacyConstraintGoogIPv6")]
            LegacyConstraintGoogIPv6 = 21,
            [EnumValue("LocalCSSFileExtensionRejected")]
            LocalCSSFileExtensionRejected = 22,
            [EnumValue("MediaSourceAbortRemove")]
            MediaSourceAbortRemove = 23,
            [EnumValue("MediaSourceDurationTruncatingBuffered")]
            MediaSourceDurationTruncatingBuffered = 24,
            [EnumValue("NavigateEventRestoreScroll")]
            NavigateEventRestoreScroll = 25,
            [EnumValue("NavigateEventTransitionWhile")]
            NavigateEventTransitionWhile = 26,
            [EnumValue("NoSysexWebMIDIWithoutPermission")]
            NoSysexWebMIDIWithoutPermission = 27,
            [EnumValue("NotificationInsecureOrigin")]
            NotificationInsecureOrigin = 28,
            [EnumValue("NotificationPermissionRequestedIframe")]
            NotificationPermissionRequestedIframe = 29,
            [EnumValue("ObsoleteWebRtcCipherSuite")]
            ObsoleteWebRtcCipherSuite = 30,
            [EnumValue("OpenWebDatabaseInsecureContext")]
            OpenWebDatabaseInsecureContext = 31,
            [EnumValue("OverflowVisibleOnReplacedElement")]
            OverflowVisibleOnReplacedElement = 32,
            [EnumValue("PictureSourceSrc")]
            PictureSourceSrc = 33,
            [EnumValue("PrefixedCancelAnimationFrame")]
            PrefixedCancelAnimationFrame = 34,
            [EnumValue("PrefixedRequestAnimationFrame")]
            PrefixedRequestAnimationFrame = 35,
            [EnumValue("PrefixedStorageInfo")]
            PrefixedStorageInfo = 36,
            [EnumValue("PrefixedVideoDisplayingFullscreen")]
            PrefixedVideoDisplayingFullscreen = 37,
            [EnumValue("PrefixedVideoEnterFullscreen")]
            PrefixedVideoEnterFullscreen = 38,
            [EnumValue("PrefixedVideoEnterFullScreen")]
            PrefixedVideoEnterFullScreen = 39,
            [EnumValue("PrefixedVideoExitFullscreen")]
            PrefixedVideoExitFullscreen = 40,
            [EnumValue("PrefixedVideoExitFullScreen")]
            PrefixedVideoExitFullScreen = 41,
            [EnumValue("PrefixedVideoSupportsFullscreen")]
            PrefixedVideoSupportsFullscreen = 42,
            [EnumValue("RangeExpand")]
            RangeExpand = 43,
            [EnumValue("RequestedSubresourceWithEmbeddedCredentials")]
            RequestedSubresourceWithEmbeddedCredentials = 44,
            [EnumValue("RTCConstraintEnableDtlsSrtpFalse")]
            RTCConstraintEnableDtlsSrtpFalse = 45,
            [EnumValue("RTCConstraintEnableDtlsSrtpTrue")]
            RTCConstraintEnableDtlsSrtpTrue = 46,
            [EnumValue("RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics")]
            RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics = 47,
            [EnumValue("RTCPeerConnectionSdpSemanticsPlanB")]
            RTCPeerConnectionSdpSemanticsPlanB = 48,
            [EnumValue("RtcpMuxPolicyNegotiate")]
            RtcpMuxPolicyNegotiate = 49,
            [EnumValue("SharedArrayBufferConstructedWithoutIsolation")]
            SharedArrayBufferConstructedWithoutIsolation = 50,
            [EnumValue("TextToSpeech_DisallowedByAutoplay")]
            TextToSpeech_DisallowedByAutoplay = 51,
            [EnumValue("V8SharedArrayBufferConstructedInExtensionWithoutIsolation")]
            V8SharedArrayBufferConstructedInExtensionWithoutIsolation = 52,
            [EnumValue("XHRJSONEncodingDetection")]
            XHRJSONEncodingDetection = 53,
            [EnumValue("XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload")]
            XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload = 54,
            [EnumValue("XRSupportsSession")]
            XRSupportsSession = 55,

        }
        /// <summary>
        /// This issue tracks information needed to print a deprecation message.
        /// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
        /// </summary>
        public class DeprecationIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.AffectedFrame? AffectedFrame
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.SourceCodeLocation SourceCodeLocation
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.DeprecationIssueType Type
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum ClientHintIssueReason
        {
            [EnumValue("MetaTagAllowListInvalidOrigin")]
            MetaTagAllowListInvalidOrigin = 1,
            [EnumValue("MetaTagModifiedHTML")]
            MetaTagModifiedHTML = 2,

        }
        /// <summary>
        /// </summary>
        public class FederatedAuthRequestIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.FederatedAuthRequestIssueReason FederatedAuthRequestIssueReason
            {
                get; set;
            }

        }
        /// <summary>
        /// Represents the failure reason when a federated authentication reason fails.
        /// Should be updated alongside RequestIdTokenStatus in
        /// third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
        /// all cases except for success.
        /// </summary>
        public enum FederatedAuthRequestIssueReason
        {
            [EnumValue("ApprovalDeclined")]
            ApprovalDeclined = 1,
            [EnumValue("TooManyRequests")]
            TooManyRequests = 2,
            [EnumValue("ManifestListHttpNotFound")]
            ManifestListHttpNotFound = 3,
            [EnumValue("ManifestListNoResponse")]
            ManifestListNoResponse = 4,
            [EnumValue("ManifestListInvalidResponse")]
            ManifestListInvalidResponse = 5,
            [EnumValue("ManifestNotInManifestList")]
            ManifestNotInManifestList = 6,
            [EnumValue("ManifestListTooBig")]
            ManifestListTooBig = 7,
            [EnumValue("ManifestHttpNotFound")]
            ManifestHttpNotFound = 8,
            [EnumValue("ManifestNoResponse")]
            ManifestNoResponse = 9,
            [EnumValue("ManifestInvalidResponse")]
            ManifestInvalidResponse = 10,
            [EnumValue("ClientMetadataHttpNotFound")]
            ClientMetadataHttpNotFound = 11,
            [EnumValue("ClientMetadataNoResponse")]
            ClientMetadataNoResponse = 12,
            [EnumValue("ClientMetadataInvalidResponse")]
            ClientMetadataInvalidResponse = 13,
            [EnumValue("ClientMetadataMissingPrivacyPolicyUrl")]
            ClientMetadataMissingPrivacyPolicyUrl = 14,
            [EnumValue("DisabledInSettings")]
            DisabledInSettings = 15,
            [EnumValue("ErrorFetchingSignin")]
            ErrorFetchingSignin = 16,
            [EnumValue("InvalidSigninResponse")]
            InvalidSigninResponse = 17,
            [EnumValue("AccountsHttpNotFound")]
            AccountsHttpNotFound = 18,
            [EnumValue("AccountsNoResponse")]
            AccountsNoResponse = 19,
            [EnumValue("AccountsInvalidResponse")]
            AccountsInvalidResponse = 20,
            [EnumValue("IdTokenHttpNotFound")]
            IdTokenHttpNotFound = 21,
            [EnumValue("IdTokenNoResponse")]
            IdTokenNoResponse = 22,
            [EnumValue("IdTokenInvalidResponse")]
            IdTokenInvalidResponse = 23,
            [EnumValue("IdTokenInvalidRequest")]
            IdTokenInvalidRequest = 24,
            [EnumValue("ErrorIdToken")]
            ErrorIdToken = 25,
            [EnumValue("Canceled")]
            Canceled = 26,

        }
        /// <summary>
        /// This issue tracks client hints related issues. It's used to deprecate old
        /// features, encourage the use of new ones, and provide general guidance.
        /// </summary>
        public class ClientHintIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.SourceCodeLocation SourceCodeLocation
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.ClientHintIssueReason ClientHintIssueReason
            {
                get; set;
            }

        }
        /// <summary>
        /// A unique identifier for the type of issue. Each type may use one of the
        /// optional fields in InspectorIssueDetails to convey more specific
        /// information about the kind of issue.
        /// </summary>
        public enum InspectorIssueCode
        {
            [EnumValue("CookieIssue")]
            CookieIssue = 1,
            [EnumValue("MixedContentIssue")]
            MixedContentIssue = 2,
            [EnumValue("BlockedByResponseIssue")]
            BlockedByResponseIssue = 3,
            [EnumValue("HeavyAdIssue")]
            HeavyAdIssue = 4,
            [EnumValue("ContentSecurityPolicyIssue")]
            ContentSecurityPolicyIssue = 5,
            [EnumValue("SharedArrayBufferIssue")]
            SharedArrayBufferIssue = 6,
            [EnumValue("TrustedWebActivityIssue")]
            TrustedWebActivityIssue = 7,
            [EnumValue("LowTextContrastIssue")]
            LowTextContrastIssue = 8,
            [EnumValue("CorsIssue")]
            CorsIssue = 9,
            [EnumValue("AttributionReportingIssue")]
            AttributionReportingIssue = 10,
            [EnumValue("QuirksModeIssue")]
            QuirksModeIssue = 11,
            [EnumValue("NavigatorUserAgentIssue")]
            NavigatorUserAgentIssue = 12,
            [EnumValue("GenericIssue")]
            GenericIssue = 13,
            [EnumValue("DeprecationIssue")]
            DeprecationIssue = 14,
            [EnumValue("ClientHintIssue")]
            ClientHintIssue = 15,
            [EnumValue("FederatedAuthRequestIssue")]
            FederatedAuthRequestIssue = 16,

        }
        /// <summary>
        /// This struct holds a list of optional fields with additional information
        /// specific to the kind of issue. When adding a new issue code, please also
        /// add a new optional field to this type.
        /// </summary>
        public class InspectorIssueDetails
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.CookieIssueDetails? CookieIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.MixedContentIssueDetails? MixedContentIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.BlockedByResponseIssueDetails? BlockedByResponseIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.HeavyAdIssueDetails? HeavyAdIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.ContentSecurityPolicyIssueDetails? ContentSecurityPolicyIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.SharedArrayBufferIssueDetails? SharedArrayBufferIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.TrustedWebActivityIssueDetails? TwaQualityEnforcementDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.LowTextContrastIssueDetails? LowTextContrastIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.CorsIssueDetails? CorsIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.AttributionReportingIssueDetails? AttributionReportingIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.QuirksModeIssueDetails? QuirksModeIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.NavigatorUserAgentIssueDetails? NavigatorUserAgentIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.GenericIssueDetails? GenericIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.DeprecationIssueDetails? DeprecationIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.ClientHintIssueDetails? ClientHintIssueDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.FederatedAuthRequestIssueDetails? FederatedAuthRequestIssueDetails
            {
                get; set;
            }

        }
        /// <summary>
        /// An inspector issue reported from the back-end.
        /// </summary>
        public class InspectorIssue
        {
            /// <summary>
            /// </summary>
            public AuditsDomain.InspectorIssueCode Code
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public AuditsDomain.InspectorIssueDetails Details
            {
                get; set;
            }
            /// <summary>
            /// A unique id for this issue. May be omitted if no other entity (e.g.
            /// exception, CDP message, etc.) is referencing this issue.
            /// </summary>
            public string? IssueId
            {
                get; set;
            }

        }

    }
    public class BackgroundServiceDomain : BaseDomain
    {
        public BackgroundServiceDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "BackgroundService";

            }

        }
        /// <summary>
        /// Called when the recording state for the service has been updated.
        /// </summary>
        public event EventHandler<RecordingStateChangedParams>? RecordingStateChanged;
        /// <summary>
        /// Called with all existing backgroundServiceEvents when enabled, and all new
        /// events afterwards if enabled and recording.
        /// </summary>
        public event EventHandler<BackgroundServiceEventReceivedParams>? BackgroundServiceEventReceived;
        /// <summary>
        /// Enables event updates for the service.
        /// </summary>
        public async ValueTask<StartObservingResult> StartObservingAsync(StartObservingParams startObservingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startObservingParams, cancellationToken);

        }
        /// <summary>
        /// Disables event updates for the service.
        /// </summary>
        public async ValueTask<StopObservingResult> StopObservingAsync(StopObservingParams stopObservingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopObservingParams, cancellationToken);

        }
        /// <summary>
        /// Set the recording state for the service.
        /// </summary>
        public async ValueTask<SetRecordingResult> SetRecordingAsync(SetRecordingParams setRecordingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setRecordingParams, cancellationToken);

        }
        /// <summary>
        /// Clears all stored data for the service.
        /// </summary>
        public async ValueTask<ClearEventsResult> ClearEventsAsync(ClearEventsParams clearEventsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearEventsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "recordingStateChanged": RaiseEvent(RecordingStateChanged, messageBytes);
                    break;
                case "backgroundServiceEventReceived": RaiseEvent(BackgroundServiceEventReceived, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class RecordingStateChangedParams
        {
            /// <summary>
            /// </summary>
            public bool IsRecording
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public BackgroundServiceDomain.ServiceName Service
            {
                get; set;
            }

        }
        public class BackgroundServiceEventReceivedParams
        {
            /// <summary>
            /// </summary>
            public BackgroundServiceDomain.BackgroundServiceEvent BackgroundServiceEvent
            {
                get; set;
            }

        }
        public class StartObservingParams : IMethodParams<StartObservingParams, StartObservingResult>
        {
            public string GetMethod()
            {
                return "BackgroundService.startObserving";

            }
            /// <summary>
            /// </summary>
            public BackgroundServiceDomain.ServiceName Service
            {
                get; set;
            }

        }
        public class StartObservingResult
        {

        }
        public class StopObservingParams : IMethodParams<StopObservingParams, StopObservingResult>
        {
            public string GetMethod()
            {
                return "BackgroundService.stopObserving";

            }
            /// <summary>
            /// </summary>
            public BackgroundServiceDomain.ServiceName Service
            {
                get; set;
            }

        }
        public class StopObservingResult
        {

        }
        public class SetRecordingParams : IMethodParams<SetRecordingParams, SetRecordingResult>
        {
            public string GetMethod()
            {
                return "BackgroundService.setRecording";

            }
            /// <summary>
            /// </summary>
            public bool ShouldRecord
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public BackgroundServiceDomain.ServiceName Service
            {
                get; set;
            }

        }
        public class SetRecordingResult
        {

        }
        public class ClearEventsParams : IMethodParams<ClearEventsParams, ClearEventsResult>
        {
            public string GetMethod()
            {
                return "BackgroundService.clearEvents";

            }
            /// <summary>
            /// </summary>
            public BackgroundServiceDomain.ServiceName Service
            {
                get; set;
            }

        }
        public class ClearEventsResult
        {

        }
        /// <summary>
        /// The Background Service that will be associated with the commands/events.
        /// Every Background Service operates independently, but they share the same
        /// API.
        /// </summary>
        public enum ServiceName
        {
            [EnumValue("backgroundFetch")]
            BackgroundFetch = 1,
            [EnumValue("backgroundSync")]
            BackgroundSync = 2,
            [EnumValue("pushMessaging")]
            PushMessaging = 3,
            [EnumValue("notifications")]
            Notifications = 4,
            [EnumValue("paymentHandler")]
            PaymentHandler = 5,
            [EnumValue("periodicBackgroundSync")]
            PeriodicBackgroundSync = 6,

        }
        /// <summary>
        /// A key-value pair for additional event information to pass along.
        /// </summary>
        public class EventMetadata
        {
            /// <summary>
            /// </summary>
            public string Key
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class BackgroundServiceEvent
        {
            /// <summary>
            /// Timestamp of the event (in seconds).
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// The origin this event belongs to.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// The Service Worker ID that initiated the event.
            /// </summary>
            public string ServiceWorkerRegistrationId
            {
                get; set;
            }
            /// <summary>
            /// The Background Service this event belongs to.
            /// </summary>
            public BackgroundServiceDomain.ServiceName Service
            {
                get; set;
            }
            /// <summary>
            /// A description of the event.
            /// </summary>
            public string EventName
            {
                get; set;
            }
            /// <summary>
            /// An identifier that groups related events together.
            /// </summary>
            public string InstanceId
            {
                get; set;
            }
            /// <summary>
            /// A list of event-specific information.
            /// </summary>
            public BackgroundServiceDomain.EventMetadata[] EventMetadata
            {
                get; set;
            }

        }

    }
    public class BrowserDomain : BaseDomain
    {
        public BrowserDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Browser";

            }

        }
        /// <summary>
        /// Fired when page is about to start a download.
        /// </summary>
        [Experimental]
        public event EventHandler<DownloadWillBeginParams>? DownloadWillBegin;
        /// <summary>
        /// Fired when download makes progress. Last call has |done| == true.
        /// </summary>
        [Experimental]
        public event EventHandler<DownloadProgressParams>? DownloadProgress;
        /// <summary>
        /// Set permission settings for given origin.
        /// </summary>
        [Experimental]
        public async ValueTask<SetPermissionResult> SetPermissionAsync(SetPermissionParams setPermissionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPermissionParams, cancellationToken);

        }
        /// <summary>
        /// Grant specific permissions to the given origin and reject all others.
        /// </summary>
        [Experimental]
        public async ValueTask<GrantPermissionsResult> GrantPermissionsAsync(GrantPermissionsParams grantPermissionsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(grantPermissionsParams, cancellationToken);

        }
        /// <summary>
        /// Reset all permission management for all origins.
        /// </summary>
        [Experimental]
        public async ValueTask<ResetPermissionsResult> ResetPermissionsAsync(ResetPermissionsParams resetPermissionsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resetPermissionsParams, cancellationToken);

        }
        /// <summary>
        /// Set the behavior when downloading a file.
        /// </summary>
        [Experimental]
        public async ValueTask<SetDownloadBehaviorResult> SetDownloadBehaviorAsync(SetDownloadBehaviorParams setDownloadBehaviorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDownloadBehaviorParams, cancellationToken);

        }
        /// <summary>
        /// Cancel a download if in progress
        /// </summary>
        [Experimental]
        public async ValueTask<CancelDownloadResult> CancelDownloadAsync(CancelDownloadParams cancelDownloadParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(cancelDownloadParams, cancellationToken);

        }
        /// <summary>
        /// Close browser gracefully.
        /// </summary>
        public async ValueTask<CloseResult> CloseAsync(CloseParams closeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(closeParams, cancellationToken);

        }
        /// <summary>
        /// Crashes browser on the main thread.
        /// </summary>
        [Experimental]
        public async ValueTask<CrashResult> CrashAsync(CrashParams crashParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(crashParams, cancellationToken);

        }
        /// <summary>
        /// Crashes GPU process.
        /// </summary>
        [Experimental]
        public async ValueTask<CrashGpuProcessResult> CrashGpuProcessAsync(CrashGpuProcessParams crashGpuProcessParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(crashGpuProcessParams, cancellationToken);

        }
        /// <summary>
        /// Returns version information.
        /// </summary>
        public async ValueTask<GetVersionResult> GetVersionAsync(GetVersionParams getVersionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getVersionParams, cancellationToken);

        }
        /// <summary>
        /// Returns the command line switches for the browser process if, and only if
        /// --enable-automation is on the commandline.
        /// </summary>
        [Experimental]
        public async ValueTask<GetBrowserCommandLineResult> GetBrowserCommandLineAsync(GetBrowserCommandLineParams getBrowserCommandLineParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getBrowserCommandLineParams, cancellationToken);

        }
        /// <summary>
        /// Get Chrome histograms.
        /// </summary>
        [Experimental]
        public async ValueTask<GetHistogramsResult> GetHistogramsAsync(GetHistogramsParams getHistogramsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getHistogramsParams, cancellationToken);

        }
        /// <summary>
        /// Get a Chrome histogram by name.
        /// </summary>
        [Experimental]
        public async ValueTask<GetHistogramResult> GetHistogramAsync(GetHistogramParams getHistogramParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getHistogramParams, cancellationToken);

        }
        /// <summary>
        /// Get position and size of the browser window.
        /// </summary>
        [Experimental]
        public async ValueTask<GetWindowBoundsResult> GetWindowBoundsAsync(GetWindowBoundsParams getWindowBoundsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getWindowBoundsParams, cancellationToken);

        }
        /// <summary>
        /// Get the browser window that contains the devtools target.
        /// </summary>
        [Experimental]
        public async ValueTask<GetWindowForTargetResult> GetWindowForTargetAsync(GetWindowForTargetParams getWindowForTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getWindowForTargetParams, cancellationToken);

        }
        /// <summary>
        /// Set position and/or size of the browser window.
        /// </summary>
        [Experimental]
        public async ValueTask<SetWindowBoundsResult> SetWindowBoundsAsync(SetWindowBoundsParams setWindowBoundsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setWindowBoundsParams, cancellationToken);

        }
        /// <summary>
        /// Set dock tile details, platform-specific.
        /// </summary>
        [Experimental]
        public async ValueTask<SetDockTileResult> SetDockTileAsync(SetDockTileParams setDockTileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDockTileParams, cancellationToken);

        }
        /// <summary>
        /// Invoke custom browser commands used by telemetry.
        /// </summary>
        [Experimental]
        public async ValueTask<ExecuteBrowserCommandResult> ExecuteBrowserCommandAsync(ExecuteBrowserCommandParams executeBrowserCommandParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(executeBrowserCommandParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "downloadWillBegin": RaiseEvent(DownloadWillBegin, messageBytes);
                    break;
                case "downloadProgress": RaiseEvent(DownloadProgress, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class DownloadWillBeginParams
        {
            /// <summary>
            /// Id of the frame that caused the download to begin.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Global unique identifier of the download.
            /// </summary>
            public string Guid
            {
                get; set;
            }
            /// <summary>
            /// URL of the resource being downloaded.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Suggested file name of the resource (the actual name of the file saved on disk may differ).
            /// </summary>
            public string SuggestedFilename
            {
                get; set;
            }

        }
        public class DownloadProgressParams
        {
            /// <summary>
            /// Global unique identifier of the download.
            /// </summary>
            public string Guid
            {
                get; set;
            }
            /// <summary>
            /// Total expected bytes to download.
            /// </summary>
            public double TotalBytes
            {
                get; set;
            }
            /// <summary>
            /// Total bytes received.
            /// </summary>
            public double ReceivedBytes
            {
                get; set;
            }
            /// <summary>
            /// Download status.
            /// </summary>
            /// <value>
            /// inProgress,completed,canceled
            /// </value>
            public string State
            {
                get; set;
            }

        }
        public class SetPermissionParams : IMethodParams<SetPermissionParams, SetPermissionResult>
        {
            public string GetMethod()
            {
                return "Browser.setPermission";

            }
            /// <summary>
            /// Descriptor of permission to override.
            /// </summary>
            public BrowserDomain.PermissionDescriptor Permission
            {
                get; set;
            }
            /// <summary>
            /// Setting of the permission.
            /// </summary>
            public BrowserDomain.PermissionSetting Setting
            {
                get; set;
            }
            /// <summary>
            /// Origin the permission applies to, all origins if not specified.
            /// </summary>
            public string? Origin
            {
                get; set;
            }
            /// <summary>
            /// Context to override. When omitted, default browser context is used.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class SetPermissionResult
        {

        }
        public class GrantPermissionsParams : IMethodParams<GrantPermissionsParams, GrantPermissionsResult>
        {
            public string GetMethod()
            {
                return "Browser.grantPermissions";

            }
            /// <summary>
            /// </summary>
            public BrowserDomain.PermissionType[] Permissions
            {
                get; set;
            }
            /// <summary>
            /// Origin the permission applies to, all origins if not specified.
            /// </summary>
            public string? Origin
            {
                get; set;
            }
            /// <summary>
            /// BrowserContext to override permissions. When omitted, default browser context is used.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class GrantPermissionsResult
        {

        }
        public class ResetPermissionsParams : IMethodParams<ResetPermissionsParams, ResetPermissionsResult>
        {
            public string GetMethod()
            {
                return "Browser.resetPermissions";

            }
            /// <summary>
            /// BrowserContext to reset permissions. When omitted, default browser context is used.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class ResetPermissionsResult
        {

        }
        public class SetDownloadBehaviorParams : IMethodParams<SetDownloadBehaviorParams, SetDownloadBehaviorResult>
        {
            public string GetMethod()
            {
                return "Browser.setDownloadBehavior";

            }
            /// <summary>
            /// Whether to allow all or deny all download requests, or use default Chrome behavior if
            /// available (otherwise deny). |allowAndName| allows download and names files according to
            /// their dowmload guids.
            /// </summary>
            /// <value>
            /// deny,allow,allowAndName,default
            /// </value>
            public string Behavior
            {
                get; set;
            }
            /// <summary>
            /// BrowserContext to set download behavior. When omitted, default browser context is used.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }
            /// <summary>
            /// The default path to save downloaded files to. This is required if behavior is set to 'allow'
            /// or 'allowAndName'.
            /// </summary>
            public string? DownloadPath
            {
                get; set;
            }
            /// <summary>
            /// Whether to emit download events (defaults to false).
            /// </summary>
            public bool? EventsEnabled
            {
                get; set;
            }

        }
        public class SetDownloadBehaviorResult
        {

        }
        public class CancelDownloadParams : IMethodParams<CancelDownloadParams, CancelDownloadResult>
        {
            public string GetMethod()
            {
                return "Browser.cancelDownload";

            }
            /// <summary>
            /// Global unique identifier of the download.
            /// </summary>
            public string Guid
            {
                get; set;
            }
            /// <summary>
            /// BrowserContext to perform the action in. When omitted, default browser context is used.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class CancelDownloadResult
        {

        }
        public class CloseParams : IMethodParams<CloseParams, CloseResult>
        {
            public string GetMethod()
            {
                return "Browser.close";

            }

        }
        public class CloseResult
        {

        }
        public class CrashParams : IMethodParams<CrashParams, CrashResult>
        {
            public string GetMethod()
            {
                return "Browser.crash";

            }

        }
        public class CrashResult
        {

        }
        public class CrashGpuProcessParams : IMethodParams<CrashGpuProcessParams, CrashGpuProcessResult>
        {
            public string GetMethod()
            {
                return "Browser.crashGpuProcess";

            }

        }
        public class CrashGpuProcessResult
        {

        }
        public class GetVersionParams : IMethodParams<GetVersionParams, GetVersionResult>
        {
            public string GetMethod()
            {
                return "Browser.getVersion";

            }

        }
        public class GetVersionResult
        {
            /// <summary>
            /// Protocol version.
            /// </summary>
            public string ProtocolVersion
            {
                get; set;
            }
            /// <summary>
            /// Product name.
            /// </summary>
            public string Product
            {
                get; set;
            }
            /// <summary>
            /// Product revision.
            /// </summary>
            public string Revision
            {
                get; set;
            }
            /// <summary>
            /// User-Agent.
            /// </summary>
            public string UserAgent
            {
                get; set;
            }
            /// <summary>
            /// V8 version.
            /// </summary>
            public string JsVersion
            {
                get; set;
            }

        }
        public class GetBrowserCommandLineParams : IMethodParams<GetBrowserCommandLineParams, GetBrowserCommandLineResult>
        {
            public string GetMethod()
            {
                return "Browser.getBrowserCommandLine";

            }

        }
        public class GetBrowserCommandLineResult
        {
            /// <summary>
            /// Commandline parameters
            /// </summary>
            public string[] Arguments
            {
                get; set;
            }

        }
        public class GetHistogramsParams : IMethodParams<GetHistogramsParams, GetHistogramsResult>
        {
            public string GetMethod()
            {
                return "Browser.getHistograms";

            }
            /// <summary>
            /// Requested substring in name. Only histograms which have query as a
            /// substring in their name are extracted. An empty or absent query returns
            /// all histograms.
            /// </summary>
            public string? Query
            {
                get; set;
            }
            /// <summary>
            /// If true, retrieve delta since last call.
            /// </summary>
            public bool? Delta
            {
                get; set;
            }

        }
        public class GetHistogramsResult
        {
            /// <summary>
            /// Histograms.
            /// </summary>
            public BrowserDomain.Histogram[] Histograms
            {
                get; set;
            }

        }
        public class GetHistogramParams : IMethodParams<GetHistogramParams, GetHistogramResult>
        {
            public string GetMethod()
            {
                return "Browser.getHistogram";

            }
            /// <summary>
            /// Requested histogram name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// If true, retrieve delta since last call.
            /// </summary>
            public bool? Delta
            {
                get; set;
            }

        }
        public class GetHistogramResult
        {
            /// <summary>
            /// Histogram.
            /// </summary>
            public BrowserDomain.Histogram Histogram
            {
                get; set;
            }

        }
        public class GetWindowBoundsParams : IMethodParams<GetWindowBoundsParams, GetWindowBoundsResult>
        {
            public string GetMethod()
            {
                return "Browser.getWindowBounds";

            }
            /// <summary>
            /// Browser window id.
            /// </summary>
            public int WindowId
            {
                get; set;
            }

        }
        public class GetWindowBoundsResult
        {
            /// <summary>
            /// Bounds information of the window. When window state is 'minimized', the restored window
            /// position and size are returned.
            /// </summary>
            public BrowserDomain.Bounds Bounds
            {
                get; set;
            }

        }
        public class GetWindowForTargetParams : IMethodParams<GetWindowForTargetParams, GetWindowForTargetResult>
        {
            public string GetMethod()
            {
                return "Browser.getWindowForTarget";

            }
            /// <summary>
            /// Devtools agent host id. If called as a part of the session, associated targetId is used.
            /// </summary>
            public string? TargetId
            {
                get; set;
            }

        }
        public class GetWindowForTargetResult
        {
            /// <summary>
            /// Browser window id.
            /// </summary>
            public int WindowId
            {
                get; set;
            }
            /// <summary>
            /// Bounds information of the window. When window state is 'minimized', the restored window
            /// position and size are returned.
            /// </summary>
            public BrowserDomain.Bounds Bounds
            {
                get; set;
            }

        }
        public class SetWindowBoundsParams : IMethodParams<SetWindowBoundsParams, SetWindowBoundsResult>
        {
            public string GetMethod()
            {
                return "Browser.setWindowBounds";

            }
            /// <summary>
            /// Browser window id.
            /// </summary>
            public int WindowId
            {
                get; set;
            }
            /// <summary>
            /// New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
            /// with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
            /// </summary>
            public BrowserDomain.Bounds Bounds
            {
                get; set;
            }

        }
        public class SetWindowBoundsResult
        {

        }
        public class SetDockTileParams : IMethodParams<SetDockTileParams, SetDockTileResult>
        {
            public string GetMethod()
            {
                return "Browser.setDockTile";

            }
            /// <summary>
            /// </summary>
            public string? BadgeLabel
            {
                get; set;
            }
            /// <summary>
            /// Png encoded image. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? Image
            {
                get; set;
            }

        }
        public class SetDockTileResult
        {

        }
        public class ExecuteBrowserCommandParams : IMethodParams<ExecuteBrowserCommandParams, ExecuteBrowserCommandResult>
        {
            public string GetMethod()
            {
                return "Browser.executeBrowserCommand";

            }
            /// <summary>
            /// </summary>
            public BrowserDomain.BrowserCommandId CommandId
            {
                get; set;
            }

        }
        public class ExecuteBrowserCommandResult
        {

        }
        /// <summary>
        /// The state of the browser window.
        /// </summary>
        [Experimental]
        public enum WindowState
        {
            [EnumValue("normal")]
            Normal = 1,
            [EnumValue("minimized")]
            Minimized = 2,
            [EnumValue("maximized")]
            Maximized = 3,
            [EnumValue("fullscreen")]
            Fullscreen = 4,

        }
        /// <summary>
        /// Browser window bounds information
        /// </summary>
        [Experimental]
        public class Bounds
        {
            /// <summary>
            /// The offset from the left edge of the screen to the window in pixels.
            /// </summary>
            public int? Left
            {
                get; set;
            }
            /// <summary>
            /// The offset from the top edge of the screen to the window in pixels.
            /// </summary>
            public int? Top
            {
                get; set;
            }
            /// <summary>
            /// The window width in pixels.
            /// </summary>
            public int? Width
            {
                get; set;
            }
            /// <summary>
            /// The window height in pixels.
            /// </summary>
            public int? Height
            {
                get; set;
            }
            /// <summary>
            /// The window state. Default to normal.
            /// </summary>
            public BrowserDomain.WindowState? WindowState
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum PermissionType
        {
            [EnumValue("accessibilityEvents")]
            AccessibilityEvents = 1,
            [EnumValue("audioCapture")]
            AudioCapture = 2,
            [EnumValue("backgroundSync")]
            BackgroundSync = 3,
            [EnumValue("backgroundFetch")]
            BackgroundFetch = 4,
            [EnumValue("clipboardReadWrite")]
            ClipboardReadWrite = 5,
            [EnumValue("clipboardSanitizedWrite")]
            ClipboardSanitizedWrite = 6,
            [EnumValue("displayCapture")]
            DisplayCapture = 7,
            [EnumValue("durableStorage")]
            DurableStorage = 8,
            [EnumValue("flash")]
            Flash = 9,
            [EnumValue("geolocation")]
            Geolocation = 10,
            [EnumValue("midi")]
            Midi = 11,
            [EnumValue("midiSysex")]
            MidiSysex = 12,
            [EnumValue("nfc")]
            Nfc = 13,
            [EnumValue("notifications")]
            Notifications = 14,
            [EnumValue("paymentHandler")]
            PaymentHandler = 15,
            [EnumValue("periodicBackgroundSync")]
            PeriodicBackgroundSync = 16,
            [EnumValue("protectedMediaIdentifier")]
            ProtectedMediaIdentifier = 17,
            [EnumValue("sensors")]
            Sensors = 18,
            [EnumValue("videoCapture")]
            VideoCapture = 19,
            [EnumValue("videoCapturePanTiltZoom")]
            VideoCapturePanTiltZoom = 20,
            [EnumValue("idleDetection")]
            IdleDetection = 21,
            [EnumValue("wakeLockScreen")]
            WakeLockScreen = 22,
            [EnumValue("wakeLockSystem")]
            WakeLockSystem = 23,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum PermissionSetting
        {
            [EnumValue("granted")]
            Granted = 1,
            [EnumValue("denied")]
            Denied = 2,
            [EnumValue("prompt")]
            Prompt = 3,

        }
        /// <summary>
        /// Definition of PermissionDescriptor defined in the Permissions API:
        /// https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
        /// </summary>
        [Experimental]
        public class PermissionDescriptor
        {
            /// <summary>
            /// Name of permission.
            /// See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// For "midi" permission, may also specify sysex control.
            /// </summary>
            public bool? Sysex
            {
                get; set;
            }
            /// <summary>
            /// For "push" permission, may specify userVisibleOnly.
            /// Note that userVisibleOnly = true is the only currently supported type.
            /// </summary>
            public bool? UserVisibleOnly
            {
                get; set;
            }
            /// <summary>
            /// For "clipboard" permission, may specify allowWithoutSanitization.
            /// </summary>
            public bool? AllowWithoutSanitization
            {
                get; set;
            }
            /// <summary>
            /// For "camera" permission, may specify panTiltZoom.
            /// </summary>
            public bool? PanTiltZoom
            {
                get; set;
            }

        }
        /// <summary>
        /// Browser command ids used by executeBrowserCommand.
        /// </summary>
        [Experimental]
        public enum BrowserCommandId
        {
            [EnumValue("openTabSearch")]
            OpenTabSearch = 1,
            [EnumValue("closeTabSearch")]
            CloseTabSearch = 2,

        }
        /// <summary>
        /// Chrome histogram bucket.
        /// </summary>
        [Experimental]
        public class Bucket
        {
            /// <summary>
            /// Minimum value (inclusive).
            /// </summary>
            public int Low
            {
                get; set;
            }
            /// <summary>
            /// Maximum value (exclusive).
            /// </summary>
            public int High
            {
                get; set;
            }
            /// <summary>
            /// Number of samples.
            /// </summary>
            public int Count
            {
                get; set;
            }

        }
        /// <summary>
        /// Chrome histogram.
        /// </summary>
        [Experimental]
        public class Histogram
        {
            /// <summary>
            /// Name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Sum of sample values.
            /// </summary>
            public int Sum
            {
                get; set;
            }
            /// <summary>
            /// Total number of samples.
            /// </summary>
            public int Count
            {
                get; set;
            }
            /// <summary>
            /// Buckets.
            /// </summary>
            public BrowserDomain.Bucket[] Buckets
            {
                get; set;
            }

        }

    }
    public class CSSDomain : BaseDomain
    {
        public CSSDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "CSS";

            }

        }
        /// <summary>
        /// Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
        /// web font
        /// </summary>
        public event EventHandler<FontsUpdatedParams>? FontsUpdated;
        /// <summary>
        /// Fires whenever a MediaQuery result changes (for example, after a browser window has been
        /// resized.) The current implementation considers only viewport-dependent media features.
        /// </summary>
        public event EventHandler<MediaQueryResultChangedParams>? MediaQueryResultChanged;
        /// <summary>
        /// Fired whenever an active document stylesheet is added.
        /// </summary>
        public event EventHandler<StyleSheetAddedParams>? StyleSheetAdded;
        /// <summary>
        /// Fired whenever a stylesheet is changed as a result of the client operation.
        /// </summary>
        public event EventHandler<StyleSheetChangedParams>? StyleSheetChanged;
        /// <summary>
        /// Fired whenever an active document stylesheet is removed.
        /// </summary>
        public event EventHandler<StyleSheetRemovedParams>? StyleSheetRemoved;
        /// <summary>
        /// Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
        /// position specified by `location`.
        /// </summary>
        public async ValueTask<AddRuleResult> AddRuleAsync(AddRuleParams addRuleParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addRuleParams, cancellationToken);

        }
        /// <summary>
        /// Returns all class names from specified stylesheet.
        /// </summary>
        public async ValueTask<CollectClassNamesResult> CollectClassNamesAsync(CollectClassNamesParams collectClassNamesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(collectClassNamesParams, cancellationToken);

        }
        /// <summary>
        /// Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
        /// </summary>
        public async ValueTask<CreateStyleSheetResult> CreateStyleSheetAsync(CreateStyleSheetParams createStyleSheetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(createStyleSheetParams, cancellationToken);

        }
        /// <summary>
        /// Disables the CSS agent for the given page.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
        /// enabled until the result of this command is received.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Ensures that the given node will have specified pseudo-classes whenever its style is computed by
        /// the browser.
        /// </summary>
        public async ValueTask<ForcePseudoStateResult> ForcePseudoStateAsync(ForcePseudoStateParams forcePseudoStateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(forcePseudoStateParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetBackgroundColorsResult> GetBackgroundColorsAsync(GetBackgroundColorsParams getBackgroundColorsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getBackgroundColorsParams, cancellationToken);

        }
        /// <summary>
        /// Returns the computed style for a DOM node identified by `nodeId`.
        /// </summary>
        public async ValueTask<GetComputedStyleForNodeResult> GetComputedStyleForNodeAsync(GetComputedStyleForNodeParams getComputedStyleForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getComputedStyleForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
        /// attributes) for a DOM node identified by `nodeId`.
        /// </summary>
        public async ValueTask<GetInlineStylesForNodeResult> GetInlineStylesForNodeAsync(GetInlineStylesForNodeParams getInlineStylesForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getInlineStylesForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Returns requested styles for a DOM node identified by `nodeId`.
        /// </summary>
        public async ValueTask<GetMatchedStylesForNodeResult> GetMatchedStylesForNodeAsync(GetMatchedStylesForNodeParams getMatchedStylesForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getMatchedStylesForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Returns all media queries parsed by the rendering engine.
        /// </summary>
        public async ValueTask<GetMediaQueriesResult> GetMediaQueriesAsync(GetMediaQueriesParams getMediaQueriesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getMediaQueriesParams, cancellationToken);

        }
        /// <summary>
        /// Requests information about platform fonts which we used to render child TextNodes in the given
        /// node.
        /// </summary>
        public async ValueTask<GetPlatformFontsForNodeResult> GetPlatformFontsForNodeAsync(GetPlatformFontsForNodeParams getPlatformFontsForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getPlatformFontsForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Returns the current textual content for a stylesheet.
        /// </summary>
        public async ValueTask<GetStyleSheetTextResult> GetStyleSheetTextAsync(GetStyleSheetTextParams getStyleSheetTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getStyleSheetTextParams, cancellationToken);

        }
        /// <summary>
        /// Returns all layers parsed by the rendering engine for the tree scope of a node.
        /// Given a DOM element identified by nodeId, getLayersForNode returns the root
        /// layer for the nearest ancestor document or shadow root. The layer root contains
        /// the full layer tree for the tree scope and their ordering.
        /// </summary>
        [Experimental]
        public async ValueTask<GetLayersForNodeResult> GetLayersForNodeAsync(GetLayersForNodeParams getLayersForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getLayersForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Starts tracking the given computed styles for updates. The specified array of properties
        /// replaces the one previously specified. Pass empty array to disable tracking.
        /// Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
        /// The changes to computed style properties are only tracked for nodes pushed to the front-end
        /// by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
        /// to the front-end, no updates will be issued for the node.
        /// </summary>
        [Experimental]
        public async ValueTask<TrackComputedStyleUpdatesResult> TrackComputedStyleUpdatesAsync(TrackComputedStyleUpdatesParams trackComputedStyleUpdatesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(trackComputedStyleUpdatesParams, cancellationToken);

        }
        /// <summary>
        /// Polls the next batch of computed style updates.
        /// </summary>
        [Experimental]
        public async ValueTask<TakeComputedStyleUpdatesResult> TakeComputedStyleUpdatesAsync(TakeComputedStyleUpdatesParams takeComputedStyleUpdatesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takeComputedStyleUpdatesParams, cancellationToken);

        }
        /// <summary>
        /// Find a rule with the given active property for the given node and set the new value for this
        /// property
        /// </summary>
        public async ValueTask<SetEffectivePropertyValueForNodeResult> SetEffectivePropertyValueForNodeAsync(SetEffectivePropertyValueForNodeParams setEffectivePropertyValueForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setEffectivePropertyValueForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Modifies the keyframe rule key text.
        /// </summary>
        public async ValueTask<SetKeyframeKeyResult> SetKeyframeKeyAsync(SetKeyframeKeyParams setKeyframeKeyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setKeyframeKeyParams, cancellationToken);

        }
        /// <summary>
        /// Modifies the rule selector.
        /// </summary>
        public async ValueTask<SetMediaTextResult> SetMediaTextAsync(SetMediaTextParams setMediaTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setMediaTextParams, cancellationToken);

        }
        /// <summary>
        /// Modifies the expression of a container query.
        /// </summary>
        [Experimental]
        public async ValueTask<SetContainerQueryTextResult> SetContainerQueryTextAsync(SetContainerQueryTextParams setContainerQueryTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setContainerQueryTextParams, cancellationToken);

        }
        /// <summary>
        /// Modifies the expression of a supports at-rule.
        /// </summary>
        [Experimental]
        public async ValueTask<SetSupportsTextResult> SetSupportsTextAsync(SetSupportsTextParams setSupportsTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setSupportsTextParams, cancellationToken);

        }
        /// <summary>
        /// Modifies the expression of a scope at-rule.
        /// </summary>
        [Experimental]
        public async ValueTask<SetScopeTextResult> SetScopeTextAsync(SetScopeTextParams setScopeTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setScopeTextParams, cancellationToken);

        }
        /// <summary>
        /// Modifies the rule selector.
        /// </summary>
        public async ValueTask<SetRuleSelectorResult> SetRuleSelectorAsync(SetRuleSelectorParams setRuleSelectorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setRuleSelectorParams, cancellationToken);

        }
        /// <summary>
        /// Sets the new stylesheet text.
        /// </summary>
        public async ValueTask<SetStyleSheetTextResult> SetStyleSheetTextAsync(SetStyleSheetTextParams setStyleSheetTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setStyleSheetTextParams, cancellationToken);

        }
        /// <summary>
        /// Applies specified style edits one after another in the given order.
        /// </summary>
        public async ValueTask<SetStyleTextsResult> SetStyleTextsAsync(SetStyleTextsParams setStyleTextsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setStyleTextsParams, cancellationToken);

        }
        /// <summary>
        /// Enables the selector recording.
        /// </summary>
        public async ValueTask<StartRuleUsageTrackingResult> StartRuleUsageTrackingAsync(StartRuleUsageTrackingParams startRuleUsageTrackingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startRuleUsageTrackingParams, cancellationToken);

        }
        /// <summary>
        /// Stop tracking rule usage and return the list of rules that were used since last call to
        /// `takeCoverageDelta` (or since start of coverage instrumentation)
        /// </summary>
        public async ValueTask<StopRuleUsageTrackingResult> StopRuleUsageTrackingAsync(StopRuleUsageTrackingParams stopRuleUsageTrackingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopRuleUsageTrackingParams, cancellationToken);

        }
        /// <summary>
        /// Obtain list of rules that became used since last call to this method (or since start of coverage
        /// instrumentation)
        /// </summary>
        public async ValueTask<TakeCoverageDeltaResult> TakeCoverageDeltaAsync(TakeCoverageDeltaParams takeCoverageDeltaParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takeCoverageDeltaParams, cancellationToken);

        }
        /// <summary>
        /// Enables/disables rendering of local CSS fonts (enabled by default).
        /// </summary>
        [Experimental]
        public async ValueTask<SetLocalFontsEnabledResult> SetLocalFontsEnabledAsync(SetLocalFontsEnabledParams setLocalFontsEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setLocalFontsEnabledParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "fontsUpdated": RaiseEvent(FontsUpdated, messageBytes);
                    break;
                case "mediaQueryResultChanged": RaiseEvent(MediaQueryResultChanged, messageBytes);
                    break;
                case "styleSheetAdded": RaiseEvent(StyleSheetAdded, messageBytes);
                    break;
                case "styleSheetChanged": RaiseEvent(StyleSheetChanged, messageBytes);
                    break;
                case "styleSheetRemoved": RaiseEvent(StyleSheetRemoved, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class FontsUpdatedParams
        {
            /// <summary>
            /// The web font that has loaded.
            /// </summary>
            public CSSDomain.FontFace? Font
            {
                get; set;
            }

        }
        public class MediaQueryResultChangedParams
        {

        }
        public class StyleSheetAddedParams
        {
            /// <summary>
            /// Added stylesheet metainfo.
            /// </summary>
            public CSSDomain.CSSStyleSheetHeader Header
            {
                get; set;
            }

        }
        public class StyleSheetChangedParams
        {
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }

        }
        public class StyleSheetRemovedParams
        {
            /// <summary>
            /// Identifier of the removed stylesheet.
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }

        }
        public class AddRuleParams : IMethodParams<AddRuleParams, AddRuleResult>
        {
            public string GetMethod()
            {
                return "CSS.addRule";

            }
            /// <summary>
            /// The css style sheet identifier where a new rule should be inserted.
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// The text of a new rule.
            /// </summary>
            public string RuleText
            {
                get; set;
            }
            /// <summary>
            /// Text position of a new rule in the target style sheet.
            /// </summary>
            public CSSDomain.SourceRange Location
            {
                get; set;
            }

        }
        public class AddRuleResult
        {
            /// <summary>
            /// The newly created rule.
            /// </summary>
            public CSSDomain.CSSRule Rule
            {
                get; set;
            }

        }
        public class CollectClassNamesParams : IMethodParams<CollectClassNamesParams, CollectClassNamesResult>
        {
            public string GetMethod()
            {
                return "CSS.collectClassNames";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }

        }
        public class CollectClassNamesResult
        {
            /// <summary>
            /// Class name list.
            /// </summary>
            public string[] ClassNames
            {
                get; set;
            }

        }
        public class CreateStyleSheetParams : IMethodParams<CreateStyleSheetParams, CreateStyleSheetResult>
        {
            public string GetMethod()
            {
                return "CSS.createStyleSheet";

            }
            /// <summary>
            /// Identifier of the frame where "via-inspector" stylesheet should be created.
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class CreateStyleSheetResult
        {
            /// <summary>
            /// Identifier of the created "via-inspector" stylesheet.
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "CSS.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "CSS.enable";

            }

        }
        public class EnableResult
        {

        }
        public class ForcePseudoStateParams : IMethodParams<ForcePseudoStateParams, ForcePseudoStateResult>
        {
            public string GetMethod()
            {
                return "CSS.forcePseudoState";

            }
            /// <summary>
            /// The element id for which to force the pseudo state.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Element pseudo classes to force when computing the element's style.
            /// </summary>
            public string[] ForcedPseudoClasses
            {
                get; set;
            }

        }
        public class ForcePseudoStateResult
        {

        }
        public class GetBackgroundColorsParams : IMethodParams<GetBackgroundColorsParams, GetBackgroundColorsResult>
        {
            public string GetMethod()
            {
                return "CSS.getBackgroundColors";

            }
            /// <summary>
            /// Id of the node to get background colors for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetBackgroundColorsResult
        {
            /// <summary>
            /// The range of background colors behind this element, if it contains any visible text. If no
            /// visible text is present, this will be undefined. In the case of a flat background color,
            /// this will consist of simply that color. In the case of a gradient, this will consist of each
            /// of the color stops. For anything more complicated, this will be an empty array. Images will
            /// be ignored (as if the image had failed to load).
            /// </summary>
            public string[]? BackgroundColors
            {
                get; set;
            }
            /// <summary>
            /// The computed font size for this node, as a CSS computed value string (e.g. '12px').
            /// </summary>
            public string? ComputedFontSize
            {
                get; set;
            }
            /// <summary>
            /// The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
            /// '100').
            /// </summary>
            public string? ComputedFontWeight
            {
                get; set;
            }

        }
        public class GetComputedStyleForNodeParams : IMethodParams<GetComputedStyleForNodeParams, GetComputedStyleForNodeResult>
        {
            public string GetMethod()
            {
                return "CSS.getComputedStyleForNode";

            }
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetComputedStyleForNodeResult
        {
            /// <summary>
            /// Computed style for the specified DOM node.
            /// </summary>
            public CSSDomain.CSSComputedStyleProperty[] ComputedStyle
            {
                get; set;
            }

        }
        public class GetInlineStylesForNodeParams : IMethodParams<GetInlineStylesForNodeParams, GetInlineStylesForNodeResult>
        {
            public string GetMethod()
            {
                return "CSS.getInlineStylesForNode";

            }
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetInlineStylesForNodeResult
        {
            /// <summary>
            /// Inline style for the specified DOM node.
            /// </summary>
            public CSSDomain.CSSStyle? InlineStyle
            {
                get; set;
            }
            /// <summary>
            /// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
            /// </summary>
            public CSSDomain.CSSStyle? AttributesStyle
            {
                get; set;
            }

        }
        public class GetMatchedStylesForNodeParams : IMethodParams<GetMatchedStylesForNodeParams, GetMatchedStylesForNodeResult>
        {
            public string GetMethod()
            {
                return "CSS.getMatchedStylesForNode";

            }
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetMatchedStylesForNodeResult
        {
            /// <summary>
            /// Inline style for the specified DOM node.
            /// </summary>
            public CSSDomain.CSSStyle? InlineStyle
            {
                get; set;
            }
            /// <summary>
            /// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
            /// </summary>
            public CSSDomain.CSSStyle? AttributesStyle
            {
                get; set;
            }
            /// <summary>
            /// CSS rules matching this node, from all applicable stylesheets.
            /// </summary>
            public CSSDomain.RuleMatch[]? MatchedCSSRules
            {
                get; set;
            }
            /// <summary>
            /// Pseudo style matches for this node.
            /// </summary>
            public CSSDomain.PseudoElementMatches[]? PseudoElements
            {
                get; set;
            }
            /// <summary>
            /// A chain of inherited styles (from the immediate node parent up to the DOM tree root).
            /// </summary>
            public CSSDomain.InheritedStyleEntry[]? Inherited
            {
                get; set;
            }
            /// <summary>
            /// A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
            /// </summary>
            public CSSDomain.InheritedPseudoElementMatches[]? InheritedPseudoElements
            {
                get; set;
            }
            /// <summary>
            /// A list of CSS keyframed animations matching this node.
            /// </summary>
            public CSSDomain.CSSKeyframesRule[]? CssKeyframesRules
            {
                get; set;
            }
            /// <summary>
            /// Id of the first parent element that does not have display: contents.
            /// </summary>
            [Experimental]
            public int? ParentLayoutNodeId
            {
                get; set;
            }

        }
        public class GetMediaQueriesParams : IMethodParams<GetMediaQueriesParams, GetMediaQueriesResult>
        {
            public string GetMethod()
            {
                return "CSS.getMediaQueries";

            }

        }
        public class GetMediaQueriesResult
        {
            /// <summary>
            /// </summary>
            public CSSDomain.CSSMedia[] Medias
            {
                get; set;
            }

        }
        public class GetPlatformFontsForNodeParams : IMethodParams<GetPlatformFontsForNodeParams, GetPlatformFontsForNodeResult>
        {
            public string GetMethod()
            {
                return "CSS.getPlatformFontsForNode";

            }
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetPlatformFontsForNodeResult
        {
            /// <summary>
            /// Usage statistics for every employed platform font.
            /// </summary>
            public CSSDomain.PlatformFontUsage[] Fonts
            {
                get; set;
            }

        }
        public class GetStyleSheetTextParams : IMethodParams<GetStyleSheetTextParams, GetStyleSheetTextResult>
        {
            public string GetMethod()
            {
                return "CSS.getStyleSheetText";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }

        }
        public class GetStyleSheetTextResult
        {
            /// <summary>
            /// The stylesheet text.
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class GetLayersForNodeParams : IMethodParams<GetLayersForNodeParams, GetLayersForNodeResult>
        {
            public string GetMethod()
            {
                return "CSS.getLayersForNode";

            }
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetLayersForNodeResult
        {
            /// <summary>
            /// </summary>
            public CSSDomain.CSSLayerData RootLayer
            {
                get; set;
            }

        }
        public class TrackComputedStyleUpdatesParams : IMethodParams<TrackComputedStyleUpdatesParams, TrackComputedStyleUpdatesResult>
        {
            public string GetMethod()
            {
                return "CSS.trackComputedStyleUpdates";

            }
            /// <summary>
            /// </summary>
            public CSSDomain.CSSComputedStyleProperty[] PropertiesToTrack
            {
                get; set;
            }

        }
        public class TrackComputedStyleUpdatesResult
        {

        }
        public class TakeComputedStyleUpdatesParams : IMethodParams<TakeComputedStyleUpdatesParams, TakeComputedStyleUpdatesResult>
        {
            public string GetMethod()
            {
                return "CSS.takeComputedStyleUpdates";

            }

        }
        public class TakeComputedStyleUpdatesResult
        {
            /// <summary>
            /// The list of node Ids that have their tracked computed styles updated
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class SetEffectivePropertyValueForNodeParams : IMethodParams<SetEffectivePropertyValueForNodeParams, SetEffectivePropertyValueForNodeResult>
        {
            public string GetMethod()
            {
                return "CSS.setEffectivePropertyValueForNode";

            }
            /// <summary>
            /// The element id for which to set property.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string PropertyName
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        public class SetEffectivePropertyValueForNodeResult
        {

        }
        public class SetKeyframeKeyParams : IMethodParams<SetKeyframeKeyParams, SetKeyframeKeyResult>
        {
            public string GetMethod()
            {
                return "CSS.setKeyframeKey";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string KeyText
            {
                get; set;
            }

        }
        public class SetKeyframeKeyResult
        {
            /// <summary>
            /// The resulting key text after modification.
            /// </summary>
            public CSSDomain.Value KeyText
            {
                get; set;
            }

        }
        public class SetMediaTextParams : IMethodParams<SetMediaTextParams, SetMediaTextResult>
        {
            public string GetMethod()
            {
                return "CSS.setMediaText";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class SetMediaTextResult
        {
            /// <summary>
            /// The resulting CSS media rule after modification.
            /// </summary>
            public CSSDomain.CSSMedia Media
            {
                get; set;
            }

        }
        public class SetContainerQueryTextParams : IMethodParams<SetContainerQueryTextParams, SetContainerQueryTextResult>
        {
            public string GetMethod()
            {
                return "CSS.setContainerQueryText";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class SetContainerQueryTextResult
        {
            /// <summary>
            /// The resulting CSS container query rule after modification.
            /// </summary>
            public CSSDomain.CSSContainerQuery ContainerQuery
            {
                get; set;
            }

        }
        public class SetSupportsTextParams : IMethodParams<SetSupportsTextParams, SetSupportsTextResult>
        {
            public string GetMethod()
            {
                return "CSS.setSupportsText";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class SetSupportsTextResult
        {
            /// <summary>
            /// The resulting CSS Supports rule after modification.
            /// </summary>
            public CSSDomain.CSSSupports Supports
            {
                get; set;
            }

        }
        public class SetScopeTextParams : IMethodParams<SetScopeTextParams, SetScopeTextResult>
        {
            public string GetMethod()
            {
                return "CSS.setScopeText";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class SetScopeTextResult
        {
            /// <summary>
            /// The resulting CSS Scope rule after modification.
            /// </summary>
            public CSSDomain.CSSScope Scope
            {
                get; set;
            }

        }
        public class SetRuleSelectorParams : IMethodParams<SetRuleSelectorParams, SetRuleSelectorResult>
        {
            public string GetMethod()
            {
                return "CSS.setRuleSelector";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Selector
            {
                get; set;
            }

        }
        public class SetRuleSelectorResult
        {
            /// <summary>
            /// The resulting selector list after modification.
            /// </summary>
            public CSSDomain.SelectorList SelectorList
            {
                get; set;
            }

        }
        public class SetStyleSheetTextParams : IMethodParams<SetStyleSheetTextParams, SetStyleSheetTextResult>
        {
            public string GetMethod()
            {
                return "CSS.setStyleSheetText";

            }
            /// <summary>
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class SetStyleSheetTextResult
        {
            /// <summary>
            /// URL of source map associated with script (if any).
            /// </summary>
            public string? SourceMapURL
            {
                get; set;
            }

        }
        public class SetStyleTextsParams : IMethodParams<SetStyleTextsParams, SetStyleTextsResult>
        {
            public string GetMethod()
            {
                return "CSS.setStyleTexts";

            }
            /// <summary>
            /// </summary>
            public CSSDomain.StyleDeclarationEdit[] Edits
            {
                get; set;
            }

        }
        public class SetStyleTextsResult
        {
            /// <summary>
            /// The resulting styles after modification.
            /// </summary>
            public CSSDomain.CSSStyle[] Styles
            {
                get; set;
            }

        }
        public class StartRuleUsageTrackingParams : IMethodParams<StartRuleUsageTrackingParams, StartRuleUsageTrackingResult>
        {
            public string GetMethod()
            {
                return "CSS.startRuleUsageTracking";

            }

        }
        public class StartRuleUsageTrackingResult
        {

        }
        public class StopRuleUsageTrackingParams : IMethodParams<StopRuleUsageTrackingParams, StopRuleUsageTrackingResult>
        {
            public string GetMethod()
            {
                return "CSS.stopRuleUsageTracking";

            }

        }
        public class StopRuleUsageTrackingResult
        {
            /// <summary>
            /// </summary>
            public CSSDomain.RuleUsage[] RuleUsage
            {
                get; set;
            }

        }
        public class TakeCoverageDeltaParams : IMethodParams<TakeCoverageDeltaParams, TakeCoverageDeltaResult>
        {
            public string GetMethod()
            {
                return "CSS.takeCoverageDelta";

            }

        }
        public class TakeCoverageDeltaResult
        {
            /// <summary>
            /// </summary>
            public CSSDomain.RuleUsage[] Coverage
            {
                get; set;
            }
            /// <summary>
            /// Monotonically increasing time, in seconds.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class SetLocalFontsEnabledParams : IMethodParams<SetLocalFontsEnabledParams, SetLocalFontsEnabledResult>
        {
            public string GetMethod()
            {
                return "CSS.setLocalFontsEnabled";

            }
            /// <summary>
            /// Whether rendering of local fonts is enabled.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetLocalFontsEnabledResult
        {

        }
        /// <summary>
        /// Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
        /// stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
        /// inspector" rules), "regular" for regular stylesheets.
        /// </summary>
        public enum StyleSheetOrigin
        {
            [EnumValue("injected")]
            Injected = 1,
            [EnumValue("user-agent")]
            UserAgent = 2,
            [EnumValue("inspector")]
            Inspector = 3,
            [EnumValue("regular")]
            Regular = 4,

        }
        /// <summary>
        /// CSS rule collection for a single pseudo style.
        /// </summary>
        public class PseudoElementMatches
        {
            /// <summary>
            /// Pseudo element type.
            /// </summary>
            public DOMDomain.PseudoType PseudoType
            {
                get; set;
            }
            /// <summary>
            /// Pseudo element custom ident.
            /// </summary>
            public string? PseudoIdentifier
            {
                get; set;
            }
            /// <summary>
            /// Matches of CSS rules applicable to the pseudo style.
            /// </summary>
            public CSSDomain.RuleMatch[] Matches
            {
                get; set;
            }

        }
        /// <summary>
        /// Inherited CSS rule collection from ancestor node.
        /// </summary>
        public class InheritedStyleEntry
        {
            /// <summary>
            /// The ancestor node's inline style, if any, in the style inheritance chain.
            /// </summary>
            public CSSDomain.CSSStyle? InlineStyle
            {
                get; set;
            }
            /// <summary>
            /// Matches of CSS rules matching the ancestor node in the style inheritance chain.
            /// </summary>
            public CSSDomain.RuleMatch[] MatchedCSSRules
            {
                get; set;
            }

        }
        /// <summary>
        /// Inherited pseudo element matches from pseudos of an ancestor node.
        /// </summary>
        public class InheritedPseudoElementMatches
        {
            /// <summary>
            /// Matches of pseudo styles from the pseudos of an ancestor node.
            /// </summary>
            public CSSDomain.PseudoElementMatches[] PseudoElements
            {
                get; set;
            }

        }
        /// <summary>
        /// Match data for a CSS rule.
        /// </summary>
        public class RuleMatch
        {
            /// <summary>
            /// CSS rule in the match.
            /// </summary>
            public CSSDomain.CSSRule Rule
            {
                get; set;
            }
            /// <summary>
            /// Matching selector indices in the rule's selectorList selectors (0-based).
            /// </summary>
            public int[] MatchingSelectors
            {
                get; set;
            }

        }
        /// <summary>
        /// Data for a simple selector (these are delimited by commas in a selector list).
        /// </summary>
        public class Value
        {
            /// <summary>
            /// Value text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// Value range in the underlying resource (if available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }

        }
        /// <summary>
        /// Selector list data.
        /// </summary>
        public class SelectorList
        {
            /// <summary>
            /// Selectors in the list.
            /// </summary>
            public CSSDomain.Value[] Selectors
            {
                get; set;
            }
            /// <summary>
            /// Rule selector text.
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS stylesheet metainformation.
        /// </summary>
        public class CSSStyleSheetHeader
        {
            /// <summary>
            /// The stylesheet identifier.
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// Owner frame identifier.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Stylesheet resource URL. Empty if this is a constructed stylesheet created using
            /// new CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported
            /// as a CSS module script).
            /// </summary>
            public string SourceURL
            {
                get; set;
            }
            /// <summary>
            /// URL of source map associated with the stylesheet (if any).
            /// </summary>
            public string? SourceMapURL
            {
                get; set;
            }
            /// <summary>
            /// Stylesheet origin.
            /// </summary>
            public CSSDomain.StyleSheetOrigin Origin
            {
                get; set;
            }
            /// <summary>
            /// Stylesheet title.
            /// </summary>
            public string Title
            {
                get; set;
            }
            /// <summary>
            /// The backend id for the owner node of the stylesheet.
            /// </summary>
            public int? OwnerNode
            {
                get; set;
            }
            /// <summary>
            /// Denotes whether the stylesheet is disabled.
            /// </summary>
            public bool Disabled
            {
                get; set;
            }
            /// <summary>
            /// Whether the sourceURL field value comes from the sourceURL comment.
            /// </summary>
            public bool? HasSourceURL
            {
                get; set;
            }
            /// <summary>
            /// Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
            /// document.written STYLE tags.
            /// </summary>
            public bool IsInline
            {
                get; set;
            }
            /// <summary>
            /// Whether this stylesheet is mutable. Inline stylesheets become mutable
            /// after they have been modified via CSSOM API.
            /// <link> element's stylesheets become mutable only if DevTools modifies them.
            /// Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
            /// </summary>
            public bool IsMutable
            {
                get; set;
            }
            /// <summary>
            /// True if this stylesheet is created through new CSSStyleSheet() or imported as a
            /// CSS module script.
            /// </summary>
            public bool IsConstructed
            {
                get; set;
            }
            /// <summary>
            /// Line offset of the stylesheet within the resource (zero based).
            /// </summary>
            public double StartLine
            {
                get; set;
            }
            /// <summary>
            /// Column offset of the stylesheet within the resource (zero based).
            /// </summary>
            public double StartColumn
            {
                get; set;
            }
            /// <summary>
            /// Size of the content (in characters).
            /// </summary>
            public double Length
            {
                get; set;
            }
            /// <summary>
            /// Line offset of the end of the stylesheet within the resource (zero based).
            /// </summary>
            public double EndLine
            {
                get; set;
            }
            /// <summary>
            /// Column offset of the end of the stylesheet within the resource (zero based).
            /// </summary>
            public double EndColumn
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS rule representation.
        /// </summary>
        public class CSSRule
        {
            /// <summary>
            /// The css style sheet identifier (absent for user agent stylesheet and user-specified
            /// stylesheet rules) this rule came from.
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// Rule selector data.
            /// </summary>
            public CSSDomain.SelectorList SelectorList
            {
                get; set;
            }
            /// <summary>
            /// Parent stylesheet's origin.
            /// </summary>
            public CSSDomain.StyleSheetOrigin Origin
            {
                get; set;
            }
            /// <summary>
            /// Associated style declaration.
            /// </summary>
            public CSSDomain.CSSStyle Style
            {
                get; set;
            }
            /// <summary>
            /// Media list array (for rules involving media queries). The array enumerates media queries
            /// starting with the innermost one, going outwards.
            /// </summary>
            public CSSDomain.CSSMedia[]? Media
            {
                get; set;
            }
            /// <summary>
            /// Container query list array (for rules involving container queries).
            /// The array enumerates container queries starting with the innermost one, going outwards.
            /// </summary>
            [Experimental]
            public CSSDomain.CSSContainerQuery[]? ContainerQueries
            {
                get; set;
            }
            /// <summary>
            /// @supports CSS at-rule array.
            /// The array enumerates @supports at-rules starting with the innermost one, going outwards.
            /// </summary>
            [Experimental]
            public CSSDomain.CSSSupports[]? Supports
            {
                get; set;
            }
            /// <summary>
            /// Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
            /// with the innermost layer and going outwards.
            /// </summary>
            [Experimental]
            public CSSDomain.CSSLayer[]? Layers
            {
                get; set;
            }
            /// <summary>
            /// @scope CSS at-rule array.
            /// The array enumerates @scope at-rules starting with the innermost one, going outwards.
            /// </summary>
            [Experimental]
            public CSSDomain.CSSScope[]? Scopes
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS coverage information.
        /// </summary>
        public class RuleUsage
        {
            /// <summary>
            /// The css style sheet identifier (absent for user agent stylesheet and user-specified
            /// stylesheet rules) this rule came from.
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// Offset of the start of the rule (including selector) from the beginning of the stylesheet.
            /// </summary>
            public double StartOffset
            {
                get; set;
            }
            /// <summary>
            /// Offset of the end of the rule body from the beginning of the stylesheet.
            /// </summary>
            public double EndOffset
            {
                get; set;
            }
            /// <summary>
            /// Indicates whether the rule was actually used by some element in the page.
            /// </summary>
            public bool Used
            {
                get; set;
            }

        }
        /// <summary>
        /// Text range within a resource. All numbers are zero-based.
        /// </summary>
        public class SourceRange
        {
            /// <summary>
            /// Start line of range.
            /// </summary>
            public int StartLine
            {
                get; set;
            }
            /// <summary>
            /// Start column of range (inclusive).
            /// </summary>
            public int StartColumn
            {
                get; set;
            }
            /// <summary>
            /// End line of range
            /// </summary>
            public int EndLine
            {
                get; set;
            }
            /// <summary>
            /// End column of range (exclusive).
            /// </summary>
            public int EndColumn
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class ShorthandEntry
        {
            /// <summary>
            /// Shorthand name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Shorthand value.
            /// </summary>
            public string Value
            {
                get; set;
            }
            /// <summary>
            /// Whether the property has "!important" annotation (implies `false` if absent).
            /// </summary>
            public bool? Important
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class CSSComputedStyleProperty
        {
            /// <summary>
            /// Computed style property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Computed style property value.
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS style representation.
        /// </summary>
        public class CSSStyle
        {
            /// <summary>
            /// The css style sheet identifier (absent for user agent stylesheet and user-specified
            /// stylesheet rules) this rule came from.
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// CSS properties in the style.
            /// </summary>
            public CSSDomain.CSSProperty[] CssProperties
            {
                get; set;
            }
            /// <summary>
            /// Computed values for all shorthands found in the style.
            /// </summary>
            public CSSDomain.ShorthandEntry[] ShorthandEntries
            {
                get; set;
            }
            /// <summary>
            /// Style declaration text (if available).
            /// </summary>
            public string? CssText
            {
                get; set;
            }
            /// <summary>
            /// Style declaration range in the enclosing stylesheet (if available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS property declaration data.
        /// </summary>
        public class CSSProperty
        {
            /// <summary>
            /// The property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// The property value.
            /// </summary>
            public string Value
            {
                get; set;
            }
            /// <summary>
            /// Whether the property has "!important" annotation (implies `false` if absent).
            /// </summary>
            public bool? Important
            {
                get; set;
            }
            /// <summary>
            /// Whether the property is implicit (implies `false` if absent).
            /// </summary>
            public bool? Implicit
            {
                get; set;
            }
            /// <summary>
            /// The full property text as specified in the style.
            /// </summary>
            public string? Text
            {
                get; set;
            }
            /// <summary>
            /// Whether the property is understood by the browser (implies `true` if absent).
            /// </summary>
            public bool? ParsedOk
            {
                get; set;
            }
            /// <summary>
            /// Whether the property is disabled by the user (present for source-based properties only).
            /// </summary>
            public bool? Disabled
            {
                get; set;
            }
            /// <summary>
            /// The entire property range in the enclosing style declaration (if available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS media rule descriptor.
        /// </summary>
        public class CSSMedia
        {
            /// <summary>
            /// Media query text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
            /// specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
            /// stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
            /// stylesheet's STYLE tag.
            /// </summary>
            /// <value>
            /// mediaRule,importRule,linkedSheet,inlineSheet
            /// </value>
            public string Source
            {
                get; set;
            }
            /// <summary>
            /// URL of the document containing the media query description.
            /// </summary>
            public string? SourceURL
            {
                get; set;
            }
            /// <summary>
            /// The associated rule (@media or @import) header range in the enclosing stylesheet (if
            /// available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the stylesheet containing this object (if exists).
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// Array of media queries.
            /// </summary>
            public CSSDomain.MediaQuery[]? MediaList
            {
                get; set;
            }

        }
        /// <summary>
        /// Media query descriptor.
        /// </summary>
        public class MediaQuery
        {
            /// <summary>
            /// Array of media query expressions.
            /// </summary>
            public CSSDomain.MediaQueryExpression[] Expressions
            {
                get; set;
            }
            /// <summary>
            /// Whether the media query condition is satisfied.
            /// </summary>
            public bool Active
            {
                get; set;
            }

        }
        /// <summary>
        /// Media query expression descriptor.
        /// </summary>
        public class MediaQueryExpression
        {
            /// <summary>
            /// Media query expression value.
            /// </summary>
            public double Value
            {
                get; set;
            }
            /// <summary>
            /// Media query expression units.
            /// </summary>
            public string Unit
            {
                get; set;
            }
            /// <summary>
            /// Media query expression feature.
            /// </summary>
            public string Feature
            {
                get; set;
            }
            /// <summary>
            /// The associated range of the value text in the enclosing stylesheet (if available).
            /// </summary>
            public CSSDomain.SourceRange? ValueRange
            {
                get; set;
            }
            /// <summary>
            /// Computed length of media query expression (if applicable).
            /// </summary>
            public double? ComputedLength
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS container query rule descriptor.
        /// </summary>
        [Experimental]
        public class CSSContainerQuery
        {
            /// <summary>
            /// Container query text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// The associated rule header range in the enclosing stylesheet (if
            /// available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the stylesheet containing this object (if exists).
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// Optional name for the container.
            /// </summary>
            public string? Name
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS Supports at-rule descriptor.
        /// </summary>
        [Experimental]
        public class CSSSupports
        {
            /// <summary>
            /// Supports rule text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// Whether the supports condition is satisfied.
            /// </summary>
            public bool Active
            {
                get; set;
            }
            /// <summary>
            /// The associated rule header range in the enclosing stylesheet (if
            /// available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the stylesheet containing this object (if exists).
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS Scope at-rule descriptor.
        /// </summary>
        [Experimental]
        public class CSSScope
        {
            /// <summary>
            /// Scope rule text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// The associated rule header range in the enclosing stylesheet (if
            /// available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the stylesheet containing this object (if exists).
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS Layer at-rule descriptor.
        /// </summary>
        [Experimental]
        public class CSSLayer
        {
            /// <summary>
            /// Layer name.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// The associated rule header range in the enclosing stylesheet (if
            /// available).
            /// </summary>
            public CSSDomain.SourceRange? Range
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the stylesheet containing this object (if exists).
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS Layer data.
        /// </summary>
        [Experimental]
        public class CSSLayerData
        {
            /// <summary>
            /// Layer name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Direct sub-layers
            /// </summary>
            public CSSDomain.CSSLayerData[]? SubLayers
            {
                get; set;
            }
            /// <summary>
            /// Layer order. The order determines the order of the layer in the cascade order.
            /// A higher number has higher priority in the cascade order.
            /// </summary>
            public double Order
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about amount of glyphs that were rendered with given font.
        /// </summary>
        public class PlatformFontUsage
        {
            /// <summary>
            /// Font's family name reported by platform.
            /// </summary>
            public string FamilyName
            {
                get; set;
            }
            /// <summary>
            /// Indicates if the font was downloaded or resolved locally.
            /// </summary>
            public bool IsCustomFont
            {
                get; set;
            }
            /// <summary>
            /// Amount of glyphs that were rendered with this font.
            /// </summary>
            public double GlyphCount
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about font variation axes for variable fonts
        /// </summary>
        public class FontVariationAxis
        {
            /// <summary>
            /// The font-variation-setting tag (a.k.a. "axis tag").
            /// </summary>
            public string Tag
            {
                get; set;
            }
            /// <summary>
            /// Human-readable variation name in the default language (normally, "en").
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// The minimum value (inclusive) the font supports for this tag.
            /// </summary>
            public double MinValue
            {
                get; set;
            }
            /// <summary>
            /// The maximum value (inclusive) the font supports for this tag.
            /// </summary>
            public double MaxValue
            {
                get; set;
            }
            /// <summary>
            /// The default value.
            /// </summary>
            public double DefaultValue
            {
                get; set;
            }

        }
        /// <summary>
        /// Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
        /// and additional information such as platformFontFamily and fontVariationAxes.
        /// </summary>
        public class FontFace
        {
            /// <summary>
            /// The font-family.
            /// </summary>
            public string FontFamily
            {
                get; set;
            }
            /// <summary>
            /// The font-style.
            /// </summary>
            public string FontStyle
            {
                get; set;
            }
            /// <summary>
            /// The font-variant.
            /// </summary>
            public string FontVariant
            {
                get; set;
            }
            /// <summary>
            /// The font-weight.
            /// </summary>
            public string FontWeight
            {
                get; set;
            }
            /// <summary>
            /// The font-stretch.
            /// </summary>
            public string FontStretch
            {
                get; set;
            }
            /// <summary>
            /// The font-display.
            /// </summary>
            public string FontDisplay
            {
                get; set;
            }
            /// <summary>
            /// The unicode-range.
            /// </summary>
            public string UnicodeRange
            {
                get; set;
            }
            /// <summary>
            /// The src.
            /// </summary>
            public string Src
            {
                get; set;
            }
            /// <summary>
            /// The resolved platform font family
            /// </summary>
            public string PlatformFontFamily
            {
                get; set;
            }
            /// <summary>
            /// Available variation settings (a.k.a. "axes").
            /// </summary>
            public CSSDomain.FontVariationAxis[]? FontVariationAxes
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS keyframes rule representation.
        /// </summary>
        public class CSSKeyframesRule
        {
            /// <summary>
            /// Animation name.
            /// </summary>
            public CSSDomain.Value AnimationName
            {
                get; set;
            }
            /// <summary>
            /// List of keyframes.
            /// </summary>
            public CSSDomain.CSSKeyframeRule[] Keyframes
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS keyframe rule representation.
        /// </summary>
        public class CSSKeyframeRule
        {
            /// <summary>
            /// The css style sheet identifier (absent for user agent stylesheet and user-specified
            /// stylesheet rules) this rule came from.
            /// </summary>
            public string? StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// Parent stylesheet's origin.
            /// </summary>
            public CSSDomain.StyleSheetOrigin Origin
            {
                get; set;
            }
            /// <summary>
            /// Associated key text.
            /// </summary>
            public CSSDomain.Value KeyText
            {
                get; set;
            }
            /// <summary>
            /// Associated style declaration.
            /// </summary>
            public CSSDomain.CSSStyle Style
            {
                get; set;
            }

        }
        /// <summary>
        /// A descriptor of operation to mutate style declaration text.
        /// </summary>
        public class StyleDeclarationEdit
        {
            /// <summary>
            /// The css style sheet identifier.
            /// </summary>
            public string StyleSheetId
            {
                get; set;
            }
            /// <summary>
            /// The range of the style text in the enclosing stylesheet.
            /// </summary>
            public CSSDomain.SourceRange Range
            {
                get; set;
            }
            /// <summary>
            /// New style text.
            /// </summary>
            public string Text
            {
                get; set;
            }

        }

    }
    public class CacheStorageDomain : BaseDomain
    {
        public CacheStorageDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "CacheStorage";

            }

        }
        /// <summary>
        /// Deletes a cache.
        /// </summary>
        public async ValueTask<DeleteCacheResult> DeleteCacheAsync(DeleteCacheParams deleteCacheParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deleteCacheParams, cancellationToken);

        }
        /// <summary>
        /// Deletes a cache entry.
        /// </summary>
        public async ValueTask<DeleteEntryResult> DeleteEntryAsync(DeleteEntryParams deleteEntryParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deleteEntryParams, cancellationToken);

        }
        /// <summary>
        /// Requests cache names.
        /// </summary>
        public async ValueTask<RequestCacheNamesResult> RequestCacheNamesAsync(RequestCacheNamesParams requestCacheNamesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestCacheNamesParams, cancellationToken);

        }
        /// <summary>
        /// Fetches cache entry.
        /// </summary>
        public async ValueTask<RequestCachedResponseResult> RequestCachedResponseAsync(RequestCachedResponseParams requestCachedResponseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestCachedResponseParams, cancellationToken);

        }
        /// <summary>
        /// Requests data from cache.
        /// </summary>
        public async ValueTask<RequestEntriesResult> RequestEntriesAsync(RequestEntriesParams requestEntriesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestEntriesParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class DeleteCacheParams : IMethodParams<DeleteCacheParams, DeleteCacheResult>
        {
            public string GetMethod()
            {
                return "CacheStorage.deleteCache";

            }
            /// <summary>
            /// Id of cache for deletion.
            /// </summary>
            public string CacheId
            {
                get; set;
            }

        }
        public class DeleteCacheResult
        {

        }
        public class DeleteEntryParams : IMethodParams<DeleteEntryParams, DeleteEntryResult>
        {
            public string GetMethod()
            {
                return "CacheStorage.deleteEntry";

            }
            /// <summary>
            /// Id of cache where the entry will be deleted.
            /// </summary>
            public string CacheId
            {
                get; set;
            }
            /// <summary>
            /// URL spec of the request.
            /// </summary>
            public string Request
            {
                get; set;
            }

        }
        public class DeleteEntryResult
        {

        }
        public class RequestCacheNamesParams : IMethodParams<RequestCacheNamesParams, RequestCacheNamesResult>
        {
            public string GetMethod()
            {
                return "CacheStorage.requestCacheNames";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }

        }
        public class RequestCacheNamesResult
        {
            /// <summary>
            /// Caches for the security origin.
            /// </summary>
            public CacheStorageDomain.Cache[] Caches
            {
                get; set;
            }

        }
        public class RequestCachedResponseParams : IMethodParams<RequestCachedResponseParams, RequestCachedResponseResult>
        {
            public string GetMethod()
            {
                return "CacheStorage.requestCachedResponse";

            }
            /// <summary>
            /// Id of cache that contains the entry.
            /// </summary>
            public string CacheId
            {
                get; set;
            }
            /// <summary>
            /// URL spec of the request.
            /// </summary>
            public string RequestURL
            {
                get; set;
            }
            /// <summary>
            /// headers of the request.
            /// </summary>
            public CacheStorageDomain.Header[] RequestHeaders
            {
                get; set;
            }

        }
        public class RequestCachedResponseResult
        {
            /// <summary>
            /// Response read from the cache.
            /// </summary>
            public CacheStorageDomain.CachedResponse Response
            {
                get; set;
            }

        }
        public class RequestEntriesParams : IMethodParams<RequestEntriesParams, RequestEntriesResult>
        {
            public string GetMethod()
            {
                return "CacheStorage.requestEntries";

            }
            /// <summary>
            /// ID of cache to get entries from.
            /// </summary>
            public string CacheId
            {
                get; set;
            }
            /// <summary>
            /// Number of records to skip.
            /// </summary>
            public int? SkipCount
            {
                get; set;
            }
            /// <summary>
            /// Number of records to fetch.
            /// </summary>
            public int? PageSize
            {
                get; set;
            }
            /// <summary>
            /// If present, only return the entries containing this substring in the path
            /// </summary>
            public string? PathFilter
            {
                get; set;
            }

        }
        public class RequestEntriesResult
        {
            /// <summary>
            /// Array of object store data entries.
            /// </summary>
            public CacheStorageDomain.DataEntry[] CacheDataEntries
            {
                get; set;
            }
            /// <summary>
            /// Count of returned entries from this storage. If pathFilter is empty, it
            /// is the count of all entries from this storage.
            /// </summary>
            public double ReturnCount
            {
                get; set;
            }

        }
        /// <summary>
        /// type of HTTP response cached
        /// </summary>
        public enum CachedResponseType
        {
            [EnumValue("basic")]
            Basic = 1,
            [EnumValue("cors")]
            Cors = 2,
            [EnumValue("default")]
            Default = 3,
            [EnumValue("error")]
            Error = 4,
            [EnumValue("opaqueResponse")]
            OpaqueResponse = 5,
            [EnumValue("opaqueRedirect")]
            OpaqueRedirect = 6,

        }
        /// <summary>
        /// Data entry.
        /// </summary>
        public class DataEntry
        {
            /// <summary>
            /// Request URL.
            /// </summary>
            public string RequestURL
            {
                get; set;
            }
            /// <summary>
            /// Request method.
            /// </summary>
            public string RequestMethod
            {
                get; set;
            }
            /// <summary>
            /// Request headers
            /// </summary>
            public CacheStorageDomain.Header[] RequestHeaders
            {
                get; set;
            }
            /// <summary>
            /// Number of seconds since epoch.
            /// </summary>
            public double ResponseTime
            {
                get; set;
            }
            /// <summary>
            /// HTTP response status code.
            /// </summary>
            public int ResponseStatus
            {
                get; set;
            }
            /// <summary>
            /// HTTP response status text.
            /// </summary>
            public string ResponseStatusText
            {
                get; set;
            }
            /// <summary>
            /// HTTP response type
            /// </summary>
            public CacheStorageDomain.CachedResponseType ResponseType
            {
                get; set;
            }
            /// <summary>
            /// Response headers
            /// </summary>
            public CacheStorageDomain.Header[] ResponseHeaders
            {
                get; set;
            }

        }
        /// <summary>
        /// Cache identifier.
        /// </summary>
        public class Cache
        {
            /// <summary>
            /// An opaque unique id of the cache.
            /// </summary>
            public string CacheId
            {
                get; set;
            }
            /// <summary>
            /// Security origin of the cache.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// The name of the cache.
            /// </summary>
            public string CacheName
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class Header
        {
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Cached response
        /// </summary>
        public class CachedResponse
        {
            /// <summary>
            /// Entry content, base64-encoded. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Body
            {
                get; set;
            }

        }

    }
    public class CastDomain : BaseDomain
    {
        public CastDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Cast";

            }

        }
        /// <summary>
        /// This is fired whenever the list of available sinks changes. A sink is a
        /// device or a software surface that you can cast to.
        /// </summary>
        public event EventHandler<SinksUpdatedParams>? SinksUpdated;
        /// <summary>
        /// This is fired whenever the outstanding issue/error message changes.
        /// |issueMessage| is empty if there is no issue.
        /// </summary>
        public event EventHandler<IssueUpdatedParams>? IssueUpdated;
        /// <summary>
        /// Starts observing for sinks that can be used for tab mirroring, and if set,
        /// sinks compatible with |presentationUrl| as well. When sinks are found, a
        /// |sinksUpdated| event is fired.
        /// Also starts observing for issue messages. When an issue is added or removed,
        /// an |issueUpdated| event is fired.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Stops observing for sinks and issues.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Sets a sink to be used when the web page requests the browser to choose a
        /// sink via Presentation API, Remote Playback API, or Cast SDK.
        /// </summary>
        public async ValueTask<SetSinkToUseResult> SetSinkToUseAsync(SetSinkToUseParams setSinkToUseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setSinkToUseParams, cancellationToken);

        }
        /// <summary>
        /// Starts mirroring the desktop to the sink.
        /// </summary>
        public async ValueTask<StartDesktopMirroringResult> StartDesktopMirroringAsync(StartDesktopMirroringParams startDesktopMirroringParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startDesktopMirroringParams, cancellationToken);

        }
        /// <summary>
        /// Starts mirroring the tab to the sink.
        /// </summary>
        public async ValueTask<StartTabMirroringResult> StartTabMirroringAsync(StartTabMirroringParams startTabMirroringParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startTabMirroringParams, cancellationToken);

        }
        /// <summary>
        /// Stops the active Cast session on the sink.
        /// </summary>
        public async ValueTask<StopCastingResult> StopCastingAsync(StopCastingParams stopCastingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopCastingParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "sinksUpdated": RaiseEvent(SinksUpdated, messageBytes);
                    break;
                case "issueUpdated": RaiseEvent(IssueUpdated, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class SinksUpdatedParams
        {
            /// <summary>
            /// </summary>
            public CastDomain.Sink[] Sinks
            {
                get; set;
            }

        }
        public class IssueUpdatedParams
        {
            /// <summary>
            /// </summary>
            public string IssueMessage
            {
                get; set;
            }

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Cast.enable";

            }
            /// <summary>
            /// </summary>
            public string? PresentationUrl
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Cast.disable";

            }

        }
        public class DisableResult
        {

        }
        public class SetSinkToUseParams : IMethodParams<SetSinkToUseParams, SetSinkToUseResult>
        {
            public string GetMethod()
            {
                return "Cast.setSinkToUse";

            }
            /// <summary>
            /// </summary>
            public string SinkName
            {
                get; set;
            }

        }
        public class SetSinkToUseResult
        {

        }
        public class StartDesktopMirroringParams : IMethodParams<StartDesktopMirroringParams, StartDesktopMirroringResult>
        {
            public string GetMethod()
            {
                return "Cast.startDesktopMirroring";

            }
            /// <summary>
            /// </summary>
            public string SinkName
            {
                get; set;
            }

        }
        public class StartDesktopMirroringResult
        {

        }
        public class StartTabMirroringParams : IMethodParams<StartTabMirroringParams, StartTabMirroringResult>
        {
            public string GetMethod()
            {
                return "Cast.startTabMirroring";

            }
            /// <summary>
            /// </summary>
            public string SinkName
            {
                get; set;
            }

        }
        public class StartTabMirroringResult
        {

        }
        public class StopCastingParams : IMethodParams<StopCastingParams, StopCastingResult>
        {
            public string GetMethod()
            {
                return "Cast.stopCasting";

            }
            /// <summary>
            /// </summary>
            public string SinkName
            {
                get; set;
            }

        }
        public class StopCastingResult
        {

        }
        /// <summary>
        /// </summary>
        public class Sink
        {
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// Text describing the current session. Present only if there is an active
            /// session on the sink.
            /// </summary>
            public string? Session
            {
                get; set;
            }

        }

    }
    public class DOMDomain : BaseDomain
    {
        public DOMDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "DOM";

            }

        }
        /// <summary>
        /// Fired when `Element`'s attribute is modified.
        /// </summary>
        public event EventHandler<AttributeModifiedParams>? AttributeModified;
        /// <summary>
        /// Fired when `Element`'s attribute is removed.
        /// </summary>
        public event EventHandler<AttributeRemovedParams>? AttributeRemoved;
        /// <summary>
        /// Mirrors `DOMCharacterDataModified` event.
        /// </summary>
        public event EventHandler<CharacterDataModifiedParams>? CharacterDataModified;
        /// <summary>
        /// Fired when `Container`'s child node count has changed.
        /// </summary>
        public event EventHandler<ChildNodeCountUpdatedParams>? ChildNodeCountUpdated;
        /// <summary>
        /// Mirrors `DOMNodeInserted` event.
        /// </summary>
        public event EventHandler<ChildNodeInsertedParams>? ChildNodeInserted;
        /// <summary>
        /// Mirrors `DOMNodeRemoved` event.
        /// </summary>
        public event EventHandler<ChildNodeRemovedParams>? ChildNodeRemoved;
        /// <summary>
        /// Called when distribution is changed.
        /// </summary>
        [Experimental]
        public event EventHandler<DistributedNodesUpdatedParams>? DistributedNodesUpdated;
        /// <summary>
        /// Fired when `Document` has been totally updated. Node ids are no longer valid.
        /// </summary>
        public event EventHandler<DocumentUpdatedParams>? DocumentUpdated;
        /// <summary>
        /// Fired when `Element`'s inline style is modified via a CSS property modification.
        /// </summary>
        [Experimental]
        public event EventHandler<InlineStyleInvalidatedParams>? InlineStyleInvalidated;
        /// <summary>
        /// Called when a pseudo element is added to an element.
        /// </summary>
        [Experimental]
        public event EventHandler<PseudoElementAddedParams>? PseudoElementAdded;
        /// <summary>
        /// Called when top layer elements are changed.
        /// </summary>
        [Experimental]
        public event EventHandler<TopLayerElementsUpdatedParams>? TopLayerElementsUpdated;
        /// <summary>
        /// Called when a pseudo element is removed from an element.
        /// </summary>
        [Experimental]
        public event EventHandler<PseudoElementRemovedParams>? PseudoElementRemoved;
        /// <summary>
        /// Fired when backend wants to provide client with the missing DOM structure. This happens upon
        /// most of the calls requesting node ids.
        /// </summary>
        public event EventHandler<SetChildNodesParams>? SetChildNodes;
        /// <summary>
        /// Called when shadow root is popped from the element.
        /// </summary>
        [Experimental]
        public event EventHandler<ShadowRootPoppedParams>? ShadowRootPopped;
        /// <summary>
        /// Called when shadow root is pushed into the element.
        /// </summary>
        [Experimental]
        public event EventHandler<ShadowRootPushedParams>? ShadowRootPushed;
        /// <summary>
        /// Collects class names for the node with given id and all of it's child nodes.
        /// </summary>
        [Experimental]
        public async ValueTask<CollectClassNamesFromSubtreeResult> CollectClassNamesFromSubtreeAsync(CollectClassNamesFromSubtreeParams collectClassNamesFromSubtreeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(collectClassNamesFromSubtreeParams, cancellationToken);

        }
        /// <summary>
        /// Creates a deep copy of the specified node and places it into the target container before the
        /// given anchor.
        /// </summary>
        [Experimental]
        public async ValueTask<CopyToResult> CopyToAsync(CopyToParams copyToParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(copyToParams, cancellationToken);

        }
        /// <summary>
        /// Describes node given its id, does not require domain to be enabled. Does not start tracking any
        /// objects, can be used for automation.
        /// </summary>
        public async ValueTask<DescribeNodeResult> DescribeNodeAsync(DescribeNodeParams describeNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(describeNodeParams, cancellationToken);

        }
        /// <summary>
        /// Scrolls the specified rect of the given node into view if not already visible.
        /// Note: exactly one between nodeId, backendNodeId and objectId should be passed
        /// to identify the node.
        /// </summary>
        [Experimental]
        public async ValueTask<ScrollIntoViewIfNeededResult> ScrollIntoViewIfNeededAsync(ScrollIntoViewIfNeededParams scrollIntoViewIfNeededParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(scrollIntoViewIfNeededParams, cancellationToken);

        }
        /// <summary>
        /// Disables DOM agent for the given page.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Discards search results from the session with the given id. `getSearchResults` should no longer
        /// be called for that search.
        /// </summary>
        [Experimental]
        public async ValueTask<DiscardSearchResultsResult> DiscardSearchResultsAsync(DiscardSearchResultsParams discardSearchResultsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(discardSearchResultsParams, cancellationToken);

        }
        /// <summary>
        /// Enables DOM agent for the given page.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Focuses the given element.
        /// </summary>
        public async ValueTask<FocusResult> FocusAsync(FocusParams focusParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(focusParams, cancellationToken);

        }
        /// <summary>
        /// Returns attributes for the specified node.
        /// </summary>
        public async ValueTask<GetAttributesResult> GetAttributesAsync(GetAttributesParams getAttributesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getAttributesParams, cancellationToken);

        }
        /// <summary>
        /// Returns boxes for the given node.
        /// </summary>
        public async ValueTask<GetBoxModelResult> GetBoxModelAsync(GetBoxModelParams getBoxModelParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getBoxModelParams, cancellationToken);

        }
        /// <summary>
        /// Returns quads that describe node position on the page. This method
        /// might return multiple quads for inline nodes.
        /// </summary>
        [Experimental]
        public async ValueTask<GetContentQuadsResult> GetContentQuadsAsync(GetContentQuadsParams getContentQuadsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getContentQuadsParams, cancellationToken);

        }
        /// <summary>
        /// Returns the root DOM node (and optionally the subtree) to the caller.
        /// </summary>
        public async ValueTask<GetDocumentResult> GetDocumentAsync(GetDocumentParams getDocumentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getDocumentParams, cancellationToken);

        }
        /// <summary>
        /// Returns the root DOM node (and optionally the subtree) to the caller.
        /// Deprecated, as it is not designed to work well with the rest of the DOM agent.
        /// Use DOMSnapshot.captureSnapshot instead.
        /// </summary>
        [Obsolete]
        public async ValueTask<GetFlattenedDocumentResult> GetFlattenedDocumentAsync(GetFlattenedDocumentParams getFlattenedDocumentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getFlattenedDocumentParams, cancellationToken);

        }
        /// <summary>
        /// Finds nodes with a given computed style in a subtree.
        /// </summary>
        [Experimental]
        public async ValueTask<GetNodesForSubtreeByStyleResult> GetNodesForSubtreeByStyleAsync(GetNodesForSubtreeByStyleParams getNodesForSubtreeByStyleParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getNodesForSubtreeByStyleParams, cancellationToken);

        }
        /// <summary>
        /// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
        /// either returned or not.
        /// </summary>
        public async ValueTask<GetNodeForLocationResult> GetNodeForLocationAsync(GetNodeForLocationParams getNodeForLocationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getNodeForLocationParams, cancellationToken);

        }
        /// <summary>
        /// Returns node's HTML markup.
        /// </summary>
        public async ValueTask<GetOuterHTMLResult> GetOuterHTMLAsync(GetOuterHTMLParams getOuterHTMLParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getOuterHTMLParams, cancellationToken);

        }
        /// <summary>
        /// Returns the id of the nearest ancestor that is a relayout boundary.
        /// </summary>
        [Experimental]
        public async ValueTask<GetRelayoutBoundaryResult> GetRelayoutBoundaryAsync(GetRelayoutBoundaryParams getRelayoutBoundaryParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getRelayoutBoundaryParams, cancellationToken);

        }
        /// <summary>
        /// Returns search results from given `fromIndex` to given `toIndex` from the search with the given
        /// identifier.
        /// </summary>
        [Experimental]
        public async ValueTask<GetSearchResultsResult> GetSearchResultsAsync(GetSearchResultsParams getSearchResultsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getSearchResultsParams, cancellationToken);

        }
        /// <summary>
        /// Hides any highlight.
        /// </summary>
        public async ValueTask<HideHighlightResult> HideHighlightAsync(HideHighlightParams hideHighlightParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(hideHighlightParams, cancellationToken);

        }
        /// <summary>
        /// Highlights DOM node.
        /// </summary>
        public async ValueTask<HighlightNodeResult> HighlightNodeAsync(HighlightNodeParams highlightNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightNodeParams, cancellationToken);

        }
        /// <summary>
        /// Highlights given rectangle.
        /// </summary>
        public async ValueTask<HighlightRectResult> HighlightRectAsync(HighlightRectParams highlightRectParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightRectParams, cancellationToken);

        }
        /// <summary>
        /// Marks last undoable state.
        /// </summary>
        [Experimental]
        public async ValueTask<MarkUndoableStateResult> MarkUndoableStateAsync(MarkUndoableStateParams markUndoableStateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(markUndoableStateParams, cancellationToken);

        }
        /// <summary>
        /// Moves node into the new container, places it before the given anchor.
        /// </summary>
        public async ValueTask<MoveToResult> MoveToAsync(MoveToParams moveToParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(moveToParams, cancellationToken);

        }
        /// <summary>
        /// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
        /// `cancelSearch` to end this search session.
        /// </summary>
        [Experimental]
        public async ValueTask<PerformSearchResult> PerformSearchAsync(PerformSearchParams performSearchParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(performSearchParams, cancellationToken);

        }
        /// <summary>
        /// Requests that the node is sent to the caller given its path. // FIXME, use XPath
        /// </summary>
        [Experimental]
        public async ValueTask<PushNodeByPathToFrontendResult> PushNodeByPathToFrontendAsync(PushNodeByPathToFrontendParams pushNodeByPathToFrontendParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(pushNodeByPathToFrontendParams, cancellationToken);

        }
        /// <summary>
        /// Requests that a batch of nodes is sent to the caller given their backend node ids.
        /// </summary>
        [Experimental]
        public async ValueTask<PushNodesByBackendIdsToFrontendResult> PushNodesByBackendIdsToFrontendAsync(PushNodesByBackendIdsToFrontendParams pushNodesByBackendIdsToFrontendParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(pushNodesByBackendIdsToFrontendParams, cancellationToken);

        }
        /// <summary>
        /// Executes `querySelector` on a given node.
        /// </summary>
        public async ValueTask<QuerySelectorResult> QuerySelectorAsync(QuerySelectorParams querySelectorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(querySelectorParams, cancellationToken);

        }
        /// <summary>
        /// Executes `querySelectorAll` on a given node.
        /// </summary>
        public async ValueTask<QuerySelectorAllResult> QuerySelectorAllAsync(QuerySelectorAllParams querySelectorAllParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(querySelectorAllParams, cancellationToken);

        }
        /// <summary>
        /// Returns NodeIds of current top layer elements.
        /// Top layer is rendered closest to the user within a viewport, therefore its elements always
        /// appear on top of all other content.
        /// </summary>
        [Experimental]
        public async ValueTask<GetTopLayerElementsResult> GetTopLayerElementsAsync(GetTopLayerElementsParams getTopLayerElementsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getTopLayerElementsParams, cancellationToken);

        }
        /// <summary>
        /// Re-does the last undone action.
        /// </summary>
        [Experimental]
        public async ValueTask<RedoResult> RedoAsync(RedoParams redoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(redoParams, cancellationToken);

        }
        /// <summary>
        /// Removes attribute with given name from an element with given id.
        /// </summary>
        public async ValueTask<RemoveAttributeResult> RemoveAttributeAsync(RemoveAttributeParams removeAttributeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeAttributeParams, cancellationToken);

        }
        /// <summary>
        /// Removes node with given id.
        /// </summary>
        public async ValueTask<RemoveNodeResult> RemoveNodeAsync(RemoveNodeParams removeNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeNodeParams, cancellationToken);

        }
        /// <summary>
        /// Requests that children of the node with given id are returned to the caller in form of
        /// `setChildNodes` events where not only immediate children are retrieved, but all children down to
        /// the specified depth.
        /// </summary>
        public async ValueTask<RequestChildNodesResult> RequestChildNodesAsync(RequestChildNodesParams requestChildNodesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestChildNodesParams, cancellationToken);

        }
        /// <summary>
        /// Requests that the node is sent to the caller given the JavaScript node object reference. All
        /// nodes that form the path from the node to the root are also sent to the client as a series of
        /// `setChildNodes` notifications.
        /// </summary>
        public async ValueTask<RequestNodeResult> RequestNodeAsync(RequestNodeParams requestNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestNodeParams, cancellationToken);

        }
        /// <summary>
        /// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
        /// </summary>
        public async ValueTask<ResolveNodeResult> ResolveNodeAsync(ResolveNodeParams resolveNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resolveNodeParams, cancellationToken);

        }
        /// <summary>
        /// Sets attribute for an element with given id.
        /// </summary>
        public async ValueTask<SetAttributeValueResult> SetAttributeValueAsync(SetAttributeValueParams setAttributeValueParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAttributeValueParams, cancellationToken);

        }
        /// <summary>
        /// Sets attributes on element with given id. This method is useful when user edits some existing
        /// attribute value and types in several attribute name/value pairs.
        /// </summary>
        public async ValueTask<SetAttributesAsTextResult> SetAttributesAsTextAsync(SetAttributesAsTextParams setAttributesAsTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAttributesAsTextParams, cancellationToken);

        }
        /// <summary>
        /// Sets files for the given file input element.
        /// </summary>
        public async ValueTask<SetFileInputFilesResult> SetFileInputFilesAsync(SetFileInputFilesParams setFileInputFilesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setFileInputFilesParams, cancellationToken);

        }
        /// <summary>
        /// Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
        /// </summary>
        [Experimental]
        public async ValueTask<SetNodeStackTracesEnabledResult> SetNodeStackTracesEnabledAsync(SetNodeStackTracesEnabledParams setNodeStackTracesEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setNodeStackTracesEnabledParams, cancellationToken);

        }
        /// <summary>
        /// Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
        /// </summary>
        [Experimental]
        public async ValueTask<GetNodeStackTracesResult> GetNodeStackTracesAsync(GetNodeStackTracesParams getNodeStackTracesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getNodeStackTracesParams, cancellationToken);

        }
        /// <summary>
        /// Returns file information for the given
        /// File wrapper.
        /// </summary>
        [Experimental]
        public async ValueTask<GetFileInfoResult> GetFileInfoAsync(GetFileInfoParams getFileInfoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getFileInfoParams, cancellationToken);

        }
        /// <summary>
        /// Enables console to refer to the node with given id via $x (see Command Line API for more details
        /// $x functions).
        /// </summary>
        [Experimental]
        public async ValueTask<SetInspectedNodeResult> SetInspectedNodeAsync(SetInspectedNodeParams setInspectedNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInspectedNodeParams, cancellationToken);

        }
        /// <summary>
        /// Sets node name for a node with given id.
        /// </summary>
        public async ValueTask<SetNodeNameResult> SetNodeNameAsync(SetNodeNameParams setNodeNameParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setNodeNameParams, cancellationToken);

        }
        /// <summary>
        /// Sets node value for a node with given id.
        /// </summary>
        public async ValueTask<SetNodeValueResult> SetNodeValueAsync(SetNodeValueParams setNodeValueParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setNodeValueParams, cancellationToken);

        }
        /// <summary>
        /// Sets node HTML markup, returns new node id.
        /// </summary>
        public async ValueTask<SetOuterHTMLResult> SetOuterHTMLAsync(SetOuterHTMLParams setOuterHTMLParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setOuterHTMLParams, cancellationToken);

        }
        /// <summary>
        /// Undoes the last performed action.
        /// </summary>
        [Experimental]
        public async ValueTask<UndoResult> UndoAsync(UndoParams undoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(undoParams, cancellationToken);

        }
        /// <summary>
        /// Returns iframe node that owns iframe with the given domain.
        /// </summary>
        [Experimental]
        public async ValueTask<GetFrameOwnerResult> GetFrameOwnerAsync(GetFrameOwnerParams getFrameOwnerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getFrameOwnerParams, cancellationToken);

        }
        /// <summary>
        /// Returns the container of the given node based on container query conditions.
        /// If containerName is given, it will find the nearest container with a matching name;
        /// otherwise it will find the nearest container regardless of its container name.
        /// </summary>
        [Experimental]
        public async ValueTask<GetContainerForNodeResult> GetContainerForNodeAsync(GetContainerForNodeParams getContainerForNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getContainerForNodeParams, cancellationToken);

        }
        /// <summary>
        /// Returns the descendants of a container query container that have
        /// container queries against this container.
        /// </summary>
        [Experimental]
        public async ValueTask<GetQueryingDescendantsForContainerResult> GetQueryingDescendantsForContainerAsync(GetQueryingDescendantsForContainerParams getQueryingDescendantsForContainerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getQueryingDescendantsForContainerParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "attributeModified": RaiseEvent(AttributeModified, messageBytes);
                    break;
                case "attributeRemoved": RaiseEvent(AttributeRemoved, messageBytes);
                    break;
                case "characterDataModified": RaiseEvent(CharacterDataModified, messageBytes);
                    break;
                case "childNodeCountUpdated": RaiseEvent(ChildNodeCountUpdated, messageBytes);
                    break;
                case "childNodeInserted": RaiseEvent(ChildNodeInserted, messageBytes);
                    break;
                case "childNodeRemoved": RaiseEvent(ChildNodeRemoved, messageBytes);
                    break;
                case "distributedNodesUpdated": RaiseEvent(DistributedNodesUpdated, messageBytes);
                    break;
                case "documentUpdated": RaiseEvent(DocumentUpdated, messageBytes);
                    break;
                case "inlineStyleInvalidated": RaiseEvent(InlineStyleInvalidated, messageBytes);
                    break;
                case "pseudoElementAdded": RaiseEvent(PseudoElementAdded, messageBytes);
                    break;
                case "topLayerElementsUpdated": RaiseEvent(TopLayerElementsUpdated, messageBytes);
                    break;
                case "pseudoElementRemoved": RaiseEvent(PseudoElementRemoved, messageBytes);
                    break;
                case "setChildNodes": RaiseEvent(SetChildNodes, messageBytes);
                    break;
                case "shadowRootPopped": RaiseEvent(ShadowRootPopped, messageBytes);
                    break;
                case "shadowRootPushed": RaiseEvent(ShadowRootPushed, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class AttributeModifiedParams
        {
            /// <summary>
            /// Id of the node that has changed.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Attribute name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Attribute value.
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        public class AttributeRemovedParams
        {
            /// <summary>
            /// Id of the node that has changed.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// A ttribute name.
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        public class CharacterDataModifiedParams
        {
            /// <summary>
            /// Id of the node that has changed.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// New text value.
            /// </summary>
            public string CharacterData
            {
                get; set;
            }

        }
        public class ChildNodeCountUpdatedParams
        {
            /// <summary>
            /// Id of the node that has changed.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// New node count.
            /// </summary>
            public int ChildNodeCount
            {
                get; set;
            }

        }
        public class ChildNodeInsertedParams
        {
            /// <summary>
            /// Id of the node that has changed.
            /// </summary>
            public int ParentNodeId
            {
                get; set;
            }
            /// <summary>
            /// If of the previous siblint.
            /// </summary>
            public int PreviousNodeId
            {
                get; set;
            }
            /// <summary>
            /// Inserted node data.
            /// </summary>
            public DOMDomain.Node Node
            {
                get; set;
            }

        }
        public class ChildNodeRemovedParams
        {
            /// <summary>
            /// Parent id.
            /// </summary>
            public int ParentNodeId
            {
                get; set;
            }
            /// <summary>
            /// Id of the node that has been removed.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class DistributedNodesUpdatedParams
        {
            /// <summary>
            /// Insertion point where distributed nodes were updated.
            /// </summary>
            public int InsertionPointId
            {
                get; set;
            }
            /// <summary>
            /// Distributed nodes for given insertion point.
            /// </summary>
            public DOMDomain.BackendNode[] DistributedNodes
            {
                get; set;
            }

        }
        public class DocumentUpdatedParams
        {

        }
        public class InlineStyleInvalidatedParams
        {
            /// <summary>
            /// Ids of the nodes for which the inline styles have been invalidated.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class PseudoElementAddedParams
        {
            /// <summary>
            /// Pseudo element's parent element id.
            /// </summary>
            public int ParentId
            {
                get; set;
            }
            /// <summary>
            /// The added pseudo element.
            /// </summary>
            public DOMDomain.Node PseudoElement
            {
                get; set;
            }

        }
        public class TopLayerElementsUpdatedParams
        {

        }
        public class PseudoElementRemovedParams
        {
            /// <summary>
            /// Pseudo element's parent element id.
            /// </summary>
            public int ParentId
            {
                get; set;
            }
            /// <summary>
            /// The removed pseudo element id.
            /// </summary>
            public int PseudoElementId
            {
                get; set;
            }

        }
        public class SetChildNodesParams
        {
            /// <summary>
            /// Parent node id to populate with children.
            /// </summary>
            public int ParentId
            {
                get; set;
            }
            /// <summary>
            /// Child nodes array.
            /// </summary>
            public DOMDomain.Node[] Nodes
            {
                get; set;
            }

        }
        public class ShadowRootPoppedParams
        {
            /// <summary>
            /// Host element id.
            /// </summary>
            public int HostId
            {
                get; set;
            }
            /// <summary>
            /// Shadow root id.
            /// </summary>
            public int RootId
            {
                get; set;
            }

        }
        public class ShadowRootPushedParams
        {
            /// <summary>
            /// Host element id.
            /// </summary>
            public int HostId
            {
                get; set;
            }
            /// <summary>
            /// Shadow root.
            /// </summary>
            public DOMDomain.Node Root
            {
                get; set;
            }

        }
        public class CollectClassNamesFromSubtreeParams : IMethodParams<CollectClassNamesFromSubtreeParams, CollectClassNamesFromSubtreeResult>
        {
            public string GetMethod()
            {
                return "DOM.collectClassNamesFromSubtree";

            }
            /// <summary>
            /// Id of the node to collect class names.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class CollectClassNamesFromSubtreeResult
        {
            /// <summary>
            /// Class name list.
            /// </summary>
            public string[] ClassNames
            {
                get; set;
            }

        }
        public class CopyToParams : IMethodParams<CopyToParams, CopyToResult>
        {
            public string GetMethod()
            {
                return "DOM.copyTo";

            }
            /// <summary>
            /// Id of the node to copy.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Id of the element to drop the copy into.
            /// </summary>
            public int TargetNodeId
            {
                get; set;
            }
            /// <summary>
            /// Drop the copy before this node (if absent, the copy becomes the last child of
            /// `targetNodeId`).
            /// </summary>
            public int? InsertBeforeNodeId
            {
                get; set;
            }

        }
        public class CopyToResult
        {
            /// <summary>
            /// Id of the node clone.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class DescribeNodeParams : IMethodParams<DescribeNodeParams, DescribeNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.describeNode";

            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
            /// entire subtree or provide an integer larger than 0.
            /// </summary>
            public int? Depth
            {
                get; set;
            }
            /// <summary>
            /// Whether or not iframes and shadow roots should be traversed when returning the subtree
            /// (default is false).
            /// </summary>
            public bool? Pierce
            {
                get; set;
            }

        }
        public class DescribeNodeResult
        {
            /// <summary>
            /// Node description.
            /// </summary>
            public DOMDomain.Node Node
            {
                get; set;
            }

        }
        public class ScrollIntoViewIfNeededParams : IMethodParams<ScrollIntoViewIfNeededParams, ScrollIntoViewIfNeededResult>
        {
            public string GetMethod()
            {
                return "DOM.scrollIntoViewIfNeeded";

            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
            /// When omitted, center of the node will be used, similar to Element.scrollIntoView.
            /// </summary>
            public DOMDomain.Rect? Rect
            {
                get; set;
            }

        }
        public class ScrollIntoViewIfNeededResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "DOM.disable";

            }

        }
        public class DisableResult
        {

        }
        public class DiscardSearchResultsParams : IMethodParams<DiscardSearchResultsParams, DiscardSearchResultsResult>
        {
            public string GetMethod()
            {
                return "DOM.discardSearchResults";

            }
            /// <summary>
            /// Unique search session identifier.
            /// </summary>
            public string SearchId
            {
                get; set;
            }

        }
        public class DiscardSearchResultsResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "DOM.enable";

            }
            /// <summary>
            /// Whether to include whitespaces in the children array of returned Nodes.
            /// </summary>
            /// <value>
            /// none,all
            /// </value>
            [Experimental]
            public string? IncludeWhitespace
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        public class FocusParams : IMethodParams<FocusParams, FocusResult>
        {
            public string GetMethod()
            {
                return "DOM.focus";

            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class FocusResult
        {

        }
        public class GetAttributesParams : IMethodParams<GetAttributesParams, GetAttributesResult>
        {
            public string GetMethod()
            {
                return "DOM.getAttributes";

            }
            /// <summary>
            /// Id of the node to retrieve attibutes for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetAttributesResult
        {
            /// <summary>
            /// An interleaved array of node attribute names and values.
            /// </summary>
            public string[] Attributes
            {
                get; set;
            }

        }
        public class GetBoxModelParams : IMethodParams<GetBoxModelParams, GetBoxModelResult>
        {
            public string GetMethod()
            {
                return "DOM.getBoxModel";

            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class GetBoxModelResult
        {
            /// <summary>
            /// Box model for the node.
            /// </summary>
            public DOMDomain.BoxModel Model
            {
                get; set;
            }

        }
        public class GetContentQuadsParams : IMethodParams<GetContentQuadsParams, GetContentQuadsResult>
        {
            public string GetMethod()
            {
                return "DOM.getContentQuads";

            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class GetContentQuadsResult
        {
            /// <summary>
            /// Quads that describe node layout relative to viewport.
            /// </summary>
            public double[][] Quads
            {
                get; set;
            }

        }
        public class GetDocumentParams : IMethodParams<GetDocumentParams, GetDocumentResult>
        {
            public string GetMethod()
            {
                return "DOM.getDocument";

            }
            /// <summary>
            /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
            /// entire subtree or provide an integer larger than 0.
            /// </summary>
            public int? Depth
            {
                get; set;
            }
            /// <summary>
            /// Whether or not iframes and shadow roots should be traversed when returning the subtree
            /// (default is false).
            /// </summary>
            public bool? Pierce
            {
                get; set;
            }

        }
        public class GetDocumentResult
        {
            /// <summary>
            /// Resulting node.
            /// </summary>
            public DOMDomain.Node Root
            {
                get; set;
            }

        }
        public class GetFlattenedDocumentParams : IMethodParams<GetFlattenedDocumentParams, GetFlattenedDocumentResult>
        {
            public string GetMethod()
            {
                return "DOM.getFlattenedDocument";

            }
            /// <summary>
            /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
            /// entire subtree or provide an integer larger than 0.
            /// </summary>
            public int? Depth
            {
                get; set;
            }
            /// <summary>
            /// Whether or not iframes and shadow roots should be traversed when returning the subtree
            /// (default is false).
            /// </summary>
            public bool? Pierce
            {
                get; set;
            }

        }
        public class GetFlattenedDocumentResult
        {
            /// <summary>
            /// Resulting node.
            /// </summary>
            public DOMDomain.Node[] Nodes
            {
                get; set;
            }

        }
        public class GetNodesForSubtreeByStyleParams : IMethodParams<GetNodesForSubtreeByStyleParams, GetNodesForSubtreeByStyleResult>
        {
            public string GetMethod()
            {
                return "DOM.getNodesForSubtreeByStyle";

            }
            /// <summary>
            /// Node ID pointing to the root of a subtree.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// The style to filter nodes by (includes nodes if any of properties matches).
            /// </summary>
            public DOMDomain.CSSComputedStyleProperty[] ComputedStyles
            {
                get; set;
            }
            /// <summary>
            /// Whether or not iframes and shadow roots in the same target should be traversed when returning the
            /// results (default is false).
            /// </summary>
            public bool? Pierce
            {
                get; set;
            }

        }
        public class GetNodesForSubtreeByStyleResult
        {
            /// <summary>
            /// Resulting nodes.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class GetNodeForLocationParams : IMethodParams<GetNodeForLocationParams, GetNodeForLocationResult>
        {
            public string GetMethod()
            {
                return "DOM.getNodeForLocation";

            }
            /// <summary>
            /// X coordinate.
            /// </summary>
            public int X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate.
            /// </summary>
            public int Y
            {
                get; set;
            }
            /// <summary>
            /// False to skip to the nearest non-UA shadow root ancestor (default: false).
            /// </summary>
            public bool? IncludeUserAgentShadowDOM
            {
                get; set;
            }
            /// <summary>
            /// Whether to ignore pointer-events: none on elements and hit test them.
            /// </summary>
            public bool? IgnorePointerEventsNone
            {
                get; set;
            }

        }
        public class GetNodeForLocationResult
        {
            /// <summary>
            /// Resulting node.
            /// </summary>
            public int BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// Frame this node belongs to.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Id of the node at given coordinates, only when enabled and requested document.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }

        }
        public class GetOuterHTMLParams : IMethodParams<GetOuterHTMLParams, GetOuterHTMLResult>
        {
            public string GetMethod()
            {
                return "DOM.getOuterHTML";

            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class GetOuterHTMLResult
        {
            /// <summary>
            /// Outer HTML markup.
            /// </summary>
            public string OuterHTML
            {
                get; set;
            }

        }
        public class GetRelayoutBoundaryParams : IMethodParams<GetRelayoutBoundaryParams, GetRelayoutBoundaryResult>
        {
            public string GetMethod()
            {
                return "DOM.getRelayoutBoundary";

            }
            /// <summary>
            /// Id of the node.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetRelayoutBoundaryResult
        {
            /// <summary>
            /// Relayout boundary node id for the given node.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetSearchResultsParams : IMethodParams<GetSearchResultsParams, GetSearchResultsResult>
        {
            public string GetMethod()
            {
                return "DOM.getSearchResults";

            }
            /// <summary>
            /// Unique search session identifier.
            /// </summary>
            public string SearchId
            {
                get; set;
            }
            /// <summary>
            /// Start index of the search result to be returned.
            /// </summary>
            public int FromIndex
            {
                get; set;
            }
            /// <summary>
            /// End index of the search result to be returned.
            /// </summary>
            public int ToIndex
            {
                get; set;
            }

        }
        public class GetSearchResultsResult
        {
            /// <summary>
            /// Ids of the search result nodes.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class HideHighlightParams : IMethodParams<HideHighlightParams, HideHighlightResult>
        {
            public string GetMethod()
            {
                return "DOM.hideHighlight";

            }

        }
        public class HideHighlightResult
        {

        }
        public class HighlightNodeParams : IMethodParams<HighlightNodeParams, HighlightNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.highlightNode";

            }

        }
        public class HighlightNodeResult
        {

        }
        public class HighlightRectParams : IMethodParams<HighlightRectParams, HighlightRectResult>
        {
            public string GetMethod()
            {
                return "DOM.highlightRect";

            }

        }
        public class HighlightRectResult
        {

        }
        public class MarkUndoableStateParams : IMethodParams<MarkUndoableStateParams, MarkUndoableStateResult>
        {
            public string GetMethod()
            {
                return "DOM.markUndoableState";

            }

        }
        public class MarkUndoableStateResult
        {

        }
        public class MoveToParams : IMethodParams<MoveToParams, MoveToResult>
        {
            public string GetMethod()
            {
                return "DOM.moveTo";

            }
            /// <summary>
            /// Id of the node to move.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Id of the element to drop the moved node into.
            /// </summary>
            public int TargetNodeId
            {
                get; set;
            }
            /// <summary>
            /// Drop node before this one (if absent, the moved node becomes the last child of
            /// `targetNodeId`).
            /// </summary>
            public int? InsertBeforeNodeId
            {
                get; set;
            }

        }
        public class MoveToResult
        {
            /// <summary>
            /// New id of the moved node.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class PerformSearchParams : IMethodParams<PerformSearchParams, PerformSearchResult>
        {
            public string GetMethod()
            {
                return "DOM.performSearch";

            }
            /// <summary>
            /// Plain text or query selector or XPath search query.
            /// </summary>
            public string Query
            {
                get; set;
            }
            /// <summary>
            /// True to search in user agent shadow DOM.
            /// </summary>
            public bool? IncludeUserAgentShadowDOM
            {
                get; set;
            }

        }
        public class PerformSearchResult
        {
            /// <summary>
            /// Unique search session identifier.
            /// </summary>
            public string SearchId
            {
                get; set;
            }
            /// <summary>
            /// Number of search results.
            /// </summary>
            public int ResultCount
            {
                get; set;
            }

        }
        public class PushNodeByPathToFrontendParams : IMethodParams<PushNodeByPathToFrontendParams, PushNodeByPathToFrontendResult>
        {
            public string GetMethod()
            {
                return "DOM.pushNodeByPathToFrontend";

            }
            /// <summary>
            /// Path to node in the proprietary format.
            /// </summary>
            public string Path
            {
                get; set;
            }

        }
        public class PushNodeByPathToFrontendResult
        {
            /// <summary>
            /// Id of the node for given path.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class PushNodesByBackendIdsToFrontendParams : IMethodParams<PushNodesByBackendIdsToFrontendParams, PushNodesByBackendIdsToFrontendResult>
        {
            public string GetMethod()
            {
                return "DOM.pushNodesByBackendIdsToFrontend";

            }
            /// <summary>
            /// The array of backend node ids.
            /// </summary>
            public int[] BackendNodeIds
            {
                get; set;
            }

        }
        public class PushNodesByBackendIdsToFrontendResult
        {
            /// <summary>
            /// The array of ids of pushed nodes that correspond to the backend ids specified in
            /// backendNodeIds.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class QuerySelectorParams : IMethodParams<QuerySelectorParams, QuerySelectorResult>
        {
            public string GetMethod()
            {
                return "DOM.querySelector";

            }
            /// <summary>
            /// Id of the node to query upon.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Selector string.
            /// </summary>
            public string Selector
            {
                get; set;
            }

        }
        public class QuerySelectorResult
        {
            /// <summary>
            /// Query selector result.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class QuerySelectorAllParams : IMethodParams<QuerySelectorAllParams, QuerySelectorAllResult>
        {
            public string GetMethod()
            {
                return "DOM.querySelectorAll";

            }
            /// <summary>
            /// Id of the node to query upon.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Selector string.
            /// </summary>
            public string Selector
            {
                get; set;
            }

        }
        public class QuerySelectorAllResult
        {
            /// <summary>
            /// Query selector result.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class GetTopLayerElementsParams : IMethodParams<GetTopLayerElementsParams, GetTopLayerElementsResult>
        {
            public string GetMethod()
            {
                return "DOM.getTopLayerElements";

            }

        }
        public class GetTopLayerElementsResult
        {
            /// <summary>
            /// NodeIds of top layer elements
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class RedoParams : IMethodParams<RedoParams, RedoResult>
        {
            public string GetMethod()
            {
                return "DOM.redo";

            }

        }
        public class RedoResult
        {

        }
        public class RemoveAttributeParams : IMethodParams<RemoveAttributeParams, RemoveAttributeResult>
        {
            public string GetMethod()
            {
                return "DOM.removeAttribute";

            }
            /// <summary>
            /// Id of the element to remove attribute from.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Name of the attribute to remove.
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        public class RemoveAttributeResult
        {

        }
        public class RemoveNodeParams : IMethodParams<RemoveNodeParams, RemoveNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.removeNode";

            }
            /// <summary>
            /// Id of the node to remove.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class RemoveNodeResult
        {

        }
        public class RequestChildNodesParams : IMethodParams<RequestChildNodesParams, RequestChildNodesResult>
        {
            public string GetMethod()
            {
                return "DOM.requestChildNodes";

            }
            /// <summary>
            /// Id of the node to get children for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
            /// entire subtree or provide an integer larger than 0.
            /// </summary>
            public int? Depth
            {
                get; set;
            }
            /// <summary>
            /// Whether or not iframes and shadow roots should be traversed when returning the sub-tree
            /// (default is false).
            /// </summary>
            public bool? Pierce
            {
                get; set;
            }

        }
        public class RequestChildNodesResult
        {

        }
        public class RequestNodeParams : IMethodParams<RequestNodeParams, RequestNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.requestNode";

            }
            /// <summary>
            /// JavaScript object id to convert into node.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }

        }
        public class RequestNodeResult
        {
            /// <summary>
            /// Node id for given object.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class ResolveNodeParams : IMethodParams<ResolveNodeParams, ResolveNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.resolveNode";

            }
            /// <summary>
            /// Id of the node to resolve.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Backend identifier of the node to resolve.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// Symbolic group name that can be used to release multiple objects.
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }
            /// <summary>
            /// Execution context in which to resolve the node.
            /// </summary>
            public int? ExecutionContextId
            {
                get; set;
            }

        }
        public class ResolveNodeResult
        {
            /// <summary>
            /// JavaScript object wrapper for given node.
            /// </summary>
            public RuntimeDomain.RemoteObject Object
            {
                get; set;
            }

        }
        public class SetAttributeValueParams : IMethodParams<SetAttributeValueParams, SetAttributeValueResult>
        {
            public string GetMethod()
            {
                return "DOM.setAttributeValue";

            }
            /// <summary>
            /// Id of the element to set attribute for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Attribute name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Attribute value.
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        public class SetAttributeValueResult
        {

        }
        public class SetAttributesAsTextParams : IMethodParams<SetAttributesAsTextParams, SetAttributesAsTextResult>
        {
            public string GetMethod()
            {
                return "DOM.setAttributesAsText";

            }
            /// <summary>
            /// Id of the element to set attributes for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Text with a number of attributes. Will parse this text using HTML parser.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// Attribute name to replace with new attributes derived from text in case text parsed
            /// successfully.
            /// </summary>
            public string? Name
            {
                get; set;
            }

        }
        public class SetAttributesAsTextResult
        {

        }
        public class SetFileInputFilesParams : IMethodParams<SetFileInputFilesParams, SetFileInputFilesResult>
        {
            public string GetMethod()
            {
                return "DOM.setFileInputFiles";

            }
            /// <summary>
            /// Array of file paths to set.
            /// </summary>
            public string[] Files
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the node.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class SetFileInputFilesResult
        {

        }
        public class SetNodeStackTracesEnabledParams : IMethodParams<SetNodeStackTracesEnabledParams, SetNodeStackTracesEnabledResult>
        {
            public string GetMethod()
            {
                return "DOM.setNodeStackTracesEnabled";

            }
            /// <summary>
            /// Enable or disable.
            /// </summary>
            public bool Enable
            {
                get; set;
            }

        }
        public class SetNodeStackTracesEnabledResult
        {

        }
        public class GetNodeStackTracesParams : IMethodParams<GetNodeStackTracesParams, GetNodeStackTracesResult>
        {
            public string GetMethod()
            {
                return "DOM.getNodeStackTraces";

            }
            /// <summary>
            /// Id of the node to get stack traces for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetNodeStackTracesResult
        {
            /// <summary>
            /// Creation stack trace, if available.
            /// </summary>
            public RuntimeDomain.StackTrace? Creation
            {
                get; set;
            }

        }
        public class GetFileInfoParams : IMethodParams<GetFileInfoParams, GetFileInfoResult>
        {
            public string GetMethod()
            {
                return "DOM.getFileInfo";

            }
            /// <summary>
            /// JavaScript object id of the node wrapper.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }

        }
        public class GetFileInfoResult
        {
            /// <summary>
            /// </summary>
            public string Path
            {
                get; set;
            }

        }
        public class SetInspectedNodeParams : IMethodParams<SetInspectedNodeParams, SetInspectedNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.setInspectedNode";

            }
            /// <summary>
            /// DOM node id to be accessible by means of $x command line API.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class SetInspectedNodeResult
        {

        }
        public class SetNodeNameParams : IMethodParams<SetNodeNameParams, SetNodeNameResult>
        {
            public string GetMethod()
            {
                return "DOM.setNodeName";

            }
            /// <summary>
            /// Id of the node to set name for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// New node's name.
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        public class SetNodeNameResult
        {
            /// <summary>
            /// New node's id.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class SetNodeValueParams : IMethodParams<SetNodeValueParams, SetNodeValueResult>
        {
            public string GetMethod()
            {
                return "DOM.setNodeValue";

            }
            /// <summary>
            /// Id of the node to set value for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// New node's value.
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        public class SetNodeValueResult
        {

        }
        public class SetOuterHTMLParams : IMethodParams<SetOuterHTMLParams, SetOuterHTMLResult>
        {
            public string GetMethod()
            {
                return "DOM.setOuterHTML";

            }
            /// <summary>
            /// Id of the node to set markup for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Outer HTML markup to set.
            /// </summary>
            public string OuterHTML
            {
                get; set;
            }

        }
        public class SetOuterHTMLResult
        {

        }
        public class UndoParams : IMethodParams<UndoParams, UndoResult>
        {
            public string GetMethod()
            {
                return "DOM.undo";

            }

        }
        public class UndoResult
        {

        }
        public class GetFrameOwnerParams : IMethodParams<GetFrameOwnerParams, GetFrameOwnerResult>
        {
            public string GetMethod()
            {
                return "DOM.getFrameOwner";

            }
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class GetFrameOwnerResult
        {
            /// <summary>
            /// Resulting node.
            /// </summary>
            public int BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// Id of the node at given coordinates, only when enabled and requested document.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }

        }
        public class GetContainerForNodeParams : IMethodParams<GetContainerForNodeParams, GetContainerForNodeResult>
        {
            public string GetMethod()
            {
                return "DOM.getContainerForNode";

            }
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? ContainerName
            {
                get; set;
            }

        }
        public class GetContainerForNodeResult
        {
            /// <summary>
            /// The container node for the given node, or null if not found.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }

        }
        public class GetQueryingDescendantsForContainerParams : IMethodParams<GetQueryingDescendantsForContainerParams, GetQueryingDescendantsForContainerResult>
        {
            public string GetMethod()
            {
                return "DOM.getQueryingDescendantsForContainer";

            }
            /// <summary>
            /// Id of the container node to find querying descendants from.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetQueryingDescendantsForContainerResult
        {
            /// <summary>
            /// Descendant nodes with container queries against the given container.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        /// <summary>
        /// Backend node with a friendly name.
        /// </summary>
        public class BackendNode
        {
            /// <summary>
            /// `Node`'s nodeType.
            /// </summary>
            public int NodeType
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeName.
            /// </summary>
            public string NodeName
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int BackendNodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// Pseudo element type.
        /// </summary>
        public enum PseudoType
        {
            [EnumValue("first-line")]
            FirstLine = 1,
            [EnumValue("first-letter")]
            FirstLetter = 2,
            [EnumValue("before")]
            Before = 3,
            [EnumValue("after")]
            After = 4,
            [EnumValue("marker")]
            Marker = 5,
            [EnumValue("backdrop")]
            Backdrop = 6,
            [EnumValue("selection")]
            Selection = 7,
            [EnumValue("target-text")]
            TargetText = 8,
            [EnumValue("spelling-error")]
            SpellingError = 9,
            [EnumValue("grammar-error")]
            GrammarError = 10,
            [EnumValue("highlight")]
            Highlight = 11,
            [EnumValue("first-line-inherited")]
            FirstLineInherited = 12,
            [EnumValue("scrollbar")]
            Scrollbar = 13,
            [EnumValue("scrollbar-thumb")]
            ScrollbarThumb = 14,
            [EnumValue("scrollbar-button")]
            ScrollbarButton = 15,
            [EnumValue("scrollbar-track")]
            ScrollbarTrack = 16,
            [EnumValue("scrollbar-track-piece")]
            ScrollbarTrackPiece = 17,
            [EnumValue("scrollbar-corner")]
            ScrollbarCorner = 18,
            [EnumValue("resizer")]
            Resizer = 19,
            [EnumValue("input-list-button")]
            InputListButton = 20,
            [EnumValue("page-transition")]
            PageTransition = 21,
            [EnumValue("page-transition-container")]
            PageTransitionContainer = 22,
            [EnumValue("page-transition-image-wrapper")]
            PageTransitionImageWrapper = 23,
            [EnumValue("page-transition-outgoing-image")]
            PageTransitionOutgoingImage = 24,
            [EnumValue("page-transition-incoming-image")]
            PageTransitionIncomingImage = 25,

        }
        /// <summary>
        /// Shadow root type.
        /// </summary>
        public enum ShadowRootType
        {
            [EnumValue("user-agent")]
            UserAgent = 1,
            [EnumValue("open")]
            Open = 2,
            [EnumValue("closed")]
            Closed = 3,

        }
        /// <summary>
        /// Document compatibility mode.
        /// </summary>
        public enum CompatibilityMode
        {
            [EnumValue("QuirksMode")]
            QuirksMode = 1,
            [EnumValue("LimitedQuirksMode")]
            LimitedQuirksMode = 2,
            [EnumValue("NoQuirksMode")]
            NoQuirksMode = 3,

        }
        /// <summary>
        /// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
        /// DOMNode is a base node mirror type.
        /// </summary>
        public class Node
        {
            /// <summary>
            /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
            /// will only push node with given `id` once. It is aware of all requested nodes and will only
            /// fire DOM events for nodes known to the client.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// The id of the parent node if any.
            /// </summary>
            public int? ParentId
            {
                get; set;
            }
            /// <summary>
            /// The BackendNodeId for this node.
            /// </summary>
            public int BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeType.
            /// </summary>
            public int NodeType
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeName.
            /// </summary>
            public string NodeName
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s localName.
            /// </summary>
            public string LocalName
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeValue.
            /// </summary>
            public string NodeValue
            {
                get; set;
            }
            /// <summary>
            /// Child count for `Container` nodes.
            /// </summary>
            public int? ChildNodeCount
            {
                get; set;
            }
            /// <summary>
            /// Child nodes of this node when requested with children.
            /// </summary>
            public DOMDomain.Node[]? Children
            {
                get; set;
            }
            /// <summary>
            /// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
            /// </summary>
            public string[]? Attributes
            {
                get; set;
            }
            /// <summary>
            /// Document URL that `Document` or `FrameOwner` node points to.
            /// </summary>
            public string? DocumentURL
            {
                get; set;
            }
            /// <summary>
            /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
            /// </summary>
            public string? BaseURL
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType`'s publicId.
            /// </summary>
            public string? PublicId
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType`'s systemId.
            /// </summary>
            public string? SystemId
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType`'s internalSubset.
            /// </summary>
            public string? InternalSubset
            {
                get; set;
            }
            /// <summary>
            /// `Document`'s XML version in case of XML documents.
            /// </summary>
            public string? XmlVersion
            {
                get; set;
            }
            /// <summary>
            /// `Attr`'s name.
            /// </summary>
            public string? Name
            {
                get; set;
            }
            /// <summary>
            /// `Attr`'s value.
            /// </summary>
            public string? Value
            {
                get; set;
            }
            /// <summary>
            /// Pseudo element type for this node.
            /// </summary>
            public DOMDomain.PseudoType? PseudoType
            {
                get; set;
            }
            /// <summary>
            /// Pseudo element identifier for this node. Only present if there is a
            /// valid pseudoType.
            /// </summary>
            public string? PseudoIdentifier
            {
                get; set;
            }
            /// <summary>
            /// Shadow root type.
            /// </summary>
            public DOMDomain.ShadowRootType? ShadowRootType
            {
                get; set;
            }
            /// <summary>
            /// Frame ID for frame owner elements.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }
            /// <summary>
            /// Content document for frame owner elements.
            /// </summary>
            public DOMDomain.Node? ContentDocument
            {
                get; set;
            }
            /// <summary>
            /// Shadow root list for given element host.
            /// </summary>
            public DOMDomain.Node[]? ShadowRoots
            {
                get; set;
            }
            /// <summary>
            /// Content document fragment for template elements.
            /// </summary>
            public DOMDomain.Node? TemplateContent
            {
                get; set;
            }
            /// <summary>
            /// Pseudo elements associated with this node.
            /// </summary>
            public DOMDomain.Node[]? PseudoElements
            {
                get; set;
            }
            /// <summary>
            /// Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
            /// This property used to return the imported document for the HTMLImport links.
            /// The property is always undefined now.
            /// </summary>
            [Obsolete]
            public DOMDomain.Node? ImportedDocument
            {
                get; set;
            }
            /// <summary>
            /// Distributed nodes for given insertion point.
            /// </summary>
            public DOMDomain.BackendNode[]? DistributedNodes
            {
                get; set;
            }
            /// <summary>
            /// Whether the node is SVG.
            /// </summary>
            public bool? IsSVG
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DOMDomain.CompatibilityMode? CompatibilityMode
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DOMDomain.BackendNode? AssignedSlot
            {
                get; set;
            }

        }
        /// <summary>
        /// A structure holding an RGBA color.
        /// </summary>
        public class RGBA
        {
            /// <summary>
            /// The red component, in the [0-255] range.
            /// </summary>
            public int R
            {
                get; set;
            }
            /// <summary>
            /// The green component, in the [0-255] range.
            /// </summary>
            public int G
            {
                get; set;
            }
            /// <summary>
            /// The blue component, in the [0-255] range.
            /// </summary>
            public int B
            {
                get; set;
            }
            /// <summary>
            /// The alpha component, in the [0-1] range (default: 1).
            /// </summary>
            public double? A
            {
                get; set;
            }

        }
        /// <summary>
        /// Box model.
        /// </summary>
        public class BoxModel
        {
            /// <summary>
            /// Content box
            /// </summary>
            public double[] Content
            {
                get; set;
            }
            /// <summary>
            /// Padding box
            /// </summary>
            public double[] Padding
            {
                get; set;
            }
            /// <summary>
            /// Border box
            /// </summary>
            public double[] Border
            {
                get; set;
            }
            /// <summary>
            /// Margin box
            /// </summary>
            public double[] Margin
            {
                get; set;
            }
            /// <summary>
            /// Node width
            /// </summary>
            public int Width
            {
                get; set;
            }
            /// <summary>
            /// Node height
            /// </summary>
            public int Height
            {
                get; set;
            }
            /// <summary>
            /// Shape outside coordinates
            /// </summary>
            public DOMDomain.ShapeOutsideInfo? ShapeOutside
            {
                get; set;
            }

        }
        /// <summary>
        /// CSS Shape Outside details.
        /// </summary>
        public class ShapeOutsideInfo
        {
            /// <summary>
            /// Shape bounds
            /// </summary>
            public double[] Bounds
            {
                get; set;
            }
            /// <summary>
            /// Shape coordinate details
            /// </summary>
            public object[] Shape
            {
                get; set;
            }
            /// <summary>
            /// Margin shape bounds
            /// </summary>
            public object[] MarginShape
            {
                get; set;
            }

        }
        /// <summary>
        /// Rectangle.
        /// </summary>
        public class Rect
        {
            /// <summary>
            /// X coordinate
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// Rectangle width
            /// </summary>
            public double Width
            {
                get; set;
            }
            /// <summary>
            /// Rectangle height
            /// </summary>
            public double Height
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class CSSComputedStyleProperty
        {
            /// <summary>
            /// Computed style property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Computed style property value.
            /// </summary>
            public string Value
            {
                get; set;
            }

        }

    }
    public class DOMDebuggerDomain : BaseDomain
    {
        public DOMDebuggerDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "DOMDebugger";

            }

        }
        /// <summary>
        /// Returns event listeners of the given object.
        /// </summary>
        public async ValueTask<GetEventListenersResult> GetEventListenersAsync(GetEventListenersParams getEventListenersParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getEventListenersParams, cancellationToken);

        }
        /// <summary>
        /// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
        /// </summary>
        public async ValueTask<RemoveDOMBreakpointResult> RemoveDOMBreakpointAsync(RemoveDOMBreakpointParams removeDOMBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeDOMBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Removes breakpoint on particular DOM event.
        /// </summary>
        public async ValueTask<RemoveEventListenerBreakpointResult> RemoveEventListenerBreakpointAsync(RemoveEventListenerBreakpointParams removeEventListenerBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeEventListenerBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Removes breakpoint on particular native event.
        /// </summary>
        [Experimental]
        public async ValueTask<RemoveInstrumentationBreakpointResult> RemoveInstrumentationBreakpointAsync(RemoveInstrumentationBreakpointParams removeInstrumentationBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeInstrumentationBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Removes breakpoint from XMLHttpRequest.
        /// </summary>
        public async ValueTask<RemoveXHRBreakpointResult> RemoveXHRBreakpointAsync(RemoveXHRBreakpointParams removeXHRBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeXHRBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Sets breakpoint on particular CSP violations.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBreakOnCSPViolationResult> SetBreakOnCSPViolationAsync(SetBreakOnCSPViolationParams setBreakOnCSPViolationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBreakOnCSPViolationParams, cancellationToken);

        }
        /// <summary>
        /// Sets breakpoint on particular operation with DOM.
        /// </summary>
        public async ValueTask<SetDOMBreakpointResult> SetDOMBreakpointAsync(SetDOMBreakpointParams setDOMBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDOMBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Sets breakpoint on particular DOM event.
        /// </summary>
        public async ValueTask<SetEventListenerBreakpointResult> SetEventListenerBreakpointAsync(SetEventListenerBreakpointParams setEventListenerBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setEventListenerBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Sets breakpoint on particular native event.
        /// </summary>
        [Experimental]
        public async ValueTask<SetInstrumentationBreakpointResult> SetInstrumentationBreakpointAsync(SetInstrumentationBreakpointParams setInstrumentationBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInstrumentationBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Sets breakpoint on XMLHttpRequest.
        /// </summary>
        public async ValueTask<SetXHRBreakpointResult> SetXHRBreakpointAsync(SetXHRBreakpointParams setXHRBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setXHRBreakpointParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class GetEventListenersParams : IMethodParams<GetEventListenersParams, GetEventListenersResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.getEventListeners";

            }
            /// <summary>
            /// Identifier of the object to return listeners for.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }
            /// <summary>
            /// The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
            /// entire subtree or provide an integer larger than 0.
            /// </summary>
            public int? Depth
            {
                get; set;
            }
            /// <summary>
            /// Whether or not iframes and shadow roots should be traversed when returning the subtree
            /// (default is false). Reports listeners for all contexts if pierce is enabled.
            /// </summary>
            public bool? Pierce
            {
                get; set;
            }

        }
        public class GetEventListenersResult
        {
            /// <summary>
            /// Array of relevant listeners.
            /// </summary>
            public DOMDebuggerDomain.EventListener[] Listeners
            {
                get; set;
            }

        }
        public class RemoveDOMBreakpointParams : IMethodParams<RemoveDOMBreakpointParams, RemoveDOMBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.removeDOMBreakpoint";

            }
            /// <summary>
            /// Identifier of the node to remove breakpoint from.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Type of the breakpoint to remove.
            /// </summary>
            public DOMDebuggerDomain.DOMBreakpointType Type
            {
                get; set;
            }

        }
        public class RemoveDOMBreakpointResult
        {

        }
        public class RemoveEventListenerBreakpointParams : IMethodParams<RemoveEventListenerBreakpointParams, RemoveEventListenerBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.removeEventListenerBreakpoint";

            }
            /// <summary>
            /// Event name.
            /// </summary>
            public string EventName
            {
                get; set;
            }
            /// <summary>
            /// EventTarget interface name.
            /// </summary>
            [Experimental]
            public string? TargetName
            {
                get; set;
            }

        }
        public class RemoveEventListenerBreakpointResult
        {

        }
        public class RemoveInstrumentationBreakpointParams : IMethodParams<RemoveInstrumentationBreakpointParams, RemoveInstrumentationBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.removeInstrumentationBreakpoint";

            }
            /// <summary>
            /// Instrumentation name to stop on.
            /// </summary>
            public string EventName
            {
                get; set;
            }

        }
        public class RemoveInstrumentationBreakpointResult
        {

        }
        public class RemoveXHRBreakpointParams : IMethodParams<RemoveXHRBreakpointParams, RemoveXHRBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.removeXHRBreakpoint";

            }
            /// <summary>
            /// Resource URL substring.
            /// </summary>
            public string Url
            {
                get; set;
            }

        }
        public class RemoveXHRBreakpointResult
        {

        }
        public class SetBreakOnCSPViolationParams : IMethodParams<SetBreakOnCSPViolationParams, SetBreakOnCSPViolationResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.setBreakOnCSPViolation";

            }
            /// <summary>
            /// CSP Violations to stop upon.
            /// </summary>
            public DOMDebuggerDomain.CSPViolationType[] ViolationTypes
            {
                get; set;
            }

        }
        public class SetBreakOnCSPViolationResult
        {

        }
        public class SetDOMBreakpointParams : IMethodParams<SetDOMBreakpointParams, SetDOMBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.setDOMBreakpoint";

            }
            /// <summary>
            /// Identifier of the node to set breakpoint on.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Type of the operation to stop upon.
            /// </summary>
            public DOMDebuggerDomain.DOMBreakpointType Type
            {
                get; set;
            }

        }
        public class SetDOMBreakpointResult
        {

        }
        public class SetEventListenerBreakpointParams : IMethodParams<SetEventListenerBreakpointParams, SetEventListenerBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.setEventListenerBreakpoint";

            }
            /// <summary>
            /// DOM Event name to stop on (any DOM event will do).
            /// </summary>
            public string EventName
            {
                get; set;
            }
            /// <summary>
            /// EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
            /// EventTarget.
            /// </summary>
            [Experimental]
            public string? TargetName
            {
                get; set;
            }

        }
        public class SetEventListenerBreakpointResult
        {

        }
        public class SetInstrumentationBreakpointParams : IMethodParams<SetInstrumentationBreakpointParams, SetInstrumentationBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.setInstrumentationBreakpoint";

            }
            /// <summary>
            /// Instrumentation name to stop on.
            /// </summary>
            public string EventName
            {
                get; set;
            }

        }
        public class SetInstrumentationBreakpointResult
        {

        }
        public class SetXHRBreakpointParams : IMethodParams<SetXHRBreakpointParams, SetXHRBreakpointResult>
        {
            public string GetMethod()
            {
                return "DOMDebugger.setXHRBreakpoint";

            }
            /// <summary>
            /// Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
            /// </summary>
            public string Url
            {
                get; set;
            }

        }
        public class SetXHRBreakpointResult
        {

        }
        /// <summary>
        /// DOM breakpoint type.
        /// </summary>
        public enum DOMBreakpointType
        {
            [EnumValue("subtree-modified")]
            SubtreeModified = 1,
            [EnumValue("attribute-modified")]
            AttributeModified = 2,
            [EnumValue("node-removed")]
            NodeRemoved = 3,

        }
        /// <summary>
        /// CSP Violation type.
        /// </summary>
        [Experimental]
        public enum CSPViolationType
        {
            [EnumValue("trustedtype-sink-violation")]
            TrustedtypeSinkViolation = 1,
            [EnumValue("trustedtype-policy-violation")]
            TrustedtypePolicyViolation = 2,

        }
        /// <summary>
        /// Object event listener.
        /// </summary>
        public class EventListener
        {
            /// <summary>
            /// `EventListener`'s type.
            /// </summary>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// `EventListener`'s useCapture.
            /// </summary>
            public bool UseCapture
            {
                get; set;
            }
            /// <summary>
            /// `EventListener`'s passive flag.
            /// </summary>
            public bool Passive
            {
                get; set;
            }
            /// <summary>
            /// `EventListener`'s once flag.
            /// </summary>
            public bool Once
            {
                get; set;
            }
            /// <summary>
            /// Script id of the handler code.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// Line number in the script (0-based).
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// Column number in the script (0-based).
            /// </summary>
            public int ColumnNumber
            {
                get; set;
            }
            /// <summary>
            /// Event handler function value.
            /// </summary>
            public RuntimeDomain.RemoteObject? Handler
            {
                get; set;
            }
            /// <summary>
            /// Event original handler function value.
            /// </summary>
            public RuntimeDomain.RemoteObject? OriginalHandler
            {
                get; set;
            }
            /// <summary>
            /// Node the listener is added to (if any).
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }

        }

    }
    public class EventBreakpointsDomain : BaseDomain
    {
        public EventBreakpointsDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "EventBreakpoints";

            }

        }
        /// <summary>
        /// Sets breakpoint on particular native event.
        /// </summary>
        public async ValueTask<SetInstrumentationBreakpointResult> SetInstrumentationBreakpointAsync(SetInstrumentationBreakpointParams setInstrumentationBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInstrumentationBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Removes breakpoint on particular native event.
        /// </summary>
        public async ValueTask<RemoveInstrumentationBreakpointResult> RemoveInstrumentationBreakpointAsync(RemoveInstrumentationBreakpointParams removeInstrumentationBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeInstrumentationBreakpointParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class SetInstrumentationBreakpointParams : IMethodParams<SetInstrumentationBreakpointParams, SetInstrumentationBreakpointResult>
        {
            public string GetMethod()
            {
                return "EventBreakpoints.setInstrumentationBreakpoint";

            }
            /// <summary>
            /// Instrumentation name to stop on.
            /// </summary>
            public string EventName
            {
                get; set;
            }

        }
        public class SetInstrumentationBreakpointResult
        {

        }
        public class RemoveInstrumentationBreakpointParams : IMethodParams<RemoveInstrumentationBreakpointParams, RemoveInstrumentationBreakpointResult>
        {
            public string GetMethod()
            {
                return "EventBreakpoints.removeInstrumentationBreakpoint";

            }
            /// <summary>
            /// Instrumentation name to stop on.
            /// </summary>
            public string EventName
            {
                get; set;
            }

        }
        public class RemoveInstrumentationBreakpointResult
        {

        }

    }
    public class DOMSnapshotDomain : BaseDomain
    {
        public DOMSnapshotDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "DOMSnapshot";

            }

        }
        /// <summary>
        /// Disables DOM snapshot agent for the given page.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables DOM snapshot agent for the given page.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
        /// template contents, and imported documents) in a flattened array, as well as layout and
        /// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
        /// flattened.
        /// </summary>
        [Obsolete]
        public async ValueTask<GetSnapshotResult> GetSnapshotAsync(GetSnapshotParams getSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getSnapshotParams, cancellationToken);

        }
        /// <summary>
        /// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
        /// template contents, and imported documents) in a flattened array, as well as layout and
        /// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
        /// flattened.
        /// </summary>
        public async ValueTask<CaptureSnapshotResult> CaptureSnapshotAsync(CaptureSnapshotParams captureSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(captureSnapshotParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "DOMSnapshot.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "DOMSnapshot.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetSnapshotParams : IMethodParams<GetSnapshotParams, GetSnapshotResult>
        {
            public string GetMethod()
            {
                return "DOMSnapshot.getSnapshot";

            }
            /// <summary>
            /// Whitelist of computed styles to return.
            /// </summary>
            public string[] ComputedStyleWhitelist
            {
                get; set;
            }
            /// <summary>
            /// Whether or not to retrieve details of DOM listeners (default false).
            /// </summary>
            public bool? IncludeEventListeners
            {
                get; set;
            }
            /// <summary>
            /// Whether to determine and include the paint order index of LayoutTreeNodes (default false).
            /// </summary>
            public bool? IncludePaintOrder
            {
                get; set;
            }
            /// <summary>
            /// Whether to include UA shadow tree in the snapshot (default false).
            /// </summary>
            public bool? IncludeUserAgentShadowTree
            {
                get; set;
            }

        }
        public class GetSnapshotResult
        {
            /// <summary>
            /// The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
            /// </summary>
            public DOMSnapshotDomain.DOMNode[] DomNodes
            {
                get; set;
            }
            /// <summary>
            /// The nodes in the layout tree.
            /// </summary>
            public DOMSnapshotDomain.LayoutTreeNode[] LayoutTreeNodes
            {
                get; set;
            }
            /// <summary>
            /// Whitelisted ComputedStyle properties for each node in the layout tree.
            /// </summary>
            public DOMSnapshotDomain.ComputedStyle[] ComputedStyles
            {
                get; set;
            }

        }
        public class CaptureSnapshotParams : IMethodParams<CaptureSnapshotParams, CaptureSnapshotResult>
        {
            public string GetMethod()
            {
                return "DOMSnapshot.captureSnapshot";

            }
            /// <summary>
            /// Whitelist of computed styles to return.
            /// </summary>
            public string[] ComputedStyles
            {
                get; set;
            }
            /// <summary>
            /// Whether to include layout object paint orders into the snapshot.
            /// </summary>
            public bool? IncludePaintOrder
            {
                get; set;
            }
            /// <summary>
            /// Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
            /// </summary>
            public bool? IncludeDOMRects
            {
                get; set;
            }
            /// <summary>
            /// Whether to include blended background colors in the snapshot (default: false).
            /// Blended background color is achieved by blending background colors of all elements
            /// that overlap with the current element.
            /// </summary>
            [Experimental]
            public bool? IncludeBlendedBackgroundColors
            {
                get; set;
            }
            /// <summary>
            /// Whether to include text color opacity in the snapshot (default: false).
            /// An element might have the opacity property set that affects the text color of the element.
            /// The final text color opacity is computed based on the opacity of all overlapping elements.
            /// </summary>
            [Experimental]
            public bool? IncludeTextColorOpacities
            {
                get; set;
            }

        }
        public class CaptureSnapshotResult
        {
            /// <summary>
            /// The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
            /// </summary>
            public DOMSnapshotDomain.DocumentSnapshot[] Documents
            {
                get; set;
            }
            /// <summary>
            /// Shared string table that all string properties refer to with indexes.
            /// </summary>
            public string[] Strings
            {
                get; set;
            }

        }
        /// <summary>
        /// A Node in the DOM tree.
        /// </summary>
        public class DOMNode
        {
            /// <summary>
            /// `Node`'s nodeType.
            /// </summary>
            public int NodeType
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeName.
            /// </summary>
            public string NodeName
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeValue.
            /// </summary>
            public string NodeValue
            {
                get; set;
            }
            /// <summary>
            /// Only set for textarea elements, contains the text value.
            /// </summary>
            public string? TextValue
            {
                get; set;
            }
            /// <summary>
            /// Only set for input elements, contains the input's associated text value.
            /// </summary>
            public string? InputValue
            {
                get; set;
            }
            /// <summary>
            /// Only set for radio and checkbox input elements, indicates if the element has been checked
            /// </summary>
            public bool? InputChecked
            {
                get; set;
            }
            /// <summary>
            /// Only set for option elements, indicates if the element has been selected
            /// </summary>
            public bool? OptionSelected
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s id, corresponds to DOM.Node.backendNodeId.
            /// </summary>
            public int BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
            /// any.
            /// </summary>
            public int[]? ChildNodeIndexes
            {
                get; set;
            }
            /// <summary>
            /// Attributes of an `Element` node.
            /// </summary>
            public DOMSnapshotDomain.NameValue[]? Attributes
            {
                get; set;
            }
            /// <summary>
            /// Indexes of pseudo elements associated with this node in the `domNodes` array returned by
            /// `getSnapshot`, if any.
            /// </summary>
            public int[]? PseudoElementIndexes
            {
                get; set;
            }
            /// <summary>
            /// The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
            /// `getSnapshot`, if any.
            /// </summary>
            public int? LayoutNodeIndex
            {
                get; set;
            }
            /// <summary>
            /// Document URL that `Document` or `FrameOwner` node points to.
            /// </summary>
            public string? DocumentURL
            {
                get; set;
            }
            /// <summary>
            /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
            /// </summary>
            public string? BaseURL
            {
                get; set;
            }
            /// <summary>
            /// Only set for documents, contains the document's content language.
            /// </summary>
            public string? ContentLanguage
            {
                get; set;
            }
            /// <summary>
            /// Only set for documents, contains the document's character set encoding.
            /// </summary>
            public string? DocumentEncoding
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType` node's publicId.
            /// </summary>
            public string? PublicId
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType` node's systemId.
            /// </summary>
            public string? SystemId
            {
                get; set;
            }
            /// <summary>
            /// Frame ID for frame owner elements and also for the document node.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }
            /// <summary>
            /// The index of a frame owner element's content document in the `domNodes` array returned by
            /// `getSnapshot`, if any.
            /// </summary>
            public int? ContentDocumentIndex
            {
                get; set;
            }
            /// <summary>
            /// Type of a pseudo element node.
            /// </summary>
            public DOMDomain.PseudoType? PseudoType
            {
                get; set;
            }
            /// <summary>
            /// Shadow root type.
            /// </summary>
            public DOMDomain.ShadowRootType? ShadowRootType
            {
                get; set;
            }
            /// <summary>
            /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
            /// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
            /// clicked.
            /// </summary>
            public bool? IsClickable
            {
                get; set;
            }
            /// <summary>
            /// Details of the node's event listeners, if any.
            /// </summary>
            public DOMDebuggerDomain.EventListener[]? EventListeners
            {
                get; set;
            }
            /// <summary>
            /// The selected url for nodes with a srcset attribute.
            /// </summary>
            public string? CurrentSourceURL
            {
                get; set;
            }
            /// <summary>
            /// The url of the script (if any) that generates this node.
            /// </summary>
            public string? OriginURL
            {
                get; set;
            }
            /// <summary>
            /// Scroll offsets, set when this node is a Document.
            /// </summary>
            public double? ScrollOffsetX
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? ScrollOffsetY
            {
                get; set;
            }

        }
        /// <summary>
        /// Details of post layout rendered text positions. The exact layout should not be regarded as
        /// stable and may change between versions.
        /// </summary>
        public class InlineTextBox
        {
            /// <summary>
            /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
            /// </summary>
            public DOMDomain.Rect BoundingBox
            {
                get; set;
            }
            /// <summary>
            /// The starting index in characters, for this post layout textbox substring. Characters that
            /// would be represented as a surrogate pair in UTF-16 have length 2.
            /// </summary>
            public int StartCharacterIndex
            {
                get; set;
            }
            /// <summary>
            /// The number of characters in this post layout textbox substring. Characters that would be
            /// represented as a surrogate pair in UTF-16 have length 2.
            /// </summary>
            public int NumCharacters
            {
                get; set;
            }

        }
        /// <summary>
        /// Details of an element in the DOM tree with a LayoutObject.
        /// </summary>
        public class LayoutTreeNode
        {
            /// <summary>
            /// The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
            /// </summary>
            public int DomNodeIndex
            {
                get; set;
            }
            /// <summary>
            /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
            /// </summary>
            public DOMDomain.Rect BoundingBox
            {
                get; set;
            }
            /// <summary>
            /// Contents of the LayoutText, if any.
            /// </summary>
            public string? LayoutText
            {
                get; set;
            }
            /// <summary>
            /// The post-layout inline text nodes, if any.
            /// </summary>
            public DOMSnapshotDomain.InlineTextBox[]? InlineTextNodes
            {
                get; set;
            }
            /// <summary>
            /// Index into the `computedStyles` array returned by `getSnapshot`.
            /// </summary>
            public int? StyleIndex
            {
                get; set;
            }
            /// <summary>
            /// Global paint order index, which is determined by the stacking order of the nodes. Nodes
            /// that are painted together will have the same index. Only provided if includePaintOrder in
            /// getSnapshot was true.
            /// </summary>
            public int? PaintOrder
            {
                get; set;
            }
            /// <summary>
            /// Set to true to indicate the element begins a new stacking context.
            /// </summary>
            public bool? IsStackingContext
            {
                get; set;
            }

        }
        /// <summary>
        /// A subset of the full ComputedStyle as defined by the request whitelist.
        /// </summary>
        public class ComputedStyle
        {
            /// <summary>
            /// Name/value pairs of computed style properties.
            /// </summary>
            public DOMSnapshotDomain.NameValue[] Properties
            {
                get; set;
            }

        }
        /// <summary>
        /// A name/value pair.
        /// </summary>
        public class NameValue
        {
            /// <summary>
            /// Attribute/property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Attribute/property value.
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Data that is only present on rare nodes.
        /// </summary>
        public class RareStringData
        {
            /// <summary>
            /// </summary>
            public int[] Index
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int[] Value
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class RareBooleanData
        {
            /// <summary>
            /// </summary>
            public int[] Index
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class RareIntegerData
        {
            /// <summary>
            /// </summary>
            public int[] Index
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int[] Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Document snapshot.
        /// </summary>
        public class DocumentSnapshot
        {
            /// <summary>
            /// Document URL that `Document` or `FrameOwner` node points to.
            /// </summary>
            public int DocumentURL
            {
                get; set;
            }
            /// <summary>
            /// Document title.
            /// </summary>
            public int Title
            {
                get; set;
            }
            /// <summary>
            /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
            /// </summary>
            public int BaseURL
            {
                get; set;
            }
            /// <summary>
            /// Contains the document's content language.
            /// </summary>
            public int ContentLanguage
            {
                get; set;
            }
            /// <summary>
            /// Contains the document's character set encoding.
            /// </summary>
            public int EncodingName
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType` node's publicId.
            /// </summary>
            public int PublicId
            {
                get; set;
            }
            /// <summary>
            /// `DocumentType` node's systemId.
            /// </summary>
            public int SystemId
            {
                get; set;
            }
            /// <summary>
            /// Frame ID for frame owner elements and also for the document node.
            /// </summary>
            public int FrameId
            {
                get; set;
            }
            /// <summary>
            /// A table with dom nodes.
            /// </summary>
            public DOMSnapshotDomain.NodeTreeSnapshot Nodes
            {
                get; set;
            }
            /// <summary>
            /// The nodes in the layout tree.
            /// </summary>
            public DOMSnapshotDomain.LayoutTreeSnapshot Layout
            {
                get; set;
            }
            /// <summary>
            /// The post-layout inline text nodes.
            /// </summary>
            public DOMSnapshotDomain.TextBoxSnapshot TextBoxes
            {
                get; set;
            }
            /// <summary>
            /// Horizontal scroll offset.
            /// </summary>
            public double? ScrollOffsetX
            {
                get; set;
            }
            /// <summary>
            /// Vertical scroll offset.
            /// </summary>
            public double? ScrollOffsetY
            {
                get; set;
            }
            /// <summary>
            /// Document content width.
            /// </summary>
            public double? ContentWidth
            {
                get; set;
            }
            /// <summary>
            /// Document content height.
            /// </summary>
            public double? ContentHeight
            {
                get; set;
            }

        }
        /// <summary>
        /// Table containing nodes.
        /// </summary>
        public class NodeTreeSnapshot
        {
            /// <summary>
            /// Parent node index.
            /// </summary>
            public int[]? ParentIndex
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeType.
            /// </summary>
            public int[]? NodeType
            {
                get; set;
            }
            /// <summary>
            /// Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? ShadowRootType
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeName.
            /// </summary>
            public int[]? NodeName
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s nodeValue.
            /// </summary>
            public int[]? NodeValue
            {
                get; set;
            }
            /// <summary>
            /// `Node`'s id, corresponds to DOM.Node.backendNodeId.
            /// </summary>
            public int[]? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// Attributes of an `Element` node. Flatten name, value pairs.
            /// </summary>
            public int[][]? Attributes
            {
                get; set;
            }
            /// <summary>
            /// Only set for textarea elements, contains the text value.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? TextValue
            {
                get; set;
            }
            /// <summary>
            /// Only set for input elements, contains the input's associated text value.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? InputValue
            {
                get; set;
            }
            /// <summary>
            /// Only set for radio and checkbox input elements, indicates if the element has been checked
            /// </summary>
            public DOMSnapshotDomain.RareBooleanData? InputChecked
            {
                get; set;
            }
            /// <summary>
            /// Only set for option elements, indicates if the element has been selected
            /// </summary>
            public DOMSnapshotDomain.RareBooleanData? OptionSelected
            {
                get; set;
            }
            /// <summary>
            /// The index of the document in the list of the snapshot documents.
            /// </summary>
            public DOMSnapshotDomain.RareIntegerData? ContentDocumentIndex
            {
                get; set;
            }
            /// <summary>
            /// Type of a pseudo element node.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? PseudoType
            {
                get; set;
            }
            /// <summary>
            /// Pseudo element identifier for this node. Only present if there is a
            /// valid pseudoType.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? PseudoIdentifier
            {
                get; set;
            }
            /// <summary>
            /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
            /// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
            /// clicked.
            /// </summary>
            public DOMSnapshotDomain.RareBooleanData? IsClickable
            {
                get; set;
            }
            /// <summary>
            /// The selected url for nodes with a srcset attribute.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? CurrentSourceURL
            {
                get; set;
            }
            /// <summary>
            /// The url of the script (if any) that generates this node.
            /// </summary>
            public DOMSnapshotDomain.RareStringData? OriginURL
            {
                get; set;
            }

        }
        /// <summary>
        /// Table of details of an element in the DOM tree with a LayoutObject.
        /// </summary>
        public class LayoutTreeSnapshot
        {
            /// <summary>
            /// Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
            /// </summary>
            public int[] NodeIndex
            {
                get; set;
            }
            /// <summary>
            /// Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
            /// </summary>
            public int[][] Styles
            {
                get; set;
            }
            /// <summary>
            /// The absolute position bounding box.
            /// </summary>
            public double[][] Bounds
            {
                get; set;
            }
            /// <summary>
            /// Contents of the LayoutText, if any.
            /// </summary>
            public int[] Text
            {
                get; set;
            }
            /// <summary>
            /// Stacking context information.
            /// </summary>
            public DOMSnapshotDomain.RareBooleanData StackingContexts
            {
                get; set;
            }
            /// <summary>
            /// Global paint order index, which is determined by the stacking order of the nodes. Nodes
            /// that are painted together will have the same index. Only provided if includePaintOrder in
            /// captureSnapshot was true.
            /// </summary>
            public int[]? PaintOrders
            {
                get; set;
            }
            /// <summary>
            /// The offset rect of nodes. Only available when includeDOMRects is set to true
            /// </summary>
            public double[][]? OffsetRects
            {
                get; set;
            }
            /// <summary>
            /// The scroll rect of nodes. Only available when includeDOMRects is set to true
            /// </summary>
            public double[][]? ScrollRects
            {
                get; set;
            }
            /// <summary>
            /// The client rect of nodes. Only available when includeDOMRects is set to true
            /// </summary>
            public double[][]? ClientRects
            {
                get; set;
            }
            /// <summary>
            /// The list of background colors that are blended with colors of overlapping elements.
            /// </summary>
            [Experimental]
            public int[]? BlendedBackgroundColors
            {
                get; set;
            }
            /// <summary>
            /// The list of computed text opacities.
            /// </summary>
            [Experimental]
            public double[]? TextColorOpacities
            {
                get; set;
            }

        }
        /// <summary>
        /// Table of details of the post layout rendered text positions. The exact layout should not be regarded as
        /// stable and may change between versions.
        /// </summary>
        public class TextBoxSnapshot
        {
            /// <summary>
            /// Index of the layout tree node that owns this box collection.
            /// </summary>
            public int[] LayoutIndex
            {
                get; set;
            }
            /// <summary>
            /// The absolute position bounding box.
            /// </summary>
            public double[][] Bounds
            {
                get; set;
            }
            /// <summary>
            /// The starting index in characters, for this post layout textbox substring. Characters that
            /// would be represented as a surrogate pair in UTF-16 have length 2.
            /// </summary>
            public int[] Start
            {
                get; set;
            }
            /// <summary>
            /// The number of characters in this post layout textbox substring. Characters that would be
            /// represented as a surrogate pair in UTF-16 have length 2.
            /// </summary>
            public int[] Length
            {
                get; set;
            }

        }

    }
    public class DOMStorageDomain : BaseDomain
    {
        public DOMStorageDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "DOMStorage";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<DomStorageItemAddedParams>? DomStorageItemAdded;
        /// <summary>
        /// </summary>
        public event EventHandler<DomStorageItemRemovedParams>? DomStorageItemRemoved;
        /// <summary>
        /// </summary>
        public event EventHandler<DomStorageItemUpdatedParams>? DomStorageItemUpdated;
        /// <summary>
        /// </summary>
        public event EventHandler<DomStorageItemsClearedParams>? DomStorageItemsCleared;
        /// <summary>
        /// </summary>
        public async ValueTask<ClearResult> ClearAsync(ClearParams clearParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearParams, cancellationToken);

        }
        /// <summary>
        /// Disables storage tracking, prevents storage events from being sent to the client.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables storage tracking, storage events will now be delivered to the client.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetDOMStorageItemsResult> GetDOMStorageItemsAsync(GetDOMStorageItemsParams getDOMStorageItemsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getDOMStorageItemsParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<RemoveDOMStorageItemResult> RemoveDOMStorageItemAsync(RemoveDOMStorageItemParams removeDOMStorageItemParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeDOMStorageItemParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SetDOMStorageItemResult> SetDOMStorageItemAsync(SetDOMStorageItemParams setDOMStorageItemParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDOMStorageItemParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "domStorageItemAdded": RaiseEvent(DomStorageItemAdded, messageBytes);
                    break;
                case "domStorageItemRemoved": RaiseEvent(DomStorageItemRemoved, messageBytes);
                    break;
                case "domStorageItemUpdated": RaiseEvent(DomStorageItemUpdated, messageBytes);
                    break;
                case "domStorageItemsCleared": RaiseEvent(DomStorageItemsCleared, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class DomStorageItemAddedParams
        {
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Key
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string NewValue
            {
                get; set;
            }

        }
        public class DomStorageItemRemovedParams
        {
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Key
            {
                get; set;
            }

        }
        public class DomStorageItemUpdatedParams
        {
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Key
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string OldValue
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string NewValue
            {
                get; set;
            }

        }
        public class DomStorageItemsClearedParams
        {
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }

        }
        public class ClearParams : IMethodParams<ClearParams, ClearResult>
        {
            public string GetMethod()
            {
                return "DOMStorage.clear";

            }
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }

        }
        public class ClearResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "DOMStorage.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "DOMStorage.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetDOMStorageItemsParams : IMethodParams<GetDOMStorageItemsParams, GetDOMStorageItemsResult>
        {
            public string GetMethod()
            {
                return "DOMStorage.getDOMStorageItems";

            }
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }

        }
        public class GetDOMStorageItemsResult
        {
            /// <summary>
            /// </summary>
            public string[][] Entries
            {
                get; set;
            }

        }
        public class RemoveDOMStorageItemParams : IMethodParams<RemoveDOMStorageItemParams, RemoveDOMStorageItemResult>
        {
            public string GetMethod()
            {
                return "DOMStorage.removeDOMStorageItem";

            }
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Key
            {
                get; set;
            }

        }
        public class RemoveDOMStorageItemResult
        {

        }
        public class SetDOMStorageItemParams : IMethodParams<SetDOMStorageItemParams, SetDOMStorageItemResult>
        {
            public string GetMethod()
            {
                return "DOMStorage.setDOMStorageItem";

            }
            /// <summary>
            /// </summary>
            public DOMStorageDomain.StorageId StorageId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Key
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        public class SetDOMStorageItemResult
        {

        }
        /// <summary>
        /// DOM Storage identifier.
        /// </summary>
        public class StorageId
        {
            /// <summary>
            /// Security origin for the storage.
            /// </summary>
            public string? SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Represents a key by which DOM Storage keys its CachedStorageAreas
            /// </summary>
            public string? StorageKey
            {
                get; set;
            }
            /// <summary>
            /// Whether the storage is local storage (not session storage).
            /// </summary>
            public bool IsLocalStorage
            {
                get; set;
            }

        }

    }
    public class DatabaseDomain : BaseDomain
    {
        public DatabaseDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Database";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<AddDatabaseParams>? AddDatabase;
        /// <summary>
        /// Disables database tracking, prevents database events from being sent to the client.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables database tracking, database events will now be delivered to the client.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<ExecuteSQLResult> ExecuteSQLAsync(ExecuteSQLParams executeSQLParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(executeSQLParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetDatabaseTableNamesResult> GetDatabaseTableNamesAsync(GetDatabaseTableNamesParams getDatabaseTableNamesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getDatabaseTableNamesParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "addDatabase": RaiseEvent(AddDatabase, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class AddDatabaseParams
        {
            /// <summary>
            /// </summary>
            public DatabaseDomain.Database Database
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Database.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Database.enable";

            }

        }
        public class EnableResult
        {

        }
        public class ExecuteSQLParams : IMethodParams<ExecuteSQLParams, ExecuteSQLResult>
        {
            public string GetMethod()
            {
                return "Database.executeSQL";

            }
            /// <summary>
            /// </summary>
            public string DatabaseId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Query
            {
                get; set;
            }

        }
        public class ExecuteSQLResult
        {
            /// <summary>
            /// </summary>
            public string[]? ColumnNames
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public object[]? Values
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DatabaseDomain.Error? SqlError
            {
                get; set;
            }

        }
        public class GetDatabaseTableNamesParams : IMethodParams<GetDatabaseTableNamesParams, GetDatabaseTableNamesResult>
        {
            public string GetMethod()
            {
                return "Database.getDatabaseTableNames";

            }
            /// <summary>
            /// </summary>
            public string DatabaseId
            {
                get; set;
            }

        }
        public class GetDatabaseTableNamesResult
        {
            /// <summary>
            /// </summary>
            public string[] TableNames
            {
                get; set;
            }

        }
        /// <summary>
        /// Database object.
        /// </summary>
        public class Database
        {
            /// <summary>
            /// Database ID.
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// Database domain.
            /// </summary>
            public string Domain
            {
                get; set;
            }
            /// <summary>
            /// Database name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Database version.
            /// </summary>
            public string Version
            {
                get; set;
            }

        }
        /// <summary>
        /// Database error.
        /// </summary>
        public class Error
        {
            /// <summary>
            /// Error message.
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// Error code.
            /// </summary>
            public int Code
            {
                get; set;
            }

        }

    }
    public class DeviceOrientationDomain : BaseDomain
    {
        public DeviceOrientationDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "DeviceOrientation";

            }

        }
        /// <summary>
        /// Clears the overridden Device Orientation.
        /// </summary>
        public async ValueTask<ClearDeviceOrientationOverrideResult> ClearDeviceOrientationOverrideAsync(ClearDeviceOrientationOverrideParams clearDeviceOrientationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearDeviceOrientationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the Device Orientation.
        /// </summary>
        public async ValueTask<SetDeviceOrientationOverrideResult> SetDeviceOrientationOverrideAsync(SetDeviceOrientationOverrideParams setDeviceOrientationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDeviceOrientationOverrideParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class ClearDeviceOrientationOverrideParams : IMethodParams<ClearDeviceOrientationOverrideParams, ClearDeviceOrientationOverrideResult>
        {
            public string GetMethod()
            {
                return "DeviceOrientation.clearDeviceOrientationOverride";

            }

        }
        public class ClearDeviceOrientationOverrideResult
        {

        }
        public class SetDeviceOrientationOverrideParams : IMethodParams<SetDeviceOrientationOverrideParams, SetDeviceOrientationOverrideResult>
        {
            public string GetMethod()
            {
                return "DeviceOrientation.setDeviceOrientationOverride";

            }
            /// <summary>
            /// Mock alpha
            /// </summary>
            public double Alpha
            {
                get; set;
            }
            /// <summary>
            /// Mock beta
            /// </summary>
            public double Beta
            {
                get; set;
            }
            /// <summary>
            /// Mock gamma
            /// </summary>
            public double Gamma
            {
                get; set;
            }

        }
        public class SetDeviceOrientationOverrideResult
        {

        }

    }
    public class EmulationDomain : BaseDomain
    {
        public EmulationDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Emulation";

            }

        }
        /// <summary>
        /// Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
        /// </summary>
        [Experimental]
        public event EventHandler<VirtualTimeBudgetExpiredParams>? VirtualTimeBudgetExpired;
        /// <summary>
        /// Tells whether emulation is supported.
        /// </summary>
        public async ValueTask<CanEmulateResult> CanEmulateAsync(CanEmulateParams canEmulateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(canEmulateParams, cancellationToken);

        }
        /// <summary>
        /// Clears the overridden device metrics.
        /// </summary>
        public async ValueTask<ClearDeviceMetricsOverrideResult> ClearDeviceMetricsOverrideAsync(ClearDeviceMetricsOverrideParams clearDeviceMetricsOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearDeviceMetricsOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Clears the overridden Geolocation Position and Error.
        /// </summary>
        public async ValueTask<ClearGeolocationOverrideResult> ClearGeolocationOverrideAsync(ClearGeolocationOverrideParams clearGeolocationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearGeolocationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Requests that page scale factor is reset to initial values.
        /// </summary>
        [Experimental]
        public async ValueTask<ResetPageScaleFactorResult> ResetPageScaleFactorAsync(ResetPageScaleFactorParams resetPageScaleFactorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resetPageScaleFactorParams, cancellationToken);

        }
        /// <summary>
        /// Enables or disables simulating a focused and active page.
        /// </summary>
        [Experimental]
        public async ValueTask<SetFocusEmulationEnabledResult> SetFocusEmulationEnabledAsync(SetFocusEmulationEnabledParams setFocusEmulationEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setFocusEmulationEnabledParams, cancellationToken);

        }
        /// <summary>
        /// Automatically render all web contents using a dark theme.
        /// </summary>
        [Experimental]
        public async ValueTask<SetAutoDarkModeOverrideResult> SetAutoDarkModeOverrideAsync(SetAutoDarkModeOverrideParams setAutoDarkModeOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAutoDarkModeOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Enables CPU throttling to emulate slow CPUs.
        /// </summary>
        [Experimental]
        public async ValueTask<SetCPUThrottlingRateResult> SetCPUThrottlingRateAsync(SetCPUThrottlingRateParams setCPUThrottlingRateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setCPUThrottlingRateParams, cancellationToken);

        }
        /// <summary>
        /// Sets or clears an override of the default background color of the frame. This override is used
        /// if the content does not specify one.
        /// </summary>
        public async ValueTask<SetDefaultBackgroundColorOverrideResult> SetDefaultBackgroundColorOverrideAsync(SetDefaultBackgroundColorOverrideParams setDefaultBackgroundColorOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDefaultBackgroundColorOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
        /// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
        /// query results).
        /// </summary>
        public async ValueTask<SetDeviceMetricsOverrideResult> SetDeviceMetricsOverrideAsync(SetDeviceMetricsOverrideParams setDeviceMetricsOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDeviceMetricsOverrideParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetScrollbarsHiddenResult> SetScrollbarsHiddenAsync(SetScrollbarsHiddenParams setScrollbarsHiddenParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setScrollbarsHiddenParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetDocumentCookieDisabledResult> SetDocumentCookieDisabledAsync(SetDocumentCookieDisabledParams setDocumentCookieDisabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDocumentCookieDisabledParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetEmitTouchEventsForMouseResult> SetEmitTouchEventsForMouseAsync(SetEmitTouchEventsForMouseParams setEmitTouchEventsForMouseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setEmitTouchEventsForMouseParams, cancellationToken);

        }
        /// <summary>
        /// Emulates the given media type or media feature for CSS media queries.
        /// </summary>
        public async ValueTask<SetEmulatedMediaResult> SetEmulatedMediaAsync(SetEmulatedMediaParams setEmulatedMediaParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setEmulatedMediaParams, cancellationToken);

        }
        /// <summary>
        /// Emulates the given vision deficiency.
        /// </summary>
        [Experimental]
        public async ValueTask<SetEmulatedVisionDeficiencyResult> SetEmulatedVisionDeficiencyAsync(SetEmulatedVisionDeficiencyParams setEmulatedVisionDeficiencyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setEmulatedVisionDeficiencyParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
        /// unavailable.
        /// </summary>
        public async ValueTask<SetGeolocationOverrideResult> SetGeolocationOverrideAsync(SetGeolocationOverrideParams setGeolocationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setGeolocationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the Idle state.
        /// </summary>
        [Experimental]
        public async ValueTask<SetIdleOverrideResult> SetIdleOverrideAsync(SetIdleOverrideParams setIdleOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setIdleOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Clears Idle state overrides.
        /// </summary>
        [Experimental]
        public async ValueTask<ClearIdleOverrideResult> ClearIdleOverrideAsync(ClearIdleOverrideParams clearIdleOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearIdleOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Overrides value returned by the javascript navigator object.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetNavigatorOverridesResult> SetNavigatorOverridesAsync(SetNavigatorOverridesParams setNavigatorOverridesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setNavigatorOverridesParams, cancellationToken);

        }
        /// <summary>
        /// Sets a specified page scale factor.
        /// </summary>
        [Experimental]
        public async ValueTask<SetPageScaleFactorResult> SetPageScaleFactorAsync(SetPageScaleFactorParams setPageScaleFactorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPageScaleFactorParams, cancellationToken);

        }
        /// <summary>
        /// Switches script execution in the page.
        /// </summary>
        public async ValueTask<SetScriptExecutionDisabledResult> SetScriptExecutionDisabledAsync(SetScriptExecutionDisabledParams setScriptExecutionDisabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setScriptExecutionDisabledParams, cancellationToken);

        }
        /// <summary>
        /// Enables touch on platforms which do not support them.
        /// </summary>
        public async ValueTask<SetTouchEmulationEnabledResult> SetTouchEmulationEnabledAsync(SetTouchEmulationEnabledParams setTouchEmulationEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setTouchEmulationEnabledParams, cancellationToken);

        }
        /// <summary>
        /// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
        /// the current virtual time policy.  Note this supersedes any previous time budget.
        /// </summary>
        [Experimental]
        public async ValueTask<SetVirtualTimePolicyResult> SetVirtualTimePolicyAsync(SetVirtualTimePolicyParams setVirtualTimePolicyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setVirtualTimePolicyParams, cancellationToken);

        }
        /// <summary>
        /// Overrides default host system locale with the specified one.
        /// </summary>
        [Experimental]
        public async ValueTask<SetLocaleOverrideResult> SetLocaleOverrideAsync(SetLocaleOverrideParams setLocaleOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setLocaleOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Overrides default host system timezone with the specified one.
        /// </summary>
        [Experimental]
        public async ValueTask<SetTimezoneOverrideResult> SetTimezoneOverrideAsync(SetTimezoneOverrideParams setTimezoneOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setTimezoneOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Resizes the frame/viewport of the page. Note that this does not affect the frame's container
        /// (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
        /// on Android.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetVisibleSizeResult> SetVisibleSizeAsync(SetVisibleSizeParams setVisibleSizeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setVisibleSizeParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetDisabledImageTypesResult> SetDisabledImageTypesAsync(SetDisabledImageTypesParams setDisabledImageTypesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDisabledImageTypesParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetHardwareConcurrencyOverrideResult> SetHardwareConcurrencyOverrideAsync(SetHardwareConcurrencyOverrideParams setHardwareConcurrencyOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setHardwareConcurrencyOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Allows overriding user agent with the given string.
        /// </summary>
        public async ValueTask<SetUserAgentOverrideResult> SetUserAgentOverrideAsync(SetUserAgentOverrideParams setUserAgentOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setUserAgentOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Allows overriding the automation flag.
        /// </summary>
        [Experimental]
        public async ValueTask<SetAutomationOverrideResult> SetAutomationOverrideAsync(SetAutomationOverrideParams setAutomationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAutomationOverrideParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "virtualTimeBudgetExpired": RaiseEvent(VirtualTimeBudgetExpired, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class VirtualTimeBudgetExpiredParams
        {

        }
        public class CanEmulateParams : IMethodParams<CanEmulateParams, CanEmulateResult>
        {
            public string GetMethod()
            {
                return "Emulation.canEmulate";

            }

        }
        public class CanEmulateResult
        {
            /// <summary>
            /// True if emulation is supported.
            /// </summary>
            public bool Result
            {
                get; set;
            }

        }
        public class ClearDeviceMetricsOverrideParams : IMethodParams<ClearDeviceMetricsOverrideParams, ClearDeviceMetricsOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.clearDeviceMetricsOverride";

            }

        }
        public class ClearDeviceMetricsOverrideResult
        {

        }
        public class ClearGeolocationOverrideParams : IMethodParams<ClearGeolocationOverrideParams, ClearGeolocationOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.clearGeolocationOverride";

            }

        }
        public class ClearGeolocationOverrideResult
        {

        }
        public class ResetPageScaleFactorParams : IMethodParams<ResetPageScaleFactorParams, ResetPageScaleFactorResult>
        {
            public string GetMethod()
            {
                return "Emulation.resetPageScaleFactor";

            }

        }
        public class ResetPageScaleFactorResult
        {

        }
        public class SetFocusEmulationEnabledParams : IMethodParams<SetFocusEmulationEnabledParams, SetFocusEmulationEnabledResult>
        {
            public string GetMethod()
            {
                return "Emulation.setFocusEmulationEnabled";

            }
            /// <summary>
            /// Whether to enable to disable focus emulation.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetFocusEmulationEnabledResult
        {

        }
        public class SetAutoDarkModeOverrideParams : IMethodParams<SetAutoDarkModeOverrideParams, SetAutoDarkModeOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setAutoDarkModeOverride";

            }
            /// <summary>
            /// Whether to enable or disable automatic dark mode.
            /// If not specified, any existing override will be cleared.
            /// </summary>
            public bool? Enabled
            {
                get; set;
            }

        }
        public class SetAutoDarkModeOverrideResult
        {

        }
        public class SetCPUThrottlingRateParams : IMethodParams<SetCPUThrottlingRateParams, SetCPUThrottlingRateResult>
        {
            public string GetMethod()
            {
                return "Emulation.setCPUThrottlingRate";

            }
            /// <summary>
            /// Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
            /// </summary>
            public double Rate
            {
                get; set;
            }

        }
        public class SetCPUThrottlingRateResult
        {

        }
        public class SetDefaultBackgroundColorOverrideParams : IMethodParams<SetDefaultBackgroundColorOverrideParams, SetDefaultBackgroundColorOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setDefaultBackgroundColorOverride";

            }
            /// <summary>
            /// RGBA of the default background color. If not specified, any existing override will be
            /// cleared.
            /// </summary>
            public DOMDomain.RGBA? Color
            {
                get; set;
            }

        }
        public class SetDefaultBackgroundColorOverrideResult
        {

        }
        public class SetDeviceMetricsOverrideParams : IMethodParams<SetDeviceMetricsOverrideParams, SetDeviceMetricsOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setDeviceMetricsOverride";

            }
            /// <summary>
            /// Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
            /// </summary>
            public int Width
            {
                get; set;
            }
            /// <summary>
            /// Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
            /// </summary>
            public int Height
            {
                get; set;
            }
            /// <summary>
            /// Overriding device scale factor value. 0 disables the override.
            /// </summary>
            public double DeviceScaleFactor
            {
                get; set;
            }
            /// <summary>
            /// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
            /// autosizing and more.
            /// </summary>
            public bool Mobile
            {
                get; set;
            }
            /// <summary>
            /// Scale to apply to resulting view image.
            /// </summary>
            [Experimental]
            public double? Scale
            {
                get; set;
            }
            /// <summary>
            /// Overriding screen width value in pixels (minimum 0, maximum 10000000).
            /// </summary>
            [Experimental]
            public int? ScreenWidth
            {
                get; set;
            }
            /// <summary>
            /// Overriding screen height value in pixels (minimum 0, maximum 10000000).
            /// </summary>
            [Experimental]
            public int? ScreenHeight
            {
                get; set;
            }
            /// <summary>
            /// Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
            /// </summary>
            [Experimental]
            public int? PositionX
            {
                get; set;
            }
            /// <summary>
            /// Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
            /// </summary>
            [Experimental]
            public int? PositionY
            {
                get; set;
            }
            /// <summary>
            /// Do not set visible view size, rely upon explicit setVisibleSize call.
            /// </summary>
            [Experimental]
            public bool? DontSetVisibleSize
            {
                get; set;
            }
            /// <summary>
            /// Screen orientation override.
            /// </summary>
            public EmulationDomain.ScreenOrientation? ScreenOrientation
            {
                get; set;
            }
            /// <summary>
            /// If set, the visible area of the page will be overridden to this viewport. This viewport
            /// change is not observed by the page, e.g. viewport-relative elements do not change positions.
            /// </summary>
            [Experimental]
            public PageDomain.Viewport? Viewport
            {
                get; set;
            }
            /// <summary>
            /// If set, the display feature of a multi-segment screen. If not set, multi-segment support
            /// is turned-off.
            /// </summary>
            [Experimental]
            public EmulationDomain.DisplayFeature? DisplayFeature
            {
                get; set;
            }

        }
        public class SetDeviceMetricsOverrideResult
        {

        }
        public class SetScrollbarsHiddenParams : IMethodParams<SetScrollbarsHiddenParams, SetScrollbarsHiddenResult>
        {
            public string GetMethod()
            {
                return "Emulation.setScrollbarsHidden";

            }
            /// <summary>
            /// Whether scrollbars should be always hidden.
            /// </summary>
            public bool Hidden
            {
                get; set;
            }

        }
        public class SetScrollbarsHiddenResult
        {

        }
        public class SetDocumentCookieDisabledParams : IMethodParams<SetDocumentCookieDisabledParams, SetDocumentCookieDisabledResult>
        {
            public string GetMethod()
            {
                return "Emulation.setDocumentCookieDisabled";

            }
            /// <summary>
            /// Whether document.coookie API should be disabled.
            /// </summary>
            public bool Disabled
            {
                get; set;
            }

        }
        public class SetDocumentCookieDisabledResult
        {

        }
        public class SetEmitTouchEventsForMouseParams : IMethodParams<SetEmitTouchEventsForMouseParams, SetEmitTouchEventsForMouseResult>
        {
            public string GetMethod()
            {
                return "Emulation.setEmitTouchEventsForMouse";

            }
            /// <summary>
            /// Whether touch emulation based on mouse input should be enabled.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }
            /// <summary>
            /// Touch/gesture events configuration. Default: current platform.
            /// </summary>
            /// <value>
            /// mobile,desktop
            /// </value>
            public string? Configuration
            {
                get; set;
            }

        }
        public class SetEmitTouchEventsForMouseResult
        {

        }
        public class SetEmulatedMediaParams : IMethodParams<SetEmulatedMediaParams, SetEmulatedMediaResult>
        {
            public string GetMethod()
            {
                return "Emulation.setEmulatedMedia";

            }
            /// <summary>
            /// Media type to emulate. Empty string disables the override.
            /// </summary>
            public string? Media
            {
                get; set;
            }
            /// <summary>
            /// Media features to emulate.
            /// </summary>
            public EmulationDomain.MediaFeature[]? Features
            {
                get; set;
            }

        }
        public class SetEmulatedMediaResult
        {

        }
        public class SetEmulatedVisionDeficiencyParams : IMethodParams<SetEmulatedVisionDeficiencyParams, SetEmulatedVisionDeficiencyResult>
        {
            public string GetMethod()
            {
                return "Emulation.setEmulatedVisionDeficiency";

            }
            /// <summary>
            /// Vision deficiency to emulate.
            /// </summary>
            /// <value>
            /// none,achromatopsia,blurredVision,deuteranopia,protanopia,tritanopia
            /// </value>
            public string Type
            {
                get; set;
            }

        }
        public class SetEmulatedVisionDeficiencyResult
        {

        }
        public class SetGeolocationOverrideParams : IMethodParams<SetGeolocationOverrideParams, SetGeolocationOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setGeolocationOverride";

            }
            /// <summary>
            /// Mock latitude
            /// </summary>
            public double? Latitude
            {
                get; set;
            }
            /// <summary>
            /// Mock longitude
            /// </summary>
            public double? Longitude
            {
                get; set;
            }
            /// <summary>
            /// Mock accuracy
            /// </summary>
            public double? Accuracy
            {
                get; set;
            }

        }
        public class SetGeolocationOverrideResult
        {

        }
        public class SetIdleOverrideParams : IMethodParams<SetIdleOverrideParams, SetIdleOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setIdleOverride";

            }
            /// <summary>
            /// Mock isUserActive
            /// </summary>
            public bool IsUserActive
            {
                get; set;
            }
            /// <summary>
            /// Mock isScreenUnlocked
            /// </summary>
            public bool IsScreenUnlocked
            {
                get; set;
            }

        }
        public class SetIdleOverrideResult
        {

        }
        public class ClearIdleOverrideParams : IMethodParams<ClearIdleOverrideParams, ClearIdleOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.clearIdleOverride";

            }

        }
        public class ClearIdleOverrideResult
        {

        }
        public class SetNavigatorOverridesParams : IMethodParams<SetNavigatorOverridesParams, SetNavigatorOverridesResult>
        {
            public string GetMethod()
            {
                return "Emulation.setNavigatorOverrides";

            }
            /// <summary>
            /// The platform navigator.platform should return.
            /// </summary>
            public string Platform
            {
                get; set;
            }

        }
        public class SetNavigatorOverridesResult
        {

        }
        public class SetPageScaleFactorParams : IMethodParams<SetPageScaleFactorParams, SetPageScaleFactorResult>
        {
            public string GetMethod()
            {
                return "Emulation.setPageScaleFactor";

            }
            /// <summary>
            /// Page scale factor.
            /// </summary>
            public double PageScaleFactor
            {
                get; set;
            }

        }
        public class SetPageScaleFactorResult
        {

        }
        public class SetScriptExecutionDisabledParams : IMethodParams<SetScriptExecutionDisabledParams, SetScriptExecutionDisabledResult>
        {
            public string GetMethod()
            {
                return "Emulation.setScriptExecutionDisabled";

            }
            /// <summary>
            /// Whether script execution should be disabled in the page.
            /// </summary>
            public bool Value
            {
                get; set;
            }

        }
        public class SetScriptExecutionDisabledResult
        {

        }
        public class SetTouchEmulationEnabledParams : IMethodParams<SetTouchEmulationEnabledParams, SetTouchEmulationEnabledResult>
        {
            public string GetMethod()
            {
                return "Emulation.setTouchEmulationEnabled";

            }
            /// <summary>
            /// Whether the touch event emulation should be enabled.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }
            /// <summary>
            /// Maximum touch points supported. Defaults to one.
            /// </summary>
            public int? MaxTouchPoints
            {
                get; set;
            }

        }
        public class SetTouchEmulationEnabledResult
        {

        }
        public class SetVirtualTimePolicyParams : IMethodParams<SetVirtualTimePolicyParams, SetVirtualTimePolicyResult>
        {
            public string GetMethod()
            {
                return "Emulation.setVirtualTimePolicy";

            }
            /// <summary>
            /// </summary>
            public EmulationDomain.VirtualTimePolicy Policy
            {
                get; set;
            }
            /// <summary>
            /// If set, after this many virtual milliseconds have elapsed virtual time will be paused and a
            /// virtualTimeBudgetExpired event is sent.
            /// </summary>
            public double? Budget
            {
                get; set;
            }
            /// <summary>
            /// If set this specifies the maximum number of tasks that can be run before virtual is forced
            /// forwards to prevent deadlock.
            /// </summary>
            public int? MaxVirtualTimeTaskStarvationCount
            {
                get; set;
            }
            /// <summary>
            /// If set, base::Time::Now will be overridden to initially return this value.
            /// </summary>
            public double? InitialVirtualTime
            {
                get; set;
            }

        }
        public class SetVirtualTimePolicyResult
        {
            /// <summary>
            /// Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
            /// </summary>
            public double VirtualTimeTicksBase
            {
                get; set;
            }

        }
        public class SetLocaleOverrideParams : IMethodParams<SetLocaleOverrideParams, SetLocaleOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setLocaleOverride";

            }
            /// <summary>
            /// ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override and
            /// restores default host system locale.
            /// </summary>
            public string? Locale
            {
                get; set;
            }

        }
        public class SetLocaleOverrideResult
        {

        }
        public class SetTimezoneOverrideParams : IMethodParams<SetTimezoneOverrideParams, SetTimezoneOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setTimezoneOverride";

            }
            /// <summary>
            /// The timezone identifier. If empty, disables the override and
            /// restores default host system timezone.
            /// </summary>
            public string TimezoneId
            {
                get; set;
            }

        }
        public class SetTimezoneOverrideResult
        {

        }
        public class SetVisibleSizeParams : IMethodParams<SetVisibleSizeParams, SetVisibleSizeResult>
        {
            public string GetMethod()
            {
                return "Emulation.setVisibleSize";

            }
            /// <summary>
            /// Frame width (DIP).
            /// </summary>
            public int Width
            {
                get; set;
            }
            /// <summary>
            /// Frame height (DIP).
            /// </summary>
            public int Height
            {
                get; set;
            }

        }
        public class SetVisibleSizeResult
        {

        }
        public class SetDisabledImageTypesParams : IMethodParams<SetDisabledImageTypesParams, SetDisabledImageTypesResult>
        {
            public string GetMethod()
            {
                return "Emulation.setDisabledImageTypes";

            }
            /// <summary>
            /// Image types to disable.
            /// </summary>
            public EmulationDomain.DisabledImageType[] ImageTypes
            {
                get; set;
            }

        }
        public class SetDisabledImageTypesResult
        {

        }
        public class SetHardwareConcurrencyOverrideParams : IMethodParams<SetHardwareConcurrencyOverrideParams, SetHardwareConcurrencyOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setHardwareConcurrencyOverride";

            }
            /// <summary>
            /// Hardware concurrency to report
            /// </summary>
            public int HardwareConcurrency
            {
                get; set;
            }

        }
        public class SetHardwareConcurrencyOverrideResult
        {

        }
        public class SetUserAgentOverrideParams : IMethodParams<SetUserAgentOverrideParams, SetUserAgentOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setUserAgentOverride";

            }
            /// <summary>
            /// User agent to use.
            /// </summary>
            public string UserAgent
            {
                get; set;
            }
            /// <summary>
            /// Browser langugage to emulate.
            /// </summary>
            public string? AcceptLanguage
            {
                get; set;
            }
            /// <summary>
            /// The platform navigator.platform should return.
            /// </summary>
            public string? Platform
            {
                get; set;
            }
            /// <summary>
            /// To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
            /// </summary>
            [Experimental]
            public EmulationDomain.UserAgentMetadata? UserAgentMetadata
            {
                get; set;
            }

        }
        public class SetUserAgentOverrideResult
        {

        }
        public class SetAutomationOverrideParams : IMethodParams<SetAutomationOverrideParams, SetAutomationOverrideResult>
        {
            public string GetMethod()
            {
                return "Emulation.setAutomationOverride";

            }
            /// <summary>
            /// Whether the override should be enabled.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetAutomationOverrideResult
        {

        }
        /// <summary>
        /// Screen orientation.
        /// </summary>
        public class ScreenOrientation
        {
            /// <summary>
            /// Orientation type.
            /// </summary>
            /// <value>
            /// portraitPrimary,portraitSecondary,landscapePrimary,landscapeSecondary
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Orientation angle.
            /// </summary>
            public int Angle
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class DisplayFeature
        {
            /// <summary>
            /// Orientation of a display feature in relation to screen
            /// </summary>
            /// <value>
            /// vertical,horizontal
            /// </value>
            public string Orientation
            {
                get; set;
            }
            /// <summary>
            /// The offset from the screen origin in either the x (for vertical
            /// orientation) or y (for horizontal orientation) direction.
            /// </summary>
            public int Offset
            {
                get; set;
            }
            /// <summary>
            /// A display feature may mask content such that it is not physically
            /// displayed - this length along with the offset describes this area.
            /// A display feature that only splits content will have a 0 mask_length.
            /// </summary>
            public int MaskLength
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class MediaFeature
        {
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
        /// allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
        /// pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
        /// resource fetches.
        /// </summary>
        [Experimental]
        public enum VirtualTimePolicy
        {
            [EnumValue("advance")]
            Advance = 1,
            [EnumValue("pause")]
            Pause = 2,
            [EnumValue("pauseIfNetworkFetchesPending")]
            PauseIfNetworkFetchesPending = 3,

        }
        /// <summary>
        /// Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
        /// </summary>
        [Experimental]
        public class UserAgentBrandVersion
        {
            /// <summary>
            /// </summary>
            public string Brand
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Version
            {
                get; set;
            }

        }
        /// <summary>
        /// Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
        /// Missing optional values will be filled in by the target with what it would normally use.
        /// </summary>
        [Experimental]
        public class UserAgentMetadata
        {
            /// <summary>
            /// </summary>
            public EmulationDomain.UserAgentBrandVersion[]? Brands
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public EmulationDomain.UserAgentBrandVersion[]? FullVersionList
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            [Obsolete]
            public string? FullVersion
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Platform
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string PlatformVersion
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Architecture
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Model
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool Mobile
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? Bitness
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool? Wow64
            {
                get; set;
            }

        }
        /// <summary>
        /// Enum of image types that can be disabled.
        /// </summary>
        [Experimental]
        public enum DisabledImageType
        {
            [EnumValue("avif")]
            Avif = 1,
            [EnumValue("jxl")]
            Jxl = 2,
            [EnumValue("webp")]
            Webp = 3,

        }

    }
    public class HeadlessExperimentalDomain : BaseDomain
    {
        public HeadlessExperimentalDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "HeadlessExperimental";

            }

        }
        /// <summary>
        /// Issued when the target starts or stops needing BeginFrames.
        /// Deprecated. Issue beginFrame unconditionally instead and use result from
        /// beginFrame to detect whether the frames were suppressed.
        /// </summary>
        [Obsolete]
        public event EventHandler<NeedsBeginFramesChangedParams>? NeedsBeginFramesChanged;
        /// <summary>
        /// Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
        /// screenshot from the resulting frame. Requires that the target was created with enabled
        /// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
        /// https://goo.gle/chrome-headless-rendering for more background.
        /// </summary>
        public async ValueTask<BeginFrameResult> BeginFrameAsync(BeginFrameParams beginFrameParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(beginFrameParams, cancellationToken);

        }
        /// <summary>
        /// Disables headless events for the target.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables headless events for the target.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "needsBeginFramesChanged": RaiseEvent(NeedsBeginFramesChanged, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class NeedsBeginFramesChangedParams
        {
            /// <summary>
            /// True if BeginFrames are needed, false otherwise.
            /// </summary>
            public bool NeedsBeginFrames
            {
                get; set;
            }

        }
        public class BeginFrameParams : IMethodParams<BeginFrameParams, BeginFrameResult>
        {
            public string GetMethod()
            {
                return "HeadlessExperimental.beginFrame";

            }
            /// <summary>
            /// Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
            /// the current time will be used.
            /// </summary>
            public double? FrameTimeTicks
            {
                get; set;
            }
            /// <summary>
            /// The interval between BeginFrames that is reported to the compositor, in milliseconds.
            /// Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
            /// </summary>
            public double? Interval
            {
                get; set;
            }
            /// <summary>
            /// Whether updates should not be committed and drawn onto the display. False by default. If
            /// true, only side effects of the BeginFrame will be run, such as layout and animations, but
            /// any visual updates may not be visible on the display or in screenshots.
            /// </summary>
            public bool? NoDisplayUpdates
            {
                get; set;
            }
            /// <summary>
            /// If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
            /// no screenshot will be captured. Note that capturing a screenshot can fail, for example,
            /// during renderer initialization. In such a case, no screenshot data will be returned.
            /// </summary>
            public HeadlessExperimentalDomain.ScreenshotParams? Screenshot
            {
                get; set;
            }

        }
        public class BeginFrameResult
        {
            /// <summary>
            /// Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
            /// display. Reported for diagnostic uses, may be removed in the future.
            /// </summary>
            public bool HasDamage
            {
                get; set;
            }
            /// <summary>
            /// Base64-encoded image data of the screenshot, if one was requested and successfully taken. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? ScreenshotData
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "HeadlessExperimental.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "HeadlessExperimental.enable";

            }

        }
        public class EnableResult
        {

        }
        /// <summary>
        /// Encoding options for a screenshot.
        /// </summary>
        public class ScreenshotParams
        {
            /// <summary>
            /// Image compression format (defaults to png).
            /// </summary>
            /// <value>
            /// jpeg,png
            /// </value>
            public string? Format
            {
                get; set;
            }
            /// <summary>
            /// Compression quality from range [0..100] (jpeg only).
            /// </summary>
            public int? Quality
            {
                get; set;
            }

        }

    }
    public class IODomain : BaseDomain
    {
        public IODomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "IO";

            }

        }
        /// <summary>
        /// Close the stream, discard any temporary backing storage.
        /// </summary>
        public async ValueTask<CloseResult> CloseAsync(CloseParams closeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(closeParams, cancellationToken);

        }
        /// <summary>
        /// Read a chunk of the stream
        /// </summary>
        public async ValueTask<ReadResult> ReadAsync(ReadParams readParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(readParams, cancellationToken);

        }
        /// <summary>
        /// Return UUID of Blob object specified by a remote object id.
        /// </summary>
        public async ValueTask<ResolveBlobResult> ResolveBlobAsync(ResolveBlobParams resolveBlobParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resolveBlobParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class CloseParams : IMethodParams<CloseParams, CloseResult>
        {
            public string GetMethod()
            {
                return "IO.close";

            }
            /// <summary>
            /// Handle of the stream to close.
            /// </summary>
            public string Handle
            {
                get; set;
            }

        }
        public class CloseResult
        {

        }
        public class ReadParams : IMethodParams<ReadParams, ReadResult>
        {
            public string GetMethod()
            {
                return "IO.read";

            }
            /// <summary>
            /// Handle of the stream to read.
            /// </summary>
            public string Handle
            {
                get; set;
            }
            /// <summary>
            /// Seek to the specified offset before reading (if not specificed, proceed with offset
            /// following the last read). Some types of streams may only support sequential reads.
            /// </summary>
            public int? Offset
            {
                get; set;
            }
            /// <summary>
            /// Maximum number of bytes to read (left upon the agent discretion if not specified).
            /// </summary>
            public int? Size
            {
                get; set;
            }

        }
        public class ReadResult
        {
            /// <summary>
            /// Set if the data is base64-encoded
            /// </summary>
            public bool? Base64Encoded
            {
                get; set;
            }
            /// <summary>
            /// Data that were read.
            /// </summary>
            public string Data
            {
                get; set;
            }
            /// <summary>
            /// Set if the end-of-file condition occurred while reading.
            /// </summary>
            public bool Eof
            {
                get; set;
            }

        }
        public class ResolveBlobParams : IMethodParams<ResolveBlobParams, ResolveBlobResult>
        {
            public string GetMethod()
            {
                return "IO.resolveBlob";

            }
            /// <summary>
            /// Object id of a Blob object wrapper.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }

        }
        public class ResolveBlobResult
        {
            /// <summary>
            /// UUID of the specified Blob.
            /// </summary>
            public string Uuid
            {
                get; set;
            }

        }

    }
    public class IndexedDBDomain : BaseDomain
    {
        public IndexedDBDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "IndexedDB";

            }

        }
        /// <summary>
        /// Clears all entries from an object store.
        /// </summary>
        public async ValueTask<ClearObjectStoreResult> ClearObjectStoreAsync(ClearObjectStoreParams clearObjectStoreParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearObjectStoreParams, cancellationToken);

        }
        /// <summary>
        /// Deletes a database.
        /// </summary>
        public async ValueTask<DeleteDatabaseResult> DeleteDatabaseAsync(DeleteDatabaseParams deleteDatabaseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deleteDatabaseParams, cancellationToken);

        }
        /// <summary>
        /// Delete a range of entries from an object store
        /// </summary>
        public async ValueTask<DeleteObjectStoreEntriesResult> DeleteObjectStoreEntriesAsync(DeleteObjectStoreEntriesParams deleteObjectStoreEntriesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deleteObjectStoreEntriesParams, cancellationToken);

        }
        /// <summary>
        /// Disables events from backend.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables events from backend.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Requests data from object store or index.
        /// </summary>
        public async ValueTask<RequestDataResult> RequestDataAsync(RequestDataParams requestDataParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestDataParams, cancellationToken);

        }
        /// <summary>
        /// Gets metadata of an object store
        /// </summary>
        public async ValueTask<GetMetadataResult> GetMetadataAsync(GetMetadataParams getMetadataParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getMetadataParams, cancellationToken);

        }
        /// <summary>
        /// Requests database with given name in given frame.
        /// </summary>
        public async ValueTask<RequestDatabaseResult> RequestDatabaseAsync(RequestDatabaseParams requestDatabaseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestDatabaseParams, cancellationToken);

        }
        /// <summary>
        /// Requests database names for given security origin.
        /// </summary>
        public async ValueTask<RequestDatabaseNamesResult> RequestDatabaseNamesAsync(RequestDatabaseNamesParams requestDatabaseNamesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestDatabaseNamesParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class ClearObjectStoreParams : IMethodParams<ClearObjectStoreParams, ClearObjectStoreResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.clearObjectStore";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Database name.
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }
            /// <summary>
            /// Object store name.
            /// </summary>
            public string ObjectStoreName
            {
                get; set;
            }

        }
        public class ClearObjectStoreResult
        {

        }
        public class DeleteDatabaseParams : IMethodParams<DeleteDatabaseParams, DeleteDatabaseResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.deleteDatabase";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Database name.
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }

        }
        public class DeleteDatabaseResult
        {

        }
        public class DeleteObjectStoreEntriesParams : IMethodParams<DeleteObjectStoreEntriesParams, DeleteObjectStoreEntriesResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.deleteObjectStoreEntries";

            }
            /// <summary>
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ObjectStoreName
            {
                get; set;
            }
            /// <summary>
            /// Range of entry keys to delete
            /// </summary>
            public IndexedDBDomain.KeyRange KeyRange
            {
                get; set;
            }

        }
        public class DeleteObjectStoreEntriesResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.enable";

            }

        }
        public class EnableResult
        {

        }
        public class RequestDataParams : IMethodParams<RequestDataParams, RequestDataResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.requestData";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Database name.
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }
            /// <summary>
            /// Object store name.
            /// </summary>
            public string ObjectStoreName
            {
                get; set;
            }
            /// <summary>
            /// Index name, empty string for object store data requests.
            /// </summary>
            public string IndexName
            {
                get; set;
            }
            /// <summary>
            /// Number of records to skip.
            /// </summary>
            public int SkipCount
            {
                get; set;
            }
            /// <summary>
            /// Number of records to fetch.
            /// </summary>
            public int PageSize
            {
                get; set;
            }
            /// <summary>
            /// Key range.
            /// </summary>
            public IndexedDBDomain.KeyRange? KeyRange
            {
                get; set;
            }

        }
        public class RequestDataResult
        {
            /// <summary>
            /// Array of object store data entries.
            /// </summary>
            public IndexedDBDomain.DataEntry[] ObjectStoreDataEntries
            {
                get; set;
            }
            /// <summary>
            /// If true, there are more entries to fetch in the given range.
            /// </summary>
            public bool HasMore
            {
                get; set;
            }

        }
        public class GetMetadataParams : IMethodParams<GetMetadataParams, GetMetadataResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.getMetadata";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Database name.
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }
            /// <summary>
            /// Object store name.
            /// </summary>
            public string ObjectStoreName
            {
                get; set;
            }

        }
        public class GetMetadataResult
        {
            /// <summary>
            /// the entries count
            /// </summary>
            public double EntriesCount
            {
                get; set;
            }
            /// <summary>
            /// the current value of key generator, to become the next inserted
            /// key into the object store. Valid if objectStore.autoIncrement
            /// is true.
            /// </summary>
            public double KeyGeneratorValue
            {
                get; set;
            }

        }
        public class RequestDatabaseParams : IMethodParams<RequestDatabaseParams, RequestDatabaseResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.requestDatabase";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Database name.
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }

        }
        public class RequestDatabaseResult
        {
            /// <summary>
            /// Database with an array of object stores.
            /// </summary>
            public IndexedDBDomain.DatabaseWithObjectStores DatabaseWithObjectStores
            {
                get; set;
            }

        }
        public class RequestDatabaseNamesParams : IMethodParams<RequestDatabaseNamesParams, RequestDatabaseNamesResult>
        {
            public string GetMethod()
            {
                return "IndexedDB.requestDatabaseNames";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }

        }
        public class RequestDatabaseNamesResult
        {
            /// <summary>
            /// Database names for origin.
            /// </summary>
            public string[] DatabaseNames
            {
                get; set;
            }

        }
        /// <summary>
        /// Database with an array of object stores.
        /// </summary>
        public class DatabaseWithObjectStores
        {
            /// <summary>
            /// Database name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Database version (type is not 'integer', as the standard
            /// requires the version number to be 'unsigned long long')
            /// </summary>
            public double Version
            {
                get; set;
            }
            /// <summary>
            /// Object stores in this database.
            /// </summary>
            public IndexedDBDomain.ObjectStore[] ObjectStores
            {
                get; set;
            }

        }
        /// <summary>
        /// Object store.
        /// </summary>
        public class ObjectStore
        {
            /// <summary>
            /// Object store name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Object store key path.
            /// </summary>
            public IndexedDBDomain.KeyPath KeyPath
            {
                get; set;
            }
            /// <summary>
            /// If true, object store has auto increment flag set.
            /// </summary>
            public bool AutoIncrement
            {
                get; set;
            }
            /// <summary>
            /// Indexes in this object store.
            /// </summary>
            public IndexedDBDomain.ObjectStoreIndex[] Indexes
            {
                get; set;
            }

        }
        /// <summary>
        /// Object store index.
        /// </summary>
        public class ObjectStoreIndex
        {
            /// <summary>
            /// Index name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Index key path.
            /// </summary>
            public IndexedDBDomain.KeyPath KeyPath
            {
                get; set;
            }
            /// <summary>
            /// If true, index is unique.
            /// </summary>
            public bool Unique
            {
                get; set;
            }
            /// <summary>
            /// If true, index allows multiple entries for a key.
            /// </summary>
            public bool MultiEntry
            {
                get; set;
            }

        }
        /// <summary>
        /// Key.
        /// </summary>
        public class Key
        {
            /// <summary>
            /// Key type.
            /// </summary>
            /// <value>
            /// number,string,date,array
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Number value.
            /// </summary>
            public double? Number
            {
                get; set;
            }
            /// <summary>
            /// String value.
            /// </summary>
            public string? String
            {
                get; set;
            }
            /// <summary>
            /// Date value.
            /// </summary>
            public double? Date
            {
                get; set;
            }
            /// <summary>
            /// Array value.
            /// </summary>
            public IndexedDBDomain.Key[]? Array
            {
                get; set;
            }

        }
        /// <summary>
        /// Key range.
        /// </summary>
        public class KeyRange
        {
            /// <summary>
            /// Lower bound.
            /// </summary>
            public IndexedDBDomain.Key? Lower
            {
                get; set;
            }
            /// <summary>
            /// Upper bound.
            /// </summary>
            public IndexedDBDomain.Key? Upper
            {
                get; set;
            }
            /// <summary>
            /// If true lower bound is open.
            /// </summary>
            public bool LowerOpen
            {
                get; set;
            }
            /// <summary>
            /// If true upper bound is open.
            /// </summary>
            public bool UpperOpen
            {
                get; set;
            }

        }
        /// <summary>
        /// Data entry.
        /// </summary>
        public class DataEntry
        {
            /// <summary>
            /// Key object.
            /// </summary>
            public RuntimeDomain.RemoteObject Key
            {
                get; set;
            }
            /// <summary>
            /// Primary key object.
            /// </summary>
            public RuntimeDomain.RemoteObject PrimaryKey
            {
                get; set;
            }
            /// <summary>
            /// Value object.
            /// </summary>
            public RuntimeDomain.RemoteObject Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Key path.
        /// </summary>
        public class KeyPath
        {
            /// <summary>
            /// Key path type.
            /// </summary>
            /// <value>
            /// null,string,array
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// String value.
            /// </summary>
            public string? String
            {
                get; set;
            }
            /// <summary>
            /// Array value.
            /// </summary>
            public string[]? Array
            {
                get; set;
            }

        }

    }
    public class InputDomain : BaseDomain
    {
        public InputDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Input";

            }

        }
        /// <summary>
        /// Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
        /// restore normal drag and drop behavior.
        /// </summary>
        [Experimental]
        public event EventHandler<DragInterceptedParams>? DragIntercepted;
        /// <summary>
        /// Dispatches a drag event into the page.
        /// </summary>
        [Experimental]
        public async ValueTask<DispatchDragEventResult> DispatchDragEventAsync(DispatchDragEventParams dispatchDragEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(dispatchDragEventParams, cancellationToken);

        }
        /// <summary>
        /// Dispatches a key event to the page.
        /// </summary>
        public async ValueTask<DispatchKeyEventResult> DispatchKeyEventAsync(DispatchKeyEventParams dispatchKeyEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(dispatchKeyEventParams, cancellationToken);

        }
        /// <summary>
        /// This method emulates inserting text that doesn't come from a key press,
        /// for example an emoji keyboard or an IME.
        /// </summary>
        [Experimental]
        public async ValueTask<InsertTextResult> InsertTextAsync(InsertTextParams insertTextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(insertTextParams, cancellationToken);

        }
        /// <summary>
        /// This method sets the current candidate text for ime.
        /// Use imeCommitComposition to commit the final text.
        /// Use imeSetComposition with empty string as text to cancel composition.
        /// </summary>
        [Experimental]
        public async ValueTask<ImeSetCompositionResult> ImeSetCompositionAsync(ImeSetCompositionParams imeSetCompositionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(imeSetCompositionParams, cancellationToken);

        }
        /// <summary>
        /// Dispatches a mouse event to the page.
        /// </summary>
        public async ValueTask<DispatchMouseEventResult> DispatchMouseEventAsync(DispatchMouseEventParams dispatchMouseEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(dispatchMouseEventParams, cancellationToken);

        }
        /// <summary>
        /// Dispatches a touch event to the page.
        /// </summary>
        public async ValueTask<DispatchTouchEventResult> DispatchTouchEventAsync(DispatchTouchEventParams dispatchTouchEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(dispatchTouchEventParams, cancellationToken);

        }
        /// <summary>
        /// Emulates touch event from the mouse event parameters.
        /// </summary>
        [Experimental]
        public async ValueTask<EmulateTouchFromMouseEventResult> EmulateTouchFromMouseEventAsync(EmulateTouchFromMouseEventParams emulateTouchFromMouseEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(emulateTouchFromMouseEventParams, cancellationToken);

        }
        /// <summary>
        /// Ignores input events (useful while auditing page).
        /// </summary>
        public async ValueTask<SetIgnoreInputEventsResult> SetIgnoreInputEventsAsync(SetIgnoreInputEventsParams setIgnoreInputEventsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setIgnoreInputEventsParams, cancellationToken);

        }
        /// <summary>
        /// Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
        /// Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
        /// </summary>
        [Experimental]
        public async ValueTask<SetInterceptDragsResult> SetInterceptDragsAsync(SetInterceptDragsParams setInterceptDragsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInterceptDragsParams, cancellationToken);

        }
        /// <summary>
        /// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
        /// </summary>
        [Experimental]
        public async ValueTask<SynthesizePinchGestureResult> SynthesizePinchGestureAsync(SynthesizePinchGestureParams synthesizePinchGestureParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(synthesizePinchGestureParams, cancellationToken);

        }
        /// <summary>
        /// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
        /// </summary>
        [Experimental]
        public async ValueTask<SynthesizeScrollGestureResult> SynthesizeScrollGestureAsync(SynthesizeScrollGestureParams synthesizeScrollGestureParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(synthesizeScrollGestureParams, cancellationToken);

        }
        /// <summary>
        /// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
        /// </summary>
        [Experimental]
        public async ValueTask<SynthesizeTapGestureResult> SynthesizeTapGestureAsync(SynthesizeTapGestureParams synthesizeTapGestureParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(synthesizeTapGestureParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "dragIntercepted": RaiseEvent(DragIntercepted, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class DragInterceptedParams
        {
            /// <summary>
            /// </summary>
            public InputDomain.DragData Data
            {
                get; set;
            }

        }
        public class DispatchDragEventParams : IMethodParams<DispatchDragEventParams, DispatchDragEventResult>
        {
            public string GetMethod()
            {
                return "Input.dispatchDragEvent";

            }
            /// <summary>
            /// Type of the drag event.
            /// </summary>
            /// <value>
            /// dragEnter,dragOver,drop,dragCancel
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// X coordinate of the event relative to the main frame's viewport in CSS pixels.
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
            /// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public InputDomain.DragData Data
            {
                get; set;
            }
            /// <summary>
            /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
            /// (default: 0).
            /// </summary>
            public int? Modifiers
            {
                get; set;
            }

        }
        public class DispatchDragEventResult
        {

        }
        public class DispatchKeyEventParams : IMethodParams<DispatchKeyEventParams, DispatchKeyEventResult>
        {
            public string GetMethod()
            {
                return "Input.dispatchKeyEvent";

            }
            /// <summary>
            /// Type of the key event.
            /// </summary>
            /// <value>
            /// keyDown,keyUp,rawKeyDown,char
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
            /// (default: 0).
            /// </summary>
            public int? Modifiers
            {
                get; set;
            }
            /// <summary>
            /// Time at which the event occurred.
            /// </summary>
            public double? Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Text as generated by processing a virtual key code with a keyboard layout. Not needed for
            /// for `keyUp` and `rawKeyDown` events (default: "")
            /// </summary>
            public string? Text
            {
                get; set;
            }
            /// <summary>
            /// Text that would have been generated by the keyboard if no modifiers were pressed (except for
            /// shift). Useful for shortcut (accelerator) key handling (default: "").
            /// </summary>
            public string? UnmodifiedText
            {
                get; set;
            }
            /// <summary>
            /// Unique key identifier (e.g., 'U+0041') (default: "").
            /// </summary>
            public string? KeyIdentifier
            {
                get; set;
            }
            /// <summary>
            /// Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
            /// </summary>
            public string? Code
            {
                get; set;
            }
            /// <summary>
            /// Unique DOM defined string value describing the meaning of the key in the context of active
            /// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
            /// </summary>
            public string? Key
            {
                get; set;
            }
            /// <summary>
            /// Windows virtual key code (default: 0).
            /// </summary>
            public int? WindowsVirtualKeyCode
            {
                get; set;
            }
            /// <summary>
            /// Native virtual key code (default: 0).
            /// </summary>
            public int? NativeVirtualKeyCode
            {
                get; set;
            }
            /// <summary>
            /// Whether the event was generated from auto repeat (default: false).
            /// </summary>
            public bool? AutoRepeat
            {
                get; set;
            }
            /// <summary>
            /// Whether the event was generated from the keypad (default: false).
            /// </summary>
            public bool? IsKeypad
            {
                get; set;
            }
            /// <summary>
            /// Whether the event was a system key event (default: false).
            /// </summary>
            public bool? IsSystemKey
            {
                get; set;
            }
            /// <summary>
            /// Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
            /// 0).
            /// </summary>
            public int? Location
            {
                get; set;
            }
            /// <summary>
            /// Editing commands to send with the key event (e.g., 'selectAll') (default: []).
            /// These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
            /// See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
            /// </summary>
            [Experimental]
            public string[]? Commands
            {
                get; set;
            }

        }
        public class DispatchKeyEventResult
        {

        }
        public class InsertTextParams : IMethodParams<InsertTextParams, InsertTextResult>
        {
            public string GetMethod()
            {
                return "Input.insertText";

            }
            /// <summary>
            /// The text to insert.
            /// </summary>
            public string Text
            {
                get; set;
            }

        }
        public class InsertTextResult
        {

        }
        public class ImeSetCompositionParams : IMethodParams<ImeSetCompositionParams, ImeSetCompositionResult>
        {
            public string GetMethod()
            {
                return "Input.imeSetComposition";

            }
            /// <summary>
            /// The text to insert
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// selection start
            /// </summary>
            public int SelectionStart
            {
                get; set;
            }
            /// <summary>
            /// selection end
            /// </summary>
            public int SelectionEnd
            {
                get; set;
            }
            /// <summary>
            /// replacement start
            /// </summary>
            public int? ReplacementStart
            {
                get; set;
            }
            /// <summary>
            /// replacement end
            /// </summary>
            public int? ReplacementEnd
            {
                get; set;
            }

        }
        public class ImeSetCompositionResult
        {

        }
        public class DispatchMouseEventParams : IMethodParams<DispatchMouseEventParams, DispatchMouseEventResult>
        {
            public string GetMethod()
            {
                return "Input.dispatchMouseEvent";

            }
            /// <summary>
            /// Type of the mouse event.
            /// </summary>
            /// <value>
            /// mousePressed,mouseReleased,mouseMoved,mouseWheel
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// X coordinate of the event relative to the main frame's viewport in CSS pixels.
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
            /// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
            /// (default: 0).
            /// </summary>
            public int? Modifiers
            {
                get; set;
            }
            /// <summary>
            /// Time at which the event occurred.
            /// </summary>
            public double? Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Mouse button (default: "none").
            /// </summary>
            public InputDomain.MouseButton? Button
            {
                get; set;
            }
            /// <summary>
            /// A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
            /// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
            /// </summary>
            public int? Buttons
            {
                get; set;
            }
            /// <summary>
            /// Number of times the mouse button was clicked (default: 0).
            /// </summary>
            public int? ClickCount
            {
                get; set;
            }
            /// <summary>
            /// The normalized pressure, which has a range of [0,1] (default: 0).
            /// </summary>
            [Experimental]
            public double? Force
            {
                get; set;
            }
            /// <summary>
            /// The normalized tangential pressure, which has a range of [-1,1] (default: 0).
            /// </summary>
            [Experimental]
            public double? TangentialPressure
            {
                get; set;
            }
            /// <summary>
            /// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
            /// </summary>
            [Experimental]
            public int? TiltX
            {
                get; set;
            }
            /// <summary>
            /// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
            /// </summary>
            [Experimental]
            public int? TiltY
            {
                get; set;
            }
            /// <summary>
            /// The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
            /// </summary>
            [Experimental]
            public int? Twist
            {
                get; set;
            }
            /// <summary>
            /// X delta in CSS pixels for mouse wheel event (default: 0).
            /// </summary>
            public double? DeltaX
            {
                get; set;
            }
            /// <summary>
            /// Y delta in CSS pixels for mouse wheel event (default: 0).
            /// </summary>
            public double? DeltaY
            {
                get; set;
            }
            /// <summary>
            /// Pointer type (default: "mouse").
            /// </summary>
            /// <value>
            /// mouse,pen
            /// </value>
            public string? PointerType
            {
                get; set;
            }

        }
        public class DispatchMouseEventResult
        {

        }
        public class DispatchTouchEventParams : IMethodParams<DispatchTouchEventParams, DispatchTouchEventResult>
        {
            public string GetMethod()
            {
                return "Input.dispatchTouchEvent";

            }
            /// <summary>
            /// Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
            /// TouchStart and TouchMove must contains at least one.
            /// </summary>
            /// <value>
            /// touchStart,touchEnd,touchMove,touchCancel
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Active touch points on the touch device. One event per any changed point (compared to
            /// previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
            /// one by one.
            /// </summary>
            public InputDomain.TouchPoint[] TouchPoints
            {
                get; set;
            }
            /// <summary>
            /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
            /// (default: 0).
            /// </summary>
            public int? Modifiers
            {
                get; set;
            }
            /// <summary>
            /// Time at which the event occurred.
            /// </summary>
            public double? Timestamp
            {
                get; set;
            }

        }
        public class DispatchTouchEventResult
        {

        }
        public class EmulateTouchFromMouseEventParams : IMethodParams<EmulateTouchFromMouseEventParams, EmulateTouchFromMouseEventResult>
        {
            public string GetMethod()
            {
                return "Input.emulateTouchFromMouseEvent";

            }
            /// <summary>
            /// Type of the mouse event.
            /// </summary>
            /// <value>
            /// mousePressed,mouseReleased,mouseMoved,mouseWheel
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// X coordinate of the mouse pointer in DIP.
            /// </summary>
            public int X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the mouse pointer in DIP.
            /// </summary>
            public int Y
            {
                get; set;
            }
            /// <summary>
            /// Mouse button. Only "none", "left", "right" are supported.
            /// </summary>
            public InputDomain.MouseButton Button
            {
                get; set;
            }
            /// <summary>
            /// Time at which the event occurred (default: current time).
            /// </summary>
            public double? Timestamp
            {
                get; set;
            }
            /// <summary>
            /// X delta in DIP for mouse wheel event (default: 0).
            /// </summary>
            public double? DeltaX
            {
                get; set;
            }
            /// <summary>
            /// Y delta in DIP for mouse wheel event (default: 0).
            /// </summary>
            public double? DeltaY
            {
                get; set;
            }
            /// <summary>
            /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
            /// (default: 0).
            /// </summary>
            public int? Modifiers
            {
                get; set;
            }
            /// <summary>
            /// Number of times the mouse button was clicked (default: 0).
            /// </summary>
            public int? ClickCount
            {
                get; set;
            }

        }
        public class EmulateTouchFromMouseEventResult
        {

        }
        public class SetIgnoreInputEventsParams : IMethodParams<SetIgnoreInputEventsParams, SetIgnoreInputEventsResult>
        {
            public string GetMethod()
            {
                return "Input.setIgnoreInputEvents";

            }
            /// <summary>
            /// Ignores input events processing when set to true.
            /// </summary>
            public bool Ignore
            {
                get; set;
            }

        }
        public class SetIgnoreInputEventsResult
        {

        }
        public class SetInterceptDragsParams : IMethodParams<SetInterceptDragsParams, SetInterceptDragsResult>
        {
            public string GetMethod()
            {
                return "Input.setInterceptDrags";

            }
            /// <summary>
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetInterceptDragsResult
        {

        }
        public class SynthesizePinchGestureParams : IMethodParams<SynthesizePinchGestureParams, SynthesizePinchGestureResult>
        {
            public string GetMethod()
            {
                return "Input.synthesizePinchGesture";

            }
            /// <summary>
            /// X coordinate of the start of the gesture in CSS pixels.
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the start of the gesture in CSS pixels.
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
            /// </summary>
            public double ScaleFactor
            {
                get; set;
            }
            /// <summary>
            /// Relative pointer speed in pixels per second (default: 800).
            /// </summary>
            public int? RelativeSpeed
            {
                get; set;
            }
            /// <summary>
            /// Which type of input events to be generated (default: 'default', which queries the platform
            /// for the preferred input type).
            /// </summary>
            public InputDomain.GestureSourceType? GestureSourceType
            {
                get; set;
            }

        }
        public class SynthesizePinchGestureResult
        {

        }
        public class SynthesizeScrollGestureParams : IMethodParams<SynthesizeScrollGestureParams, SynthesizeScrollGestureResult>
        {
            public string GetMethod()
            {
                return "Input.synthesizeScrollGesture";

            }
            /// <summary>
            /// X coordinate of the start of the gesture in CSS pixels.
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the start of the gesture in CSS pixels.
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// The distance to scroll along the X axis (positive to scroll left).
            /// </summary>
            public double? XDistance
            {
                get; set;
            }
            /// <summary>
            /// The distance to scroll along the Y axis (positive to scroll up).
            /// </summary>
            public double? YDistance
            {
                get; set;
            }
            /// <summary>
            /// The number of additional pixels to scroll back along the X axis, in addition to the given
            /// distance.
            /// </summary>
            public double? XOverscroll
            {
                get; set;
            }
            /// <summary>
            /// The number of additional pixels to scroll back along the Y axis, in addition to the given
            /// distance.
            /// </summary>
            public double? YOverscroll
            {
                get; set;
            }
            /// <summary>
            /// Prevent fling (default: true).
            /// </summary>
            public bool? PreventFling
            {
                get; set;
            }
            /// <summary>
            /// Swipe speed in pixels per second (default: 800).
            /// </summary>
            public int? Speed
            {
                get; set;
            }
            /// <summary>
            /// Which type of input events to be generated (default: 'default', which queries the platform
            /// for the preferred input type).
            /// </summary>
            public InputDomain.GestureSourceType? GestureSourceType
            {
                get; set;
            }
            /// <summary>
            /// The number of times to repeat the gesture (default: 0).
            /// </summary>
            public int? RepeatCount
            {
                get; set;
            }
            /// <summary>
            /// The number of milliseconds delay between each repeat. (default: 250).
            /// </summary>
            public int? RepeatDelayMs
            {
                get; set;
            }
            /// <summary>
            /// The name of the interaction markers to generate, if not empty (default: "").
            /// </summary>
            public string? InteractionMarkerName
            {
                get; set;
            }

        }
        public class SynthesizeScrollGestureResult
        {

        }
        public class SynthesizeTapGestureParams : IMethodParams<SynthesizeTapGestureParams, SynthesizeTapGestureResult>
        {
            public string GetMethod()
            {
                return "Input.synthesizeTapGesture";

            }
            /// <summary>
            /// X coordinate of the start of the gesture in CSS pixels.
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the start of the gesture in CSS pixels.
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// Duration between touchdown and touchup events in ms (default: 50).
            /// </summary>
            public int? Duration
            {
                get; set;
            }
            /// <summary>
            /// Number of times to perform the tap (e.g. 2 for double tap, default: 1).
            /// </summary>
            public int? TapCount
            {
                get; set;
            }
            /// <summary>
            /// Which type of input events to be generated (default: 'default', which queries the platform
            /// for the preferred input type).
            /// </summary>
            public InputDomain.GestureSourceType? GestureSourceType
            {
                get; set;
            }

        }
        public class SynthesizeTapGestureResult
        {

        }
        /// <summary>
        /// </summary>
        public class TouchPoint
        {
            /// <summary>
            /// X coordinate of the event relative to the main frame's viewport in CSS pixels.
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
            /// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// X radius of the touch area (default: 1.0).
            /// </summary>
            public double? RadiusX
            {
                get; set;
            }
            /// <summary>
            /// Y radius of the touch area (default: 1.0).
            /// </summary>
            public double? RadiusY
            {
                get; set;
            }
            /// <summary>
            /// Rotation angle (default: 0.0).
            /// </summary>
            public double? RotationAngle
            {
                get; set;
            }
            /// <summary>
            /// Force (default: 1.0).
            /// </summary>
            public double? Force
            {
                get; set;
            }
            /// <summary>
            /// The normalized tangential pressure, which has a range of [-1,1] (default: 0).
            /// </summary>
            [Experimental]
            public double? TangentialPressure
            {
                get; set;
            }
            /// <summary>
            /// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
            /// </summary>
            [Experimental]
            public int? TiltX
            {
                get; set;
            }
            /// <summary>
            /// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
            /// </summary>
            [Experimental]
            public int? TiltY
            {
                get; set;
            }
            /// <summary>
            /// The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
            /// </summary>
            [Experimental]
            public int? Twist
            {
                get; set;
            }
            /// <summary>
            /// Identifier used to track touch sources between events, must be unique within an event.
            /// </summary>
            public double? Id
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum GestureSourceType
        {
            [EnumValue("default")]
            Default = 1,
            [EnumValue("touch")]
            Touch = 2,
            [EnumValue("mouse")]
            Mouse = 3,

        }
        /// <summary>
        /// </summary>
        public enum MouseButton
        {
            [EnumValue("none")]
            None = 1,
            [EnumValue("left")]
            Left = 2,
            [EnumValue("middle")]
            Middle = 3,
            [EnumValue("right")]
            Right = 4,
            [EnumValue("back")]
            Back = 5,
            [EnumValue("forward")]
            Forward = 6,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class DragDataItem
        {
            /// <summary>
            /// Mime type of the dragged data.
            /// </summary>
            public string MimeType
            {
                get; set;
            }
            /// <summary>
            /// Depending of the value of `mimeType`, it contains the dragged link,
            /// text, HTML markup or any other data.
            /// </summary>
            public string Data
            {
                get; set;
            }
            /// <summary>
            /// Title associated with a link. Only valid when `mimeType` == "text/uri-list".
            /// </summary>
            public string? Title
            {
                get; set;
            }
            /// <summary>
            /// Stores the base URL for the contained markup. Only valid when `mimeType`
            /// == "text/html".
            /// </summary>
            public string? BaseURL
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class DragData
        {
            /// <summary>
            /// </summary>
            public InputDomain.DragDataItem[] Items
            {
                get; set;
            }
            /// <summary>
            /// List of filenames that should be included when dropping
            /// </summary>
            public string[]? Files
            {
                get; set;
            }
            /// <summary>
            /// Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
            /// </summary>
            public int DragOperationsMask
            {
                get; set;
            }

        }

    }
    public class InspectorDomain : BaseDomain
    {
        public InspectorDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Inspector";

            }

        }
        /// <summary>
        /// Fired when remote debugging connection is about to be terminated. Contains detach reason.
        /// </summary>
        public event EventHandler<DetachedParams>? Detached;
        /// <summary>
        /// Fired when debugging target has crashed
        /// </summary>
        public event EventHandler<TargetCrashedParams>? TargetCrashed;
        /// <summary>
        /// Fired when debugging target has reloaded after crash
        /// </summary>
        public event EventHandler<TargetReloadedAfterCrashParams>? TargetReloadedAfterCrash;
        /// <summary>
        /// Disables inspector domain notifications.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables inspector domain notifications.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "detached": RaiseEvent(Detached, messageBytes);
                    break;
                case "targetCrashed": RaiseEvent(TargetCrashed, messageBytes);
                    break;
                case "targetReloadedAfterCrash": RaiseEvent(TargetReloadedAfterCrash, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class DetachedParams
        {
            /// <summary>
            /// The reason why connection has been terminated.
            /// </summary>
            public string Reason
            {
                get; set;
            }

        }
        public class TargetCrashedParams
        {

        }
        public class TargetReloadedAfterCrashParams
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Inspector.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Inspector.enable";

            }

        }
        public class EnableResult
        {

        }

    }
    public class LayerTreeDomain : BaseDomain
    {
        public LayerTreeDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "LayerTree";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<LayerPaintedParams>? LayerPainted;
        /// <summary>
        /// </summary>
        public event EventHandler<LayerTreeDidChangeParams>? LayerTreeDidChange;
        /// <summary>
        /// Provides the reasons why the given layer was composited.
        /// </summary>
        public async ValueTask<CompositingReasonsResult> CompositingReasonsAsync(CompositingReasonsParams compositingReasonsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(compositingReasonsParams, cancellationToken);

        }
        /// <summary>
        /// Disables compositing tree inspection.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables compositing tree inspection.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Returns the snapshot identifier.
        /// </summary>
        public async ValueTask<LoadSnapshotResult> LoadSnapshotAsync(LoadSnapshotParams loadSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(loadSnapshotParams, cancellationToken);

        }
        /// <summary>
        /// Returns the layer snapshot identifier.
        /// </summary>
        public async ValueTask<MakeSnapshotResult> MakeSnapshotAsync(MakeSnapshotParams makeSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(makeSnapshotParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<ProfileSnapshotResult> ProfileSnapshotAsync(ProfileSnapshotParams profileSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(profileSnapshotParams, cancellationToken);

        }
        /// <summary>
        /// Releases layer snapshot captured by the back-end.
        /// </summary>
        public async ValueTask<ReleaseSnapshotResult> ReleaseSnapshotAsync(ReleaseSnapshotParams releaseSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(releaseSnapshotParams, cancellationToken);

        }
        /// <summary>
        /// Replays the layer snapshot and returns the resulting bitmap.
        /// </summary>
        public async ValueTask<ReplaySnapshotResult> ReplaySnapshotAsync(ReplaySnapshotParams replaySnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(replaySnapshotParams, cancellationToken);

        }
        /// <summary>
        /// Replays the layer snapshot and returns canvas log.
        /// </summary>
        public async ValueTask<SnapshotCommandLogResult> SnapshotCommandLogAsync(SnapshotCommandLogParams snapshotCommandLogParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(snapshotCommandLogParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "layerPainted": RaiseEvent(LayerPainted, messageBytes);
                    break;
                case "layerTreeDidChange": RaiseEvent(LayerTreeDidChange, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class LayerPaintedParams
        {
            /// <summary>
            /// The id of the painted layer.
            /// </summary>
            public string LayerId
            {
                get; set;
            }
            /// <summary>
            /// Clip rectangle.
            /// </summary>
            public DOMDomain.Rect Clip
            {
                get; set;
            }

        }
        public class LayerTreeDidChangeParams
        {
            /// <summary>
            /// Layer tree, absent if not in the comspositing mode.
            /// </summary>
            public LayerTreeDomain.Layer[]? Layers
            {
                get; set;
            }

        }
        public class CompositingReasonsParams : IMethodParams<CompositingReasonsParams, CompositingReasonsResult>
        {
            public string GetMethod()
            {
                return "LayerTree.compositingReasons";

            }
            /// <summary>
            /// The id of the layer for which we want to get the reasons it was composited.
            /// </summary>
            public string LayerId
            {
                get; set;
            }

        }
        public class CompositingReasonsResult
        {
            /// <summary>
            /// A list of strings specifying reasons for the given layer to become composited.
            /// </summary>
            [Obsolete]
            public string[] CompositingReasons
            {
                get; set;
            }
            /// <summary>
            /// A list of strings specifying reason IDs for the given layer to become composited.
            /// </summary>
            public string[] CompositingReasonIds
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "LayerTree.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "LayerTree.enable";

            }

        }
        public class EnableResult
        {

        }
        public class LoadSnapshotParams : IMethodParams<LoadSnapshotParams, LoadSnapshotResult>
        {
            public string GetMethod()
            {
                return "LayerTree.loadSnapshot";

            }
            /// <summary>
            /// An array of tiles composing the snapshot.
            /// </summary>
            public LayerTreeDomain.PictureTile[] Tiles
            {
                get; set;
            }

        }
        public class LoadSnapshotResult
        {
            /// <summary>
            /// The id of the snapshot.
            /// </summary>
            public string SnapshotId
            {
                get; set;
            }

        }
        public class MakeSnapshotParams : IMethodParams<MakeSnapshotParams, MakeSnapshotResult>
        {
            public string GetMethod()
            {
                return "LayerTree.makeSnapshot";

            }
            /// <summary>
            /// The id of the layer.
            /// </summary>
            public string LayerId
            {
                get; set;
            }

        }
        public class MakeSnapshotResult
        {
            /// <summary>
            /// The id of the layer snapshot.
            /// </summary>
            public string SnapshotId
            {
                get; set;
            }

        }
        public class ProfileSnapshotParams : IMethodParams<ProfileSnapshotParams, ProfileSnapshotResult>
        {
            public string GetMethod()
            {
                return "LayerTree.profileSnapshot";

            }
            /// <summary>
            /// The id of the layer snapshot.
            /// </summary>
            public string SnapshotId
            {
                get; set;
            }
            /// <summary>
            /// The maximum number of times to replay the snapshot (1, if not specified).
            /// </summary>
            public int? MinRepeatCount
            {
                get; set;
            }
            /// <summary>
            /// The minimum duration (in seconds) to replay the snapshot.
            /// </summary>
            public double? MinDuration
            {
                get; set;
            }
            /// <summary>
            /// The clip rectangle to apply when replaying the snapshot.
            /// </summary>
            public DOMDomain.Rect? ClipRect
            {
                get; set;
            }

        }
        public class ProfileSnapshotResult
        {
            /// <summary>
            /// The array of paint profiles, one per run.
            /// </summary>
            public double[][] Timings
            {
                get; set;
            }

        }
        public class ReleaseSnapshotParams : IMethodParams<ReleaseSnapshotParams, ReleaseSnapshotResult>
        {
            public string GetMethod()
            {
                return "LayerTree.releaseSnapshot";

            }
            /// <summary>
            /// The id of the layer snapshot.
            /// </summary>
            public string SnapshotId
            {
                get; set;
            }

        }
        public class ReleaseSnapshotResult
        {

        }
        public class ReplaySnapshotParams : IMethodParams<ReplaySnapshotParams, ReplaySnapshotResult>
        {
            public string GetMethod()
            {
                return "LayerTree.replaySnapshot";

            }
            /// <summary>
            /// The id of the layer snapshot.
            /// </summary>
            public string SnapshotId
            {
                get; set;
            }
            /// <summary>
            /// The first step to replay from (replay from the very start if not specified).
            /// </summary>
            public int? FromStep
            {
                get; set;
            }
            /// <summary>
            /// The last step to replay to (replay till the end if not specified).
            /// </summary>
            public int? ToStep
            {
                get; set;
            }
            /// <summary>
            /// The scale to apply while replaying (defaults to 1).
            /// </summary>
            public double? Scale
            {
                get; set;
            }

        }
        public class ReplaySnapshotResult
        {
            /// <summary>
            /// A data: URL for resulting image.
            /// </summary>
            public string DataURL
            {
                get; set;
            }

        }
        public class SnapshotCommandLogParams : IMethodParams<SnapshotCommandLogParams, SnapshotCommandLogResult>
        {
            public string GetMethod()
            {
                return "LayerTree.snapshotCommandLog";

            }
            /// <summary>
            /// The id of the layer snapshot.
            /// </summary>
            public string SnapshotId
            {
                get; set;
            }

        }
        public class SnapshotCommandLogResult
        {
            /// <summary>
            /// The array of canvas function calls.
            /// </summary>
            public object[] CommandLog
            {
                get; set;
            }

        }
        /// <summary>
        /// Rectangle where scrolling happens on the main thread.
        /// </summary>
        public class ScrollRect
        {
            /// <summary>
            /// Rectangle itself.
            /// </summary>
            public DOMDomain.Rect Rect
            {
                get; set;
            }
            /// <summary>
            /// Reason for rectangle to force scrolling on the main thread
            /// </summary>
            /// <value>
            /// RepaintsOnScroll,TouchEventHandler,WheelEventHandler
            /// </value>
            public string Type
            {
                get; set;
            }

        }
        /// <summary>
        /// Sticky position constraints.
        /// </summary>
        public class StickyPositionConstraint
        {
            /// <summary>
            /// Layout rectangle of the sticky element before being shifted
            /// </summary>
            public DOMDomain.Rect StickyBoxRect
            {
                get; set;
            }
            /// <summary>
            /// Layout rectangle of the containing block of the sticky element
            /// </summary>
            public DOMDomain.Rect ContainingBlockRect
            {
                get; set;
            }
            /// <summary>
            /// The nearest sticky layer that shifts the sticky box
            /// </summary>
            public string? NearestLayerShiftingStickyBox
            {
                get; set;
            }
            /// <summary>
            /// The nearest sticky layer that shifts the containing block
            /// </summary>
            public string? NearestLayerShiftingContainingBlock
            {
                get; set;
            }

        }
        /// <summary>
        /// Serialized fragment of layer picture along with its offset within the layer.
        /// </summary>
        public class PictureTile
        {
            /// <summary>
            /// Offset from owning layer left boundary
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Offset from owning layer top boundary
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// Base64-encoded snapshot data. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Picture
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about a compositing layer.
        /// </summary>
        public class Layer
        {
            /// <summary>
            /// The unique id for this layer.
            /// </summary>
            public string LayerId
            {
                get; set;
            }
            /// <summary>
            /// The id of parent (not present for root).
            /// </summary>
            public string? ParentLayerId
            {
                get; set;
            }
            /// <summary>
            /// The backend id for the node associated with this layer.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// Offset from parent layer, X coordinate.
            /// </summary>
            public double OffsetX
            {
                get; set;
            }
            /// <summary>
            /// Offset from parent layer, Y coordinate.
            /// </summary>
            public double OffsetY
            {
                get; set;
            }
            /// <summary>
            /// Layer width.
            /// </summary>
            public double Width
            {
                get; set;
            }
            /// <summary>
            /// Layer height.
            /// </summary>
            public double Height
            {
                get; set;
            }
            /// <summary>
            /// Transformation matrix for layer, default is identity matrix
            /// </summary>
            public double[]? Transform
            {
                get; set;
            }
            /// <summary>
            /// Transform anchor point X, absent if no transform specified
            /// </summary>
            public double? AnchorX
            {
                get; set;
            }
            /// <summary>
            /// Transform anchor point Y, absent if no transform specified
            /// </summary>
            public double? AnchorY
            {
                get; set;
            }
            /// <summary>
            /// Transform anchor point Z, absent if no transform specified
            /// </summary>
            public double? AnchorZ
            {
                get; set;
            }
            /// <summary>
            /// Indicates how many time this layer has painted.
            /// </summary>
            public int PaintCount
            {
                get; set;
            }
            /// <summary>
            /// Indicates whether this layer hosts any content, rather than being used for
            /// transform/scrolling purposes only.
            /// </summary>
            public bool DrawsContent
            {
                get; set;
            }
            /// <summary>
            /// Set if layer is not visible.
            /// </summary>
            public bool? Invisible
            {
                get; set;
            }
            /// <summary>
            /// Rectangles scrolling on main thread only.
            /// </summary>
            public LayerTreeDomain.ScrollRect[]? ScrollRects
            {
                get; set;
            }
            /// <summary>
            /// Sticky position constraint information
            /// </summary>
            public LayerTreeDomain.StickyPositionConstraint? StickyPositionConstraint
            {
                get; set;
            }

        }

    }
    public class LogDomain : BaseDomain
    {
        public LogDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Log";

            }

        }
        /// <summary>
        /// Issued when new message was logged.
        /// </summary>
        public event EventHandler<EntryAddedParams>? EntryAdded;
        /// <summary>
        /// Clears the log.
        /// </summary>
        public async ValueTask<ClearResult> ClearAsync(ClearParams clearParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearParams, cancellationToken);

        }
        /// <summary>
        /// Disables log domain, prevents further log entries from being reported to the client.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables log domain, sends the entries collected so far to the client by means of the
        /// `entryAdded` notification.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// start violation reporting.
        /// </summary>
        public async ValueTask<StartViolationsReportResult> StartViolationsReportAsync(StartViolationsReportParams startViolationsReportParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startViolationsReportParams, cancellationToken);

        }
        /// <summary>
        /// Stop violation reporting.
        /// </summary>
        public async ValueTask<StopViolationsReportResult> StopViolationsReportAsync(StopViolationsReportParams stopViolationsReportParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopViolationsReportParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "entryAdded": RaiseEvent(EntryAdded, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class EntryAddedParams
        {
            /// <summary>
            /// The entry.
            /// </summary>
            public LogDomain.LogEntry Entry
            {
                get; set;
            }

        }
        public class ClearParams : IMethodParams<ClearParams, ClearResult>
        {
            public string GetMethod()
            {
                return "Log.clear";

            }

        }
        public class ClearResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Log.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Log.enable";

            }

        }
        public class EnableResult
        {

        }
        public class StartViolationsReportParams : IMethodParams<StartViolationsReportParams, StartViolationsReportResult>
        {
            public string GetMethod()
            {
                return "Log.startViolationsReport";

            }
            /// <summary>
            /// Configuration for violations.
            /// </summary>
            public LogDomain.ViolationSetting[] Config
            {
                get; set;
            }

        }
        public class StartViolationsReportResult
        {

        }
        public class StopViolationsReportParams : IMethodParams<StopViolationsReportParams, StopViolationsReportResult>
        {
            public string GetMethod()
            {
                return "Log.stopViolationsReport";

            }

        }
        public class StopViolationsReportResult
        {

        }
        /// <summary>
        /// Log entry.
        /// </summary>
        public class LogEntry
        {
            /// <summary>
            /// Log entry source.
            /// </summary>
            /// <value>
            /// xml,javascript,network,storage,appcache,rendering,security,deprecation,worker,violation,intervention,recommendation,other
            /// </value>
            public string Source
            {
                get; set;
            }
            /// <summary>
            /// Log entry severity.
            /// </summary>
            /// <value>
            /// verbose,info,warning,error
            /// </value>
            public string Level
            {
                get; set;
            }
            /// <summary>
            /// Logged text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            /// <value>
            /// cors
            /// </value>
            public string? Category
            {
                get; set;
            }
            /// <summary>
            /// Timestamp when this entry was added.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// URL of the resource if known.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// Line number in the resource.
            /// </summary>
            public int? LineNumber
            {
                get; set;
            }
            /// <summary>
            /// JavaScript stack trace.
            /// </summary>
            public RuntimeDomain.StackTrace? StackTrace
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the network request associated with this entry.
            /// </summary>
            public string? NetworkRequestId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the worker associated with this entry.
            /// </summary>
            public string? WorkerId
            {
                get; set;
            }
            /// <summary>
            /// Call arguments.
            /// </summary>
            public RuntimeDomain.RemoteObject[]? Args
            {
                get; set;
            }

        }
        /// <summary>
        /// Violation configuration setting.
        /// </summary>
        public class ViolationSetting
        {
            /// <summary>
            /// Violation type.
            /// </summary>
            /// <value>
            /// longTask,longLayout,blockedEvent,blockedParser,discouragedAPIUse,handler,recurringHandler
            /// </value>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Time threshold to trigger upon.
            /// </summary>
            public double Threshold
            {
                get; set;
            }

        }

    }
    public class MemoryDomain : BaseDomain
    {
        public MemoryDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Memory";

            }

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetDOMCountersResult> GetDOMCountersAsync(GetDOMCountersParams getDOMCountersParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getDOMCountersParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<PrepareForLeakDetectionResult> PrepareForLeakDetectionAsync(PrepareForLeakDetectionParams prepareForLeakDetectionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(prepareForLeakDetectionParams, cancellationToken);

        }
        /// <summary>
        /// Simulate OomIntervention by purging V8 memory.
        /// </summary>
        public async ValueTask<ForciblyPurgeJavaScriptMemoryResult> ForciblyPurgeJavaScriptMemoryAsync(ForciblyPurgeJavaScriptMemoryParams forciblyPurgeJavaScriptMemoryParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(forciblyPurgeJavaScriptMemoryParams, cancellationToken);

        }
        /// <summary>
        /// Enable/disable suppressing memory pressure notifications in all processes.
        /// </summary>
        public async ValueTask<SetPressureNotificationsSuppressedResult> SetPressureNotificationsSuppressedAsync(SetPressureNotificationsSuppressedParams setPressureNotificationsSuppressedParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPressureNotificationsSuppressedParams, cancellationToken);

        }
        /// <summary>
        /// Simulate a memory pressure notification in all processes.
        /// </summary>
        public async ValueTask<SimulatePressureNotificationResult> SimulatePressureNotificationAsync(SimulatePressureNotificationParams simulatePressureNotificationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(simulatePressureNotificationParams, cancellationToken);

        }
        /// <summary>
        /// Start collecting native memory profile.
        /// </summary>
        public async ValueTask<StartSamplingResult> StartSamplingAsync(StartSamplingParams startSamplingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startSamplingParams, cancellationToken);

        }
        /// <summary>
        /// Stop collecting native memory profile.
        /// </summary>
        public async ValueTask<StopSamplingResult> StopSamplingAsync(StopSamplingParams stopSamplingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopSamplingParams, cancellationToken);

        }
        /// <summary>
        /// Retrieve native memory allocations profile
        /// collected since renderer process startup.
        /// </summary>
        public async ValueTask<GetAllTimeSamplingProfileResult> GetAllTimeSamplingProfileAsync(GetAllTimeSamplingProfileParams getAllTimeSamplingProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getAllTimeSamplingProfileParams, cancellationToken);

        }
        /// <summary>
        /// Retrieve native memory allocations profile
        /// collected since browser process startup.
        /// </summary>
        public async ValueTask<GetBrowserSamplingProfileResult> GetBrowserSamplingProfileAsync(GetBrowserSamplingProfileParams getBrowserSamplingProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getBrowserSamplingProfileParams, cancellationToken);

        }
        /// <summary>
        /// Retrieve native memory allocations profile collected since last
        /// `startSampling` call.
        /// </summary>
        public async ValueTask<GetSamplingProfileResult> GetSamplingProfileAsync(GetSamplingProfileParams getSamplingProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getSamplingProfileParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class GetDOMCountersParams : IMethodParams<GetDOMCountersParams, GetDOMCountersResult>
        {
            public string GetMethod()
            {
                return "Memory.getDOMCounters";

            }

        }
        public class GetDOMCountersResult
        {
            /// <summary>
            /// </summary>
            public int Documents
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int Nodes
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int JsEventListeners
            {
                get; set;
            }

        }
        public class PrepareForLeakDetectionParams : IMethodParams<PrepareForLeakDetectionParams, PrepareForLeakDetectionResult>
        {
            public string GetMethod()
            {
                return "Memory.prepareForLeakDetection";

            }

        }
        public class PrepareForLeakDetectionResult
        {

        }
        public class ForciblyPurgeJavaScriptMemoryParams : IMethodParams<ForciblyPurgeJavaScriptMemoryParams, ForciblyPurgeJavaScriptMemoryResult>
        {
            public string GetMethod()
            {
                return "Memory.forciblyPurgeJavaScriptMemory";

            }

        }
        public class ForciblyPurgeJavaScriptMemoryResult
        {

        }
        public class SetPressureNotificationsSuppressedParams : IMethodParams<SetPressureNotificationsSuppressedParams, SetPressureNotificationsSuppressedResult>
        {
            public string GetMethod()
            {
                return "Memory.setPressureNotificationsSuppressed";

            }
            /// <summary>
            /// If true, memory pressure notifications will be suppressed.
            /// </summary>
            public bool Suppressed
            {
                get; set;
            }

        }
        public class SetPressureNotificationsSuppressedResult
        {

        }
        public class SimulatePressureNotificationParams : IMethodParams<SimulatePressureNotificationParams, SimulatePressureNotificationResult>
        {
            public string GetMethod()
            {
                return "Memory.simulatePressureNotification";

            }
            /// <summary>
            /// Memory pressure level of the notification.
            /// </summary>
            public MemoryDomain.PressureLevel Level
            {
                get; set;
            }

        }
        public class SimulatePressureNotificationResult
        {

        }
        public class StartSamplingParams : IMethodParams<StartSamplingParams, StartSamplingResult>
        {
            public string GetMethod()
            {
                return "Memory.startSampling";

            }
            /// <summary>
            /// Average number of bytes between samples.
            /// </summary>
            public int? SamplingInterval
            {
                get; set;
            }
            /// <summary>
            /// Do not randomize intervals between samples.
            /// </summary>
            public bool? SuppressRandomness
            {
                get; set;
            }

        }
        public class StartSamplingResult
        {

        }
        public class StopSamplingParams : IMethodParams<StopSamplingParams, StopSamplingResult>
        {
            public string GetMethod()
            {
                return "Memory.stopSampling";

            }

        }
        public class StopSamplingResult
        {

        }
        public class GetAllTimeSamplingProfileParams : IMethodParams<GetAllTimeSamplingProfileParams, GetAllTimeSamplingProfileResult>
        {
            public string GetMethod()
            {
                return "Memory.getAllTimeSamplingProfile";

            }

        }
        public class GetAllTimeSamplingProfileResult
        {
            /// <summary>
            /// </summary>
            public MemoryDomain.SamplingProfile Profile
            {
                get; set;
            }

        }
        public class GetBrowserSamplingProfileParams : IMethodParams<GetBrowserSamplingProfileParams, GetBrowserSamplingProfileResult>
        {
            public string GetMethod()
            {
                return "Memory.getBrowserSamplingProfile";

            }

        }
        public class GetBrowserSamplingProfileResult
        {
            /// <summary>
            /// </summary>
            public MemoryDomain.SamplingProfile Profile
            {
                get; set;
            }

        }
        public class GetSamplingProfileParams : IMethodParams<GetSamplingProfileParams, GetSamplingProfileResult>
        {
            public string GetMethod()
            {
                return "Memory.getSamplingProfile";

            }

        }
        public class GetSamplingProfileResult
        {
            /// <summary>
            /// </summary>
            public MemoryDomain.SamplingProfile Profile
            {
                get; set;
            }

        }
        /// <summary>
        /// Memory pressure level.
        /// </summary>
        public enum PressureLevel
        {
            [EnumValue("moderate")]
            Moderate = 1,
            [EnumValue("critical")]
            Critical = 2,

        }
        /// <summary>
        /// Heap profile sample.
        /// </summary>
        public class SamplingProfileNode
        {
            /// <summary>
            /// Size of the sampled allocation.
            /// </summary>
            public double Size
            {
                get; set;
            }
            /// <summary>
            /// Total bytes attributed to this sample.
            /// </summary>
            public double Total
            {
                get; set;
            }
            /// <summary>
            /// Execution stack at the point of allocation.
            /// </summary>
            public string[] Stack
            {
                get; set;
            }

        }
        /// <summary>
        /// Array of heap profile samples.
        /// </summary>
        public class SamplingProfile
        {
            /// <summary>
            /// </summary>
            public MemoryDomain.SamplingProfileNode[] Samples
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public MemoryDomain.Module[] Modules
            {
                get; set;
            }

        }
        /// <summary>
        /// Executable module information
        /// </summary>
        public class Module
        {
            /// <summary>
            /// Name of the module.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// UUID of the module.
            /// </summary>
            public string Uuid
            {
                get; set;
            }
            /// <summary>
            /// Base address where the module is loaded into memory. Encoded as a decimal
            /// or hexadecimal (0x prefixed) string.
            /// </summary>
            public string BaseAddress
            {
                get; set;
            }
            /// <summary>
            /// Size of the module in bytes.
            /// </summary>
            public double Size
            {
                get; set;
            }

        }

    }
    public class NetworkDomain : BaseDomain
    {
        public NetworkDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Network";

            }

        }
        /// <summary>
        /// Fired when data chunk was received over the network.
        /// </summary>
        public event EventHandler<DataReceivedParams>? DataReceived;
        /// <summary>
        /// Fired when EventSource message is received.
        /// </summary>
        public event EventHandler<EventSourceMessageReceivedParams>? EventSourceMessageReceived;
        /// <summary>
        /// Fired when HTTP request has failed to load.
        /// </summary>
        public event EventHandler<LoadingFailedParams>? LoadingFailed;
        /// <summary>
        /// Fired when HTTP request has finished loading.
        /// </summary>
        public event EventHandler<LoadingFinishedParams>? LoadingFinished;
        /// <summary>
        /// Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
        /// mocked.
        /// Deprecated, use Fetch.requestPaused instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public event EventHandler<RequestInterceptedParams>? RequestIntercepted;
        /// <summary>
        /// Fired if request ended up loading from cache.
        /// </summary>
        public event EventHandler<RequestServedFromCacheParams>? RequestServedFromCache;
        /// <summary>
        /// Fired when page is about to send HTTP request.
        /// </summary>
        public event EventHandler<RequestWillBeSentParams>? RequestWillBeSent;
        /// <summary>
        /// Fired when resource loading priority is changed
        /// </summary>
        [Experimental]
        public event EventHandler<ResourceChangedPriorityParams>? ResourceChangedPriority;
        /// <summary>
        /// Fired when a signed exchange was received over the network
        /// </summary>
        [Experimental]
        public event EventHandler<SignedExchangeReceivedParams>? SignedExchangeReceived;
        /// <summary>
        /// Fired when HTTP response is available.
        /// </summary>
        public event EventHandler<ResponseReceivedParams>? ResponseReceived;
        /// <summary>
        /// Fired when WebSocket is closed.
        /// </summary>
        public event EventHandler<WebSocketClosedParams>? WebSocketClosed;
        /// <summary>
        /// Fired upon WebSocket creation.
        /// </summary>
        public event EventHandler<WebSocketCreatedParams>? WebSocketCreated;
        /// <summary>
        /// Fired when WebSocket message error occurs.
        /// </summary>
        public event EventHandler<WebSocketFrameErrorParams>? WebSocketFrameError;
        /// <summary>
        /// Fired when WebSocket message is received.
        /// </summary>
        public event EventHandler<WebSocketFrameReceivedParams>? WebSocketFrameReceived;
        /// <summary>
        /// Fired when WebSocket message is sent.
        /// </summary>
        public event EventHandler<WebSocketFrameSentParams>? WebSocketFrameSent;
        /// <summary>
        /// Fired when WebSocket handshake response becomes available.
        /// </summary>
        public event EventHandler<WebSocketHandshakeResponseReceivedParams>? WebSocketHandshakeResponseReceived;
        /// <summary>
        /// Fired when WebSocket is about to initiate handshake.
        /// </summary>
        public event EventHandler<WebSocketWillSendHandshakeRequestParams>? WebSocketWillSendHandshakeRequest;
        /// <summary>
        /// Fired upon WebTransport creation.
        /// </summary>
        public event EventHandler<WebTransportCreatedParams>? WebTransportCreated;
        /// <summary>
        /// Fired when WebTransport handshake is finished.
        /// </summary>
        public event EventHandler<WebTransportConnectionEstablishedParams>? WebTransportConnectionEstablished;
        /// <summary>
        /// Fired when WebTransport is disposed.
        /// </summary>
        public event EventHandler<WebTransportClosedParams>? WebTransportClosed;
        /// <summary>
        /// Fired when additional information about a requestWillBeSent event is available from the
        /// network stack. Not every requestWillBeSent event will have an additional
        /// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
        /// or requestWillBeSentExtraInfo will be fired first for the same request.
        /// </summary>
        [Experimental]
        public event EventHandler<RequestWillBeSentExtraInfoParams>? RequestWillBeSentExtraInfo;
        /// <summary>
        /// Fired when additional information about a responseReceived event is available from the network
        /// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
        /// it, and responseReceivedExtraInfo may be fired before or after responseReceived.
        /// </summary>
        [Experimental]
        public event EventHandler<ResponseReceivedExtraInfoParams>? ResponseReceivedExtraInfo;
        /// <summary>
        /// Fired exactly once for each Trust Token operation. Depending on
        /// the type of the operation and whether the operation succeeded or
        /// failed, the event is fired before the corresponding request was sent
        /// or after the response was received.
        /// </summary>
        [Experimental]
        public event EventHandler<TrustTokenOperationDoneParams>? TrustTokenOperationDone;
        /// <summary>
        /// Fired once when parsing the .wbn file has succeeded.
        /// The event contains the information about the web bundle contents.
        /// </summary>
        [Experimental]
        public event EventHandler<SubresourceWebBundleMetadataReceivedParams>? SubresourceWebBundleMetadataReceived;
        /// <summary>
        /// Fired once when parsing the .wbn file has failed.
        /// </summary>
        [Experimental]
        public event EventHandler<SubresourceWebBundleMetadataErrorParams>? SubresourceWebBundleMetadataError;
        /// <summary>
        /// Fired when handling requests for resources within a .wbn file.
        /// Note: this will only be fired for resources that are requested by the webpage.
        /// </summary>
        [Experimental]
        public event EventHandler<SubresourceWebBundleInnerResponseParsedParams>? SubresourceWebBundleInnerResponseParsed;
        /// <summary>
        /// Fired when request for resources within a .wbn file failed.
        /// </summary>
        [Experimental]
        public event EventHandler<SubresourceWebBundleInnerResponseErrorParams>? SubresourceWebBundleInnerResponseError;
        /// <summary>
        /// Is sent whenever a new report is added.
        /// And after 'enableReportingApi' for all existing reports.
        /// </summary>
        [Experimental]
        public event EventHandler<ReportingApiReportAddedParams>? ReportingApiReportAdded;
        /// <summary>
        /// </summary>
        [Experimental]
        public event EventHandler<ReportingApiReportUpdatedParams>? ReportingApiReportUpdated;
        /// <summary>
        /// </summary>
        [Experimental]
        public event EventHandler<ReportingApiEndpointsChangedForOriginParams>? ReportingApiEndpointsChangedForOrigin;
        /// <summary>
        /// Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
        /// </summary>
        [Experimental]
        public async ValueTask<SetAcceptedEncodingsResult> SetAcceptedEncodingsAsync(SetAcceptedEncodingsParams setAcceptedEncodingsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAcceptedEncodingsParams, cancellationToken);

        }
        /// <summary>
        /// Clears accepted encodings set by setAcceptedEncodings
        /// </summary>
        [Experimental]
        public async ValueTask<ClearAcceptedEncodingsOverrideResult> ClearAcceptedEncodingsOverrideAsync(ClearAcceptedEncodingsOverrideParams clearAcceptedEncodingsOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearAcceptedEncodingsOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Tells whether clearing browser cache is supported.
        /// </summary>
        [Obsolete]
        public async ValueTask<CanClearBrowserCacheResult> CanClearBrowserCacheAsync(CanClearBrowserCacheParams canClearBrowserCacheParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(canClearBrowserCacheParams, cancellationToken);

        }
        /// <summary>
        /// Tells whether clearing browser cookies is supported.
        /// </summary>
        [Obsolete]
        public async ValueTask<CanClearBrowserCookiesResult> CanClearBrowserCookiesAsync(CanClearBrowserCookiesParams canClearBrowserCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(canClearBrowserCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Tells whether emulation of network conditions is supported.
        /// </summary>
        [Obsolete]
        public async ValueTask<CanEmulateNetworkConditionsResult> CanEmulateNetworkConditionsAsync(CanEmulateNetworkConditionsParams canEmulateNetworkConditionsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(canEmulateNetworkConditionsParams, cancellationToken);

        }
        /// <summary>
        /// Clears browser cache.
        /// </summary>
        public async ValueTask<ClearBrowserCacheResult> ClearBrowserCacheAsync(ClearBrowserCacheParams clearBrowserCacheParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearBrowserCacheParams, cancellationToken);

        }
        /// <summary>
        /// Clears browser cookies.
        /// </summary>
        public async ValueTask<ClearBrowserCookiesResult> ClearBrowserCookiesAsync(ClearBrowserCookiesParams clearBrowserCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearBrowserCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Response to Network.requestIntercepted which either modifies the request to continue with any
        /// modifications, or blocks it, or completes it with the provided response bytes. If a network
        /// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
        /// event will be sent with the same InterceptionId.
        /// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<ContinueInterceptedRequestResult> ContinueInterceptedRequestAsync(ContinueInterceptedRequestParams continueInterceptedRequestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(continueInterceptedRequestParams, cancellationToken);

        }
        /// <summary>
        /// Deletes browser cookies with matching name and url or domain/path pair.
        /// </summary>
        public async ValueTask<DeleteCookiesResult> DeleteCookiesAsync(DeleteCookiesParams deleteCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deleteCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Disables network tracking, prevents network events from being sent to the client.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Activates emulation of network conditions.
        /// </summary>
        public async ValueTask<EmulateNetworkConditionsResult> EmulateNetworkConditionsAsync(EmulateNetworkConditionsParams emulateNetworkConditionsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(emulateNetworkConditionsParams, cancellationToken);

        }
        /// <summary>
        /// Enables network tracking, network events will now be delivered to the client.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Returns all browser cookies. Depending on the backend support, will return detailed cookie
        /// information in the `cookies` field.
        /// </summary>
        public async ValueTask<GetAllCookiesResult> GetAllCookiesAsync(GetAllCookiesParams getAllCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getAllCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Returns the DER-encoded certificate.
        /// </summary>
        [Experimental]
        public async ValueTask<GetCertificateResult> GetCertificateAsync(GetCertificateParams getCertificateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCertificateParams, cancellationToken);

        }
        /// <summary>
        /// Returns all browser cookies for the current URL. Depending on the backend support, will return
        /// detailed cookie information in the `cookies` field.
        /// </summary>
        public async ValueTask<GetCookiesResult> GetCookiesAsync(GetCookiesParams getCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Returns content served for the given request.
        /// </summary>
        public async ValueTask<GetResponseBodyResult> GetResponseBodyAsync(GetResponseBodyParams getResponseBodyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getResponseBodyParams, cancellationToken);

        }
        /// <summary>
        /// Returns post data sent with the request. Returns an error when no data was sent with the request.
        /// </summary>
        public async ValueTask<GetRequestPostDataResult> GetRequestPostDataAsync(GetRequestPostDataParams getRequestPostDataParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getRequestPostDataParams, cancellationToken);

        }
        /// <summary>
        /// Returns content served for the given currently intercepted request.
        /// </summary>
        [Experimental]
        public async ValueTask<GetResponseBodyForInterceptionResult> GetResponseBodyForInterceptionAsync(GetResponseBodyForInterceptionParams getResponseBodyForInterceptionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getResponseBodyForInterceptionParams, cancellationToken);

        }
        /// <summary>
        /// Returns a handle to the stream representing the response body. Note that after this command,
        /// the intercepted request can't be continued as is -- you either need to cancel it or to provide
        /// the response body. The stream only supports sequential read, IO.read will fail if the position
        /// is specified.
        /// </summary>
        [Experimental]
        public async ValueTask<TakeResponseBodyForInterceptionAsStreamResult> TakeResponseBodyForInterceptionAsStreamAsync(TakeResponseBodyForInterceptionAsStreamParams takeResponseBodyForInterceptionAsStreamParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takeResponseBodyForInterceptionAsStreamParams, cancellationToken);

        }
        /// <summary>
        /// This method sends a new XMLHttpRequest which is identical to the original one. The following
        /// parameters should be identical: method, url, async, request body, extra headers, withCredentials
        /// attribute, user, password.
        /// </summary>
        [Experimental]
        public async ValueTask<ReplayXHRResult> ReplayXHRAsync(ReplayXHRParams replayXHRParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(replayXHRParams, cancellationToken);

        }
        /// <summary>
        /// Searches for given string in response content.
        /// </summary>
        [Experimental]
        public async ValueTask<SearchInResponseBodyResult> SearchInResponseBodyAsync(SearchInResponseBodyParams searchInResponseBodyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(searchInResponseBodyParams, cancellationToken);

        }
        /// <summary>
        /// Blocks URLs from loading.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBlockedURLsResult> SetBlockedURLsAsync(SetBlockedURLsParams setBlockedURLsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBlockedURLsParams, cancellationToken);

        }
        /// <summary>
        /// Toggles ignoring of service worker for each request.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBypassServiceWorkerResult> SetBypassServiceWorkerAsync(SetBypassServiceWorkerParams setBypassServiceWorkerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBypassServiceWorkerParams, cancellationToken);

        }
        /// <summary>
        /// Toggles ignoring cache for each request. If `true`, cache will not be used.
        /// </summary>
        public async ValueTask<SetCacheDisabledResult> SetCacheDisabledAsync(SetCacheDisabledParams setCacheDisabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setCacheDisabledParams, cancellationToken);

        }
        /// <summary>
        /// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
        /// </summary>
        public async ValueTask<SetCookieResult> SetCookieAsync(SetCookieParams setCookieParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setCookieParams, cancellationToken);

        }
        /// <summary>
        /// Sets given cookies.
        /// </summary>
        public async ValueTask<SetCookiesResult> SetCookiesAsync(SetCookiesParams setCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Specifies whether to always send extra HTTP headers with the requests from this page.
        /// </summary>
        public async ValueTask<SetExtraHTTPHeadersResult> SetExtraHTTPHeadersAsync(SetExtraHTTPHeadersParams setExtraHTTPHeadersParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setExtraHTTPHeadersParams, cancellationToken);

        }
        /// <summary>
        /// Specifies whether to attach a page script stack id in requests
        /// </summary>
        [Experimental]
        public async ValueTask<SetAttachDebugStackResult> SetAttachDebugStackAsync(SetAttachDebugStackParams setAttachDebugStackParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAttachDebugStackParams, cancellationToken);

        }
        /// <summary>
        /// Sets the requests to intercept that match the provided patterns and optionally resource types.
        /// Deprecated, please use Fetch.enable instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetRequestInterceptionResult> SetRequestInterceptionAsync(SetRequestInterceptionParams setRequestInterceptionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setRequestInterceptionParams, cancellationToken);

        }
        /// <summary>
        /// Allows overriding user agent with the given string.
        /// </summary>
        public async ValueTask<SetUserAgentOverrideResult> SetUserAgentOverrideAsync(SetUserAgentOverrideParams setUserAgentOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setUserAgentOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Returns information about the COEP/COOP isolation status.
        /// </summary>
        [Experimental]
        public async ValueTask<GetSecurityIsolationStatusResult> GetSecurityIsolationStatusAsync(GetSecurityIsolationStatusParams getSecurityIsolationStatusParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getSecurityIsolationStatusParams, cancellationToken);

        }
        /// <summary>
        /// Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
        /// Enabling triggers 'reportingApiReportAdded' for all existing reports.
        /// </summary>
        [Experimental]
        public async ValueTask<EnableReportingApiResult> EnableReportingApiAsync(EnableReportingApiParams enableReportingApiParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableReportingApiParams, cancellationToken);

        }
        /// <summary>
        /// Fetches the resource and returns the content.
        /// </summary>
        [Experimental]
        public async ValueTask<LoadNetworkResourceResult> LoadNetworkResourceAsync(LoadNetworkResourceParams loadNetworkResourceParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(loadNetworkResourceParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "dataReceived": RaiseEvent(DataReceived, messageBytes);
                    break;
                case "eventSourceMessageReceived": RaiseEvent(EventSourceMessageReceived, messageBytes);
                    break;
                case "loadingFailed": RaiseEvent(LoadingFailed, messageBytes);
                    break;
                case "loadingFinished": RaiseEvent(LoadingFinished, messageBytes);
                    break;
                case "requestIntercepted": RaiseEvent(RequestIntercepted, messageBytes);
                    break;
                case "requestServedFromCache": RaiseEvent(RequestServedFromCache, messageBytes);
                    break;
                case "requestWillBeSent": RaiseEvent(RequestWillBeSent, messageBytes);
                    break;
                case "resourceChangedPriority": RaiseEvent(ResourceChangedPriority, messageBytes);
                    break;
                case "signedExchangeReceived": RaiseEvent(SignedExchangeReceived, messageBytes);
                    break;
                case "responseReceived": RaiseEvent(ResponseReceived, messageBytes);
                    break;
                case "webSocketClosed": RaiseEvent(WebSocketClosed, messageBytes);
                    break;
                case "webSocketCreated": RaiseEvent(WebSocketCreated, messageBytes);
                    break;
                case "webSocketFrameError": RaiseEvent(WebSocketFrameError, messageBytes);
                    break;
                case "webSocketFrameReceived": RaiseEvent(WebSocketFrameReceived, messageBytes);
                    break;
                case "webSocketFrameSent": RaiseEvent(WebSocketFrameSent, messageBytes);
                    break;
                case "webSocketHandshakeResponseReceived": RaiseEvent(WebSocketHandshakeResponseReceived, messageBytes);
                    break;
                case "webSocketWillSendHandshakeRequest": RaiseEvent(WebSocketWillSendHandshakeRequest, messageBytes);
                    break;
                case "webTransportCreated": RaiseEvent(WebTransportCreated, messageBytes);
                    break;
                case "webTransportConnectionEstablished": RaiseEvent(WebTransportConnectionEstablished, messageBytes);
                    break;
                case "webTransportClosed": RaiseEvent(WebTransportClosed, messageBytes);
                    break;
                case "requestWillBeSentExtraInfo": RaiseEvent(RequestWillBeSentExtraInfo, messageBytes);
                    break;
                case "responseReceivedExtraInfo": RaiseEvent(ResponseReceivedExtraInfo, messageBytes);
                    break;
                case "trustTokenOperationDone": RaiseEvent(TrustTokenOperationDone, messageBytes);
                    break;
                case "subresourceWebBundleMetadataReceived": RaiseEvent(SubresourceWebBundleMetadataReceived, messageBytes);
                    break;
                case "subresourceWebBundleMetadataError": RaiseEvent(SubresourceWebBundleMetadataError, messageBytes);
                    break;
                case "subresourceWebBundleInnerResponseParsed": RaiseEvent(SubresourceWebBundleInnerResponseParsed, messageBytes);
                    break;
                case "subresourceWebBundleInnerResponseError": RaiseEvent(SubresourceWebBundleInnerResponseError, messageBytes);
                    break;
                case "reportingApiReportAdded": RaiseEvent(ReportingApiReportAdded, messageBytes);
                    break;
                case "reportingApiReportUpdated": RaiseEvent(ReportingApiReportUpdated, messageBytes);
                    break;
                case "reportingApiEndpointsChangedForOrigin": RaiseEvent(ReportingApiEndpointsChangedForOrigin, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class DataReceivedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Data chunk length.
            /// </summary>
            public int DataLength
            {
                get; set;
            }
            /// <summary>
            /// Actual bytes received (might be less than dataLength for compressed encodings).
            /// </summary>
            public int EncodedDataLength
            {
                get; set;
            }

        }
        public class EventSourceMessageReceivedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Message type.
            /// </summary>
            public string EventName
            {
                get; set;
            }
            /// <summary>
            /// Message identifier.
            /// </summary>
            public string EventId
            {
                get; set;
            }
            /// <summary>
            /// Message content.
            /// </summary>
            public string Data
            {
                get; set;
            }

        }
        public class LoadingFailedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Resource type.
            /// </summary>
            public NetworkDomain.ResourceType Type
            {
                get; set;
            }
            /// <summary>
            /// User friendly error message.
            /// </summary>
            public string ErrorText
            {
                get; set;
            }
            /// <summary>
            /// True if loading was canceled.
            /// </summary>
            public bool? Canceled
            {
                get; set;
            }
            /// <summary>
            /// The reason why loading was blocked, if any.
            /// </summary>
            public NetworkDomain.BlockedReason? BlockedReason
            {
                get; set;
            }
            /// <summary>
            /// The reason why loading was blocked by CORS, if any.
            /// </summary>
            public NetworkDomain.CorsErrorStatus? CorsErrorStatus
            {
                get; set;
            }

        }
        public class LoadingFinishedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Total number of bytes received for this request.
            /// </summary>
            public double EncodedDataLength
            {
                get; set;
            }
            /// <summary>
            /// Set when 1) response was blocked by Cross-Origin Read Blocking and also
            /// 2) this needs to be reported to the DevTools console.
            /// </summary>
            public bool? ShouldReportCorbBlocking
            {
                get; set;
            }

        }
        public class RequestInterceptedParams
        {
            /// <summary>
            /// Each request the page makes will have a unique id, however if any redirects are encountered
            /// while processing that fetch, they will be reported with the same id as the original fetch.
            /// Likewise if HTTP authentication is needed then the same fetch id will be used.
            /// </summary>
            public string InterceptionId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.Request Request
            {
                get; set;
            }
            /// <summary>
            /// The id of the frame that initiated the request.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// How the requested resource will be used.
            /// </summary>
            public NetworkDomain.ResourceType ResourceType
            {
                get; set;
            }
            /// <summary>
            /// Whether this is a navigation request, which can abort the navigation completely.
            /// </summary>
            public bool IsNavigationRequest
            {
                get; set;
            }
            /// <summary>
            /// Set if the request is a navigation that will result in a download.
            /// Only present after response is received from the server (i.e. HeadersReceived stage).
            /// </summary>
            public bool? IsDownload
            {
                get; set;
            }
            /// <summary>
            /// Redirect location, only sent if a redirect was intercepted.
            /// </summary>
            public string? RedirectUrl
            {
                get; set;
            }
            /// <summary>
            /// Details of the Authorization Challenge encountered. If this is set then
            /// continueInterceptedRequest must contain an authChallengeResponse.
            /// </summary>
            public NetworkDomain.AuthChallenge? AuthChallenge
            {
                get; set;
            }
            /// <summary>
            /// Response error if intercepted at response stage or if redirect occurred while intercepting
            /// request.
            /// </summary>
            public NetworkDomain.ErrorReason? ResponseErrorReason
            {
                get; set;
            }
            /// <summary>
            /// Response code if intercepted at response stage or if redirect occurred while intercepting
            /// request or auth retry occurred.
            /// </summary>
            public int? ResponseStatusCode
            {
                get; set;
            }
            /// <summary>
            /// Response headers if intercepted at the response stage or if redirect occurred while
            /// intercepting request or auth retry occurred.
            /// </summary>
            public NetworkDomain.Headers? ResponseHeaders
            {
                get; set;
            }
            /// <summary>
            /// If the intercepted request had a corresponding requestWillBeSent event fired for it, then
            /// this requestId will be the same as the requestId present in the requestWillBeSent event.
            /// </summary>
            public string? RequestId
            {
                get; set;
            }

        }
        public class RequestServedFromCacheParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }

        }
        public class RequestWillBeSentParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Loader identifier. Empty string if the request is fetched from worker.
            /// </summary>
            public string LoaderId
            {
                get; set;
            }
            /// <summary>
            /// URL of the document this request is loaded for.
            /// </summary>
            public string DocumentURL
            {
                get; set;
            }
            /// <summary>
            /// Request data.
            /// </summary>
            public NetworkDomain.Request Request
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double WallTime
            {
                get; set;
            }
            /// <summary>
            /// Request initiator.
            /// </summary>
            public NetworkDomain.Initiator Initiator
            {
                get; set;
            }
            /// <summary>
            /// In the case that redirectResponse is populated, this flag indicates whether
            /// requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted
            /// for the request which was just redirected.
            /// </summary>
            [Experimental]
            public bool RedirectHasExtraInfo
            {
                get; set;
            }
            /// <summary>
            /// Redirect response data.
            /// </summary>
            public NetworkDomain.Response? RedirectResponse
            {
                get; set;
            }
            /// <summary>
            /// Type of this resource.
            /// </summary>
            public NetworkDomain.ResourceType? Type
            {
                get; set;
            }
            /// <summary>
            /// Frame identifier.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }
            /// <summary>
            /// Whether the request is initiated by a user gesture. Defaults to false.
            /// </summary>
            public bool? HasUserGesture
            {
                get; set;
            }

        }
        public class ResourceChangedPriorityParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// New priority
            /// </summary>
            public NetworkDomain.ResourcePriority NewPriority
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class SignedExchangeReceivedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Information about the signed exchange response.
            /// </summary>
            public NetworkDomain.SignedExchangeInfo Info
            {
                get; set;
            }

        }
        public class ResponseReceivedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Loader identifier. Empty string if the request is fetched from worker.
            /// </summary>
            public string LoaderId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Resource type.
            /// </summary>
            public NetworkDomain.ResourceType Type
            {
                get; set;
            }
            /// <summary>
            /// Response data.
            /// </summary>
            public NetworkDomain.Response Response
            {
                get; set;
            }
            /// <summary>
            /// Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be
            /// or were emitted for this request.
            /// </summary>
            [Experimental]
            public bool HasExtraInfo
            {
                get; set;
            }
            /// <summary>
            /// Frame identifier.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }
        public class WebSocketClosedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class WebSocketCreatedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// WebSocket request URL.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Request initiator.
            /// </summary>
            public NetworkDomain.Initiator? Initiator
            {
                get; set;
            }

        }
        public class WebSocketFrameErrorParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// WebSocket error message.
            /// </summary>
            public string ErrorMessage
            {
                get; set;
            }

        }
        public class WebSocketFrameReceivedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// WebSocket response data.
            /// </summary>
            public NetworkDomain.WebSocketFrame Response
            {
                get; set;
            }

        }
        public class WebSocketFrameSentParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// WebSocket response data.
            /// </summary>
            public NetworkDomain.WebSocketFrame Response
            {
                get; set;
            }

        }
        public class WebSocketHandshakeResponseReceivedParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// WebSocket response data.
            /// </summary>
            public NetworkDomain.WebSocketResponse Response
            {
                get; set;
            }

        }
        public class WebSocketWillSendHandshakeRequestParams
        {
            /// <summary>
            /// Request identifier.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// UTC Timestamp.
            /// </summary>
            public double WallTime
            {
                get; set;
            }
            /// <summary>
            /// WebSocket request data.
            /// </summary>
            public NetworkDomain.WebSocketRequest Request
            {
                get; set;
            }

        }
        public class WebTransportCreatedParams
        {
            /// <summary>
            /// WebTransport identifier.
            /// </summary>
            public string TransportId
            {
                get; set;
            }
            /// <summary>
            /// WebTransport request URL.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Request initiator.
            /// </summary>
            public NetworkDomain.Initiator? Initiator
            {
                get; set;
            }

        }
        public class WebTransportConnectionEstablishedParams
        {
            /// <summary>
            /// WebTransport identifier.
            /// </summary>
            public string TransportId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class WebTransportClosedParams
        {
            /// <summary>
            /// WebTransport identifier.
            /// </summary>
            public string TransportId
            {
                get; set;
            }
            /// <summary>
            /// Timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class RequestWillBeSentExtraInfoParams
        {
            /// <summary>
            /// Request identifier. Used to match this information to an existing requestWillBeSent event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// A list of cookies potentially associated to the requested URL. This includes both cookies sent with
            /// the request and the ones not sent; the latter are distinguished by having blockedReason field set.
            /// </summary>
            public NetworkDomain.BlockedCookieWithReason[] AssociatedCookies
            {
                get; set;
            }
            /// <summary>
            /// Raw request headers as they will be sent over the wire.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }
            /// <summary>
            /// Connection timing information for the request.
            /// </summary>
            [Experimental]
            public NetworkDomain.ConnectTiming ConnectTiming
            {
                get; set;
            }
            /// <summary>
            /// The client security state set for the request.
            /// </summary>
            public NetworkDomain.ClientSecurityState? ClientSecurityState
            {
                get; set;
            }

        }
        public class ResponseReceivedExtraInfoParams
        {
            /// <summary>
            /// Request identifier. Used to match this information to another responseReceived event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// A list of cookies which were not stored from the response along with the corresponding
            /// reasons for blocking. The cookies here may not be valid due to syntax errors, which
            /// are represented by the invalid cookie line string instead of a proper cookie.
            /// </summary>
            public NetworkDomain.BlockedSetCookieWithReason[] BlockedCookies
            {
                get; set;
            }
            /// <summary>
            /// Raw response headers as they were received over the wire.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }
            /// <summary>
            /// The IP address space of the resource. The address space can only be determined once the transport
            /// established the connection, so we can't send it in `requestWillBeSentExtraInfo`.
            /// </summary>
            public NetworkDomain.IPAddressSpace ResourceIPAddressSpace
            {
                get; set;
            }
            /// <summary>
            /// The status code of the response. This is useful in cases the request failed and no responseReceived
            /// event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code
            /// for cached requests, where the status in responseReceived is a 200 and this will be 304.
            /// </summary>
            public int StatusCode
            {
                get; set;
            }
            /// <summary>
            /// Raw response header text as it was received over the wire. The raw text may not always be
            /// available, such as in the case of HTTP/2 or QUIC.
            /// </summary>
            public string? HeadersText
            {
                get; set;
            }

        }
        public class TrustTokenOperationDoneParams
        {
            /// <summary>
            /// Detailed success or error status of the operation.
            /// 'AlreadyExists' also signifies a successful operation, as the result
            /// of the operation already exists und thus, the operation was abort
            /// preemptively (e.g. a cache hit).
            /// </summary>
            /// <value>
            /// Ok,InvalidArgument,FailedPrecondition,ResourceExhausted,AlreadyExists,Unavailable,BadResponse,InternalError,UnknownError,FulfilledLocally
            /// </value>
            public string Status
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.TrustTokenOperationType Type
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Top level origin. The context in which the operation was attempted.
            /// </summary>
            public string? TopLevelOrigin
            {
                get; set;
            }
            /// <summary>
            /// Origin of the issuer in case of a "Issuance" or "Redemption" operation.
            /// </summary>
            public string? IssuerOrigin
            {
                get; set;
            }
            /// <summary>
            /// The number of obtained Trust Tokens on a successful "Issuance" operation.
            /// </summary>
            public int? IssuedTokenCount
            {
                get; set;
            }

        }
        public class SubresourceWebBundleMetadataReceivedParams
        {
            /// <summary>
            /// Request identifier. Used to match this information to another event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// A list of URLs of resources in the subresource Web Bundle.
            /// </summary>
            public string[] Urls
            {
                get; set;
            }

        }
        public class SubresourceWebBundleMetadataErrorParams
        {
            /// <summary>
            /// Request identifier. Used to match this information to another event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Error message
            /// </summary>
            public string ErrorMessage
            {
                get; set;
            }

        }
        public class SubresourceWebBundleInnerResponseParsedParams
        {
            /// <summary>
            /// Request identifier of the subresource request
            /// </summary>
            public string InnerRequestId
            {
                get; set;
            }
            /// <summary>
            /// URL of the subresource resource.
            /// </summary>
            public string InnerRequestURL
            {
                get; set;
            }
            /// <summary>
            /// Bundle request identifier. Used to match this information to another event.
            /// This made be absent in case when the instrumentation was enabled only
            /// after webbundle was parsed.
            /// </summary>
            public string? BundleRequestId
            {
                get; set;
            }

        }
        public class SubresourceWebBundleInnerResponseErrorParams
        {
            /// <summary>
            /// Request identifier of the subresource request
            /// </summary>
            public string InnerRequestId
            {
                get; set;
            }
            /// <summary>
            /// URL of the subresource resource.
            /// </summary>
            public string InnerRequestURL
            {
                get; set;
            }
            /// <summary>
            /// Error message
            /// </summary>
            public string ErrorMessage
            {
                get; set;
            }
            /// <summary>
            /// Bundle request identifier. Used to match this information to another event.
            /// This made be absent in case when the instrumentation was enabled only
            /// after webbundle was parsed.
            /// </summary>
            public string? BundleRequestId
            {
                get; set;
            }

        }
        public class ReportingApiReportAddedParams
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.ReportingApiReport Report
            {
                get; set;
            }

        }
        public class ReportingApiReportUpdatedParams
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.ReportingApiReport Report
            {
                get; set;
            }

        }
        public class ReportingApiEndpointsChangedForOriginParams
        {
            /// <summary>
            /// Origin of the document(s) which configured the endpoints.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.ReportingApiEndpoint[] Endpoints
            {
                get; set;
            }

        }
        public class SetAcceptedEncodingsParams : IMethodParams<SetAcceptedEncodingsParams, SetAcceptedEncodingsResult>
        {
            public string GetMethod()
            {
                return "Network.setAcceptedEncodings";

            }
            /// <summary>
            /// List of accepted content encodings.
            /// </summary>
            public NetworkDomain.ContentEncoding[] Encodings
            {
                get; set;
            }

        }
        public class SetAcceptedEncodingsResult
        {

        }
        public class ClearAcceptedEncodingsOverrideParams : IMethodParams<ClearAcceptedEncodingsOverrideParams, ClearAcceptedEncodingsOverrideResult>
        {
            public string GetMethod()
            {
                return "Network.clearAcceptedEncodingsOverride";

            }

        }
        public class ClearAcceptedEncodingsOverrideResult
        {

        }
        public class CanClearBrowserCacheParams : IMethodParams<CanClearBrowserCacheParams, CanClearBrowserCacheResult>
        {
            public string GetMethod()
            {
                return "Network.canClearBrowserCache";

            }

        }
        public class CanClearBrowserCacheResult
        {
            /// <summary>
            /// True if browser cache can be cleared.
            /// </summary>
            public bool Result
            {
                get; set;
            }

        }
        public class CanClearBrowserCookiesParams : IMethodParams<CanClearBrowserCookiesParams, CanClearBrowserCookiesResult>
        {
            public string GetMethod()
            {
                return "Network.canClearBrowserCookies";

            }

        }
        public class CanClearBrowserCookiesResult
        {
            /// <summary>
            /// True if browser cookies can be cleared.
            /// </summary>
            public bool Result
            {
                get; set;
            }

        }
        public class CanEmulateNetworkConditionsParams : IMethodParams<CanEmulateNetworkConditionsParams, CanEmulateNetworkConditionsResult>
        {
            public string GetMethod()
            {
                return "Network.canEmulateNetworkConditions";

            }

        }
        public class CanEmulateNetworkConditionsResult
        {
            /// <summary>
            /// True if emulation of network conditions is supported.
            /// </summary>
            public bool Result
            {
                get; set;
            }

        }
        public class ClearBrowserCacheParams : IMethodParams<ClearBrowserCacheParams, ClearBrowserCacheResult>
        {
            public string GetMethod()
            {
                return "Network.clearBrowserCache";

            }

        }
        public class ClearBrowserCacheResult
        {

        }
        public class ClearBrowserCookiesParams : IMethodParams<ClearBrowserCookiesParams, ClearBrowserCookiesResult>
        {
            public string GetMethod()
            {
                return "Network.clearBrowserCookies";

            }

        }
        public class ClearBrowserCookiesResult
        {

        }
        public class ContinueInterceptedRequestParams : IMethodParams<ContinueInterceptedRequestParams, ContinueInterceptedRequestResult>
        {
            public string GetMethod()
            {
                return "Network.continueInterceptedRequest";

            }
            /// <summary>
            /// </summary>
            public string InterceptionId
            {
                get; set;
            }
            /// <summary>
            /// If set this causes the request to fail with the given reason. Passing `Aborted` for requests
            /// marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
            /// to an authChallenge.
            /// </summary>
            public NetworkDomain.ErrorReason? ErrorReason
            {
                get; set;
            }
            /// <summary>
            /// If set the requests completes using with the provided base64 encoded raw response, including
            /// HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? RawResponse
            {
                get; set;
            }
            /// <summary>
            /// If set the request url will be modified in a way that's not observable by page. Must not be
            /// set in response to an authChallenge.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// If set this allows the request method to be overridden. Must not be set in response to an
            /// authChallenge.
            /// </summary>
            public string? Method
            {
                get; set;
            }
            /// <summary>
            /// If set this allows postData to be set. Must not be set in response to an authChallenge.
            /// </summary>
            public string? PostData
            {
                get; set;
            }
            /// <summary>
            /// If set this allows the request headers to be changed. Must not be set in response to an
            /// authChallenge.
            /// </summary>
            public NetworkDomain.Headers? Headers
            {
                get; set;
            }
            /// <summary>
            /// Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
            /// </summary>
            public NetworkDomain.AuthChallengeResponse? AuthChallengeResponse
            {
                get; set;
            }

        }
        public class ContinueInterceptedRequestResult
        {

        }
        public class DeleteCookiesParams : IMethodParams<DeleteCookiesParams, DeleteCookiesResult>
        {
            public string GetMethod()
            {
                return "Network.deleteCookies";

            }
            /// <summary>
            /// Name of the cookies to remove.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// If specified, deletes all the cookies with the given name where domain and path match
            /// provided URL.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// If specified, deletes only cookies with the exact domain.
            /// </summary>
            public string? Domain
            {
                get; set;
            }
            /// <summary>
            /// If specified, deletes only cookies with the exact path.
            /// </summary>
            public string? Path
            {
                get; set;
            }

        }
        public class DeleteCookiesResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Network.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EmulateNetworkConditionsParams : IMethodParams<EmulateNetworkConditionsParams, EmulateNetworkConditionsResult>
        {
            public string GetMethod()
            {
                return "Network.emulateNetworkConditions";

            }
            /// <summary>
            /// True to emulate internet disconnection.
            /// </summary>
            public bool Offline
            {
                get; set;
            }
            /// <summary>
            /// Minimum latency from request sent to response headers received (ms).
            /// </summary>
            public double Latency
            {
                get; set;
            }
            /// <summary>
            /// Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
            /// </summary>
            public double DownloadThroughput
            {
                get; set;
            }
            /// <summary>
            /// Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
            /// </summary>
            public double UploadThroughput
            {
                get; set;
            }
            /// <summary>
            /// Connection type if known.
            /// </summary>
            public NetworkDomain.ConnectionType? ConnectionType
            {
                get; set;
            }

        }
        public class EmulateNetworkConditionsResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Network.enable";

            }
            /// <summary>
            /// Buffer size in bytes to use when preserving network payloads (XHRs, etc).
            /// </summary>
            [Experimental]
            public int? MaxTotalBufferSize
            {
                get; set;
            }
            /// <summary>
            /// Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
            /// </summary>
            [Experimental]
            public int? MaxResourceBufferSize
            {
                get; set;
            }
            /// <summary>
            /// Longest post body size (in bytes) that would be included in requestWillBeSent notification
            /// </summary>
            public int? MaxPostDataSize
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        public class GetAllCookiesParams : IMethodParams<GetAllCookiesParams, GetAllCookiesResult>
        {
            public string GetMethod()
            {
                return "Network.getAllCookies";

            }

        }
        public class GetAllCookiesResult
        {
            /// <summary>
            /// Array of cookie objects.
            /// </summary>
            public NetworkDomain.Cookie[] Cookies
            {
                get; set;
            }

        }
        public class GetCertificateParams : IMethodParams<GetCertificateParams, GetCertificateResult>
        {
            public string GetMethod()
            {
                return "Network.getCertificate";

            }
            /// <summary>
            /// Origin to get certificate for.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class GetCertificateResult
        {
            /// <summary>
            /// </summary>
            public string[] TableNames
            {
                get; set;
            }

        }
        public class GetCookiesParams : IMethodParams<GetCookiesParams, GetCookiesResult>
        {
            public string GetMethod()
            {
                return "Network.getCookies";

            }
            /// <summary>
            /// The list of URLs for which applicable cookies will be fetched.
            /// If not specified, it's assumed to be set to the list containing
            /// the URLs of the page and all of its subframes.
            /// </summary>
            public string[]? Urls
            {
                get; set;
            }

        }
        public class GetCookiesResult
        {
            /// <summary>
            /// Array of cookie objects.
            /// </summary>
            public NetworkDomain.Cookie[] Cookies
            {
                get; set;
            }

        }
        public class GetResponseBodyParams : IMethodParams<GetResponseBodyParams, GetResponseBodyResult>
        {
            public string GetMethod()
            {
                return "Network.getResponseBody";

            }
            /// <summary>
            /// Identifier of the network request to get content for.
            /// </summary>
            public string RequestId
            {
                get; set;
            }

        }
        public class GetResponseBodyResult
        {
            /// <summary>
            /// Response body.
            /// </summary>
            public string Body
            {
                get; set;
            }
            /// <summary>
            /// True, if content was sent as base64.
            /// </summary>
            public bool Base64Encoded
            {
                get; set;
            }

        }
        public class GetRequestPostDataParams : IMethodParams<GetRequestPostDataParams, GetRequestPostDataResult>
        {
            public string GetMethod()
            {
                return "Network.getRequestPostData";

            }
            /// <summary>
            /// Identifier of the network request to get content for.
            /// </summary>
            public string RequestId
            {
                get; set;
            }

        }
        public class GetRequestPostDataResult
        {
            /// <summary>
            /// Request body string, omitting files from multipart requests
            /// </summary>
            public string PostData
            {
                get; set;
            }

        }
        public class GetResponseBodyForInterceptionParams : IMethodParams<GetResponseBodyForInterceptionParams, GetResponseBodyForInterceptionResult>
        {
            public string GetMethod()
            {
                return "Network.getResponseBodyForInterception";

            }
            /// <summary>
            /// Identifier for the intercepted request to get body for.
            /// </summary>
            public string InterceptionId
            {
                get; set;
            }

        }
        public class GetResponseBodyForInterceptionResult
        {
            /// <summary>
            /// Response body.
            /// </summary>
            public string Body
            {
                get; set;
            }
            /// <summary>
            /// True, if content was sent as base64.
            /// </summary>
            public bool Base64Encoded
            {
                get; set;
            }

        }
        public class TakeResponseBodyForInterceptionAsStreamParams : IMethodParams<TakeResponseBodyForInterceptionAsStreamParams, TakeResponseBodyForInterceptionAsStreamResult>
        {
            public string GetMethod()
            {
                return "Network.takeResponseBodyForInterceptionAsStream";

            }
            /// <summary>
            /// </summary>
            public string InterceptionId
            {
                get; set;
            }

        }
        public class TakeResponseBodyForInterceptionAsStreamResult
        {
            /// <summary>
            /// </summary>
            public string Stream
            {
                get; set;
            }

        }
        public class ReplayXHRParams : IMethodParams<ReplayXHRParams, ReplayXHRResult>
        {
            public string GetMethod()
            {
                return "Network.replayXHR";

            }
            /// <summary>
            /// Identifier of XHR to replay.
            /// </summary>
            public string RequestId
            {
                get; set;
            }

        }
        public class ReplayXHRResult
        {

        }
        public class SearchInResponseBodyParams : IMethodParams<SearchInResponseBodyParams, SearchInResponseBodyResult>
        {
            public string GetMethod()
            {
                return "Network.searchInResponseBody";

            }
            /// <summary>
            /// Identifier of the network response to search.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// String to search for.
            /// </summary>
            public string Query
            {
                get; set;
            }
            /// <summary>
            /// If true, search is case sensitive.
            /// </summary>
            public bool? CaseSensitive
            {
                get; set;
            }
            /// <summary>
            /// If true, treats string parameter as regex.
            /// </summary>
            public bool? IsRegex
            {
                get; set;
            }

        }
        public class SearchInResponseBodyResult
        {
            /// <summary>
            /// List of search matches.
            /// </summary>
            public DebuggerDomain.SearchMatch[] Result
            {
                get; set;
            }

        }
        public class SetBlockedURLsParams : IMethodParams<SetBlockedURLsParams, SetBlockedURLsResult>
        {
            public string GetMethod()
            {
                return "Network.setBlockedURLs";

            }
            /// <summary>
            /// URL patterns to block. Wildcards ('*') are allowed.
            /// </summary>
            public string[] Urls
            {
                get; set;
            }

        }
        public class SetBlockedURLsResult
        {

        }
        public class SetBypassServiceWorkerParams : IMethodParams<SetBypassServiceWorkerParams, SetBypassServiceWorkerResult>
        {
            public string GetMethod()
            {
                return "Network.setBypassServiceWorker";

            }
            /// <summary>
            /// Bypass service worker and load from network.
            /// </summary>
            public bool Bypass
            {
                get; set;
            }

        }
        public class SetBypassServiceWorkerResult
        {

        }
        public class SetCacheDisabledParams : IMethodParams<SetCacheDisabledParams, SetCacheDisabledResult>
        {
            public string GetMethod()
            {
                return "Network.setCacheDisabled";

            }
            /// <summary>
            /// Cache disabled state.
            /// </summary>
            public bool CacheDisabled
            {
                get; set;
            }

        }
        public class SetCacheDisabledResult
        {

        }
        public class SetCookieParams : IMethodParams<SetCookieParams, SetCookieResult>
        {
            public string GetMethod()
            {
                return "Network.setCookie";

            }
            /// <summary>
            /// Cookie name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Cookie value.
            /// </summary>
            public string Value
            {
                get; set;
            }
            /// <summary>
            /// The request-URI to associate with the setting of the cookie. This value can affect the
            /// default domain, path, source port, and source scheme values of the created cookie.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// Cookie domain.
            /// </summary>
            public string? Domain
            {
                get; set;
            }
            /// <summary>
            /// Cookie path.
            /// </summary>
            public string? Path
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is secure.
            /// </summary>
            public bool? Secure
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is http-only.
            /// </summary>
            public bool? HttpOnly
            {
                get; set;
            }
            /// <summary>
            /// Cookie SameSite type.
            /// </summary>
            public NetworkDomain.CookieSameSite? SameSite
            {
                get; set;
            }
            /// <summary>
            /// Cookie expiration date, session cookie if not set
            /// </summary>
            public double? Expires
            {
                get; set;
            }
            /// <summary>
            /// Cookie Priority type.
            /// </summary>
            [Experimental]
            public NetworkDomain.CookiePriority? Priority
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is SameParty.
            /// </summary>
            [Experimental]
            public bool? SameParty
            {
                get; set;
            }
            /// <summary>
            /// Cookie source scheme type.
            /// </summary>
            [Experimental]
            public NetworkDomain.CookieSourceScheme? SourceScheme
            {
                get; set;
            }
            /// <summary>
            /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
            /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
            /// This is a temporary ability and it will be removed in the future.
            /// </summary>
            [Experimental]
            public int? SourcePort
            {
                get; set;
            }
            /// <summary>
            /// Cookie partition key. The site of the top-level URL the browser was visiting at the start
            /// of the request to the endpoint that set the cookie.
            /// If not set, the cookie will be set as not partitioned.
            /// </summary>
            [Experimental]
            public string? PartitionKey
            {
                get; set;
            }

        }
        public class SetCookieResult
        {
            /// <summary>
            /// Always set to true. If an error occurs, the response indicates protocol error.
            /// </summary>
            [Obsolete]
            public bool Success
            {
                get; set;
            }

        }
        public class SetCookiesParams : IMethodParams<SetCookiesParams, SetCookiesResult>
        {
            public string GetMethod()
            {
                return "Network.setCookies";

            }
            /// <summary>
            /// Cookies to be set.
            /// </summary>
            public NetworkDomain.CookieParam[] Cookies
            {
                get; set;
            }

        }
        public class SetCookiesResult
        {

        }
        public class SetExtraHTTPHeadersParams : IMethodParams<SetExtraHTTPHeadersParams, SetExtraHTTPHeadersResult>
        {
            public string GetMethod()
            {
                return "Network.setExtraHTTPHeaders";

            }
            /// <summary>
            /// Map with extra HTTP headers.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }

        }
        public class SetExtraHTTPHeadersResult
        {

        }
        public class SetAttachDebugStackParams : IMethodParams<SetAttachDebugStackParams, SetAttachDebugStackResult>
        {
            public string GetMethod()
            {
                return "Network.setAttachDebugStack";

            }
            /// <summary>
            /// Whether to attach a page script stack for debugging purpose.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetAttachDebugStackResult
        {

        }
        public class SetRequestInterceptionParams : IMethodParams<SetRequestInterceptionParams, SetRequestInterceptionResult>
        {
            public string GetMethod()
            {
                return "Network.setRequestInterception";

            }
            /// <summary>
            /// Requests matching any of these patterns will be forwarded and wait for the corresponding
            /// continueInterceptedRequest call.
            /// </summary>
            public NetworkDomain.RequestPattern[] Patterns
            {
                get; set;
            }

        }
        public class SetRequestInterceptionResult
        {

        }
        public class SetUserAgentOverrideParams : IMethodParams<SetUserAgentOverrideParams, SetUserAgentOverrideResult>
        {
            public string GetMethod()
            {
                return "Network.setUserAgentOverride";

            }
            /// <summary>
            /// User agent to use.
            /// </summary>
            public string UserAgent
            {
                get; set;
            }
            /// <summary>
            /// Browser langugage to emulate.
            /// </summary>
            public string? AcceptLanguage
            {
                get; set;
            }
            /// <summary>
            /// The platform navigator.platform should return.
            /// </summary>
            public string? Platform
            {
                get; set;
            }
            /// <summary>
            /// To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
            /// </summary>
            [Experimental]
            public EmulationDomain.UserAgentMetadata? UserAgentMetadata
            {
                get; set;
            }

        }
        public class SetUserAgentOverrideResult
        {

        }
        public class GetSecurityIsolationStatusParams : IMethodParams<GetSecurityIsolationStatusParams, GetSecurityIsolationStatusResult>
        {
            public string GetMethod()
            {
                return "Network.getSecurityIsolationStatus";

            }
            /// <summary>
            /// If no frameId is provided, the status of the target is provided.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }

        }
        public class GetSecurityIsolationStatusResult
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.SecurityIsolationStatus Status
            {
                get; set;
            }

        }
        public class EnableReportingApiParams : IMethodParams<EnableReportingApiParams, EnableReportingApiResult>
        {
            public string GetMethod()
            {
                return "Network.enableReportingApi";

            }
            /// <summary>
            /// Whether to enable or disable events for the Reporting API
            /// </summary>
            public bool Enable
            {
                get; set;
            }

        }
        public class EnableReportingApiResult
        {

        }
        public class LoadNetworkResourceParams : IMethodParams<LoadNetworkResourceParams, LoadNetworkResourceResult>
        {
            public string GetMethod()
            {
                return "Network.loadNetworkResource";

            }
            /// <summary>
            /// Frame id to get the resource for. Mandatory for frame targets, and
            /// should be omitted for worker targets.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }
            /// <summary>
            /// URL of the resource to get content for.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Options for the request.
            /// </summary>
            public NetworkDomain.LoadNetworkResourceOptions Options
            {
                get; set;
            }

        }
        public class LoadNetworkResourceResult
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.LoadNetworkResourcePageResult Resource
            {
                get; set;
            }

        }
        /// <summary>
        /// Resource type as it was perceived by the rendering engine.
        /// </summary>
        public enum ResourceType
        {
            [EnumValue("Document")]
            Document = 1,
            [EnumValue("Stylesheet")]
            Stylesheet = 2,
            [EnumValue("Image")]
            Image = 3,
            [EnumValue("Media")]
            Media = 4,
            [EnumValue("Font")]
            Font = 5,
            [EnumValue("Script")]
            Script = 6,
            [EnumValue("TextTrack")]
            TextTrack = 7,
            [EnumValue("XHR")]
            XHR = 8,
            [EnumValue("Fetch")]
            Fetch = 9,
            [EnumValue("Prefetch")]
            Prefetch = 10,
            [EnumValue("EventSource")]
            EventSource = 11,
            [EnumValue("WebSocket")]
            WebSocket = 12,
            [EnumValue("Manifest")]
            Manifest = 13,
            [EnumValue("SignedExchange")]
            SignedExchange = 14,
            [EnumValue("Ping")]
            Ping = 15,
            [EnumValue("CSPViolationReport")]
            CSPViolationReport = 16,
            [EnumValue("Preflight")]
            Preflight = 17,
            [EnumValue("Other")]
            Other = 18,

        }
        /// <summary>
        /// Network level fetch failure reason.
        /// </summary>
        public enum ErrorReason
        {
            [EnumValue("Failed")]
            Failed = 1,
            [EnumValue("Aborted")]
            Aborted = 2,
            [EnumValue("TimedOut")]
            TimedOut = 3,
            [EnumValue("AccessDenied")]
            AccessDenied = 4,
            [EnumValue("ConnectionClosed")]
            ConnectionClosed = 5,
            [EnumValue("ConnectionReset")]
            ConnectionReset = 6,
            [EnumValue("ConnectionRefused")]
            ConnectionRefused = 7,
            [EnumValue("ConnectionAborted")]
            ConnectionAborted = 8,
            [EnumValue("ConnectionFailed")]
            ConnectionFailed = 9,
            [EnumValue("NameNotResolved")]
            NameNotResolved = 10,
            [EnumValue("InternetDisconnected")]
            InternetDisconnected = 11,
            [EnumValue("AddressUnreachable")]
            AddressUnreachable = 12,
            [EnumValue("BlockedByClient")]
            BlockedByClient = 13,
            [EnumValue("BlockedByResponse")]
            BlockedByResponse = 14,

        }
        /// <summary>
        /// Request / response headers as keys / values of JSON object.
        /// </summary>
        public class Headers
        {

        }
        /// <summary>
        /// The underlying connection technology that the browser is supposedly using.
        /// </summary>
        public enum ConnectionType
        {
            [EnumValue("none")]
            None = 1,
            [EnumValue("cellular2g")]
            Cellular2g = 2,
            [EnumValue("cellular3g")]
            Cellular3g = 3,
            [EnumValue("cellular4g")]
            Cellular4g = 4,
            [EnumValue("bluetooth")]
            Bluetooth = 5,
            [EnumValue("ethernet")]
            Ethernet = 6,
            [EnumValue("wifi")]
            Wifi = 7,
            [EnumValue("wimax")]
            Wimax = 8,
            [EnumValue("other")]
            Other = 9,

        }
        /// <summary>
        /// Represents the cookie's 'SameSite' status:
        /// https://tools.ietf.org/html/draft-west-first-party-cookies
        /// </summary>
        public enum CookieSameSite
        {
            [EnumValue("Strict")]
            Strict = 1,
            [EnumValue("Lax")]
            Lax = 2,
            [EnumValue("None")]
            None = 3,

        }
        /// <summary>
        /// Represents the cookie's 'Priority' status:
        /// https://tools.ietf.org/html/draft-west-cookie-priority-00
        /// </summary>
        [Experimental]
        public enum CookiePriority
        {
            [EnumValue("Low")]
            Low = 1,
            [EnumValue("Medium")]
            Medium = 2,
            [EnumValue("High")]
            High = 3,

        }
        /// <summary>
        /// Represents the source scheme of the origin that originally set the cookie.
        /// A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
        /// This is a temporary ability and it will be removed in the future.
        /// </summary>
        [Experimental]
        public enum CookieSourceScheme
        {
            [EnumValue("Unset")]
            Unset = 1,
            [EnumValue("NonSecure")]
            NonSecure = 2,
            [EnumValue("Secure")]
            Secure = 3,

        }
        /// <summary>
        /// Timing information for the request.
        /// </summary>
        public class ResourceTiming
        {
            /// <summary>
            /// Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
            /// milliseconds relatively to this requestTime.
            /// </summary>
            public double RequestTime
            {
                get; set;
            }
            /// <summary>
            /// Started resolving proxy.
            /// </summary>
            public double ProxyStart
            {
                get; set;
            }
            /// <summary>
            /// Finished resolving proxy.
            /// </summary>
            public double ProxyEnd
            {
                get; set;
            }
            /// <summary>
            /// Started DNS address resolve.
            /// </summary>
            public double DnsStart
            {
                get; set;
            }
            /// <summary>
            /// Finished DNS address resolve.
            /// </summary>
            public double DnsEnd
            {
                get; set;
            }
            /// <summary>
            /// Started connecting to the remote host.
            /// </summary>
            public double ConnectStart
            {
                get; set;
            }
            /// <summary>
            /// Connected to the remote host.
            /// </summary>
            public double ConnectEnd
            {
                get; set;
            }
            /// <summary>
            /// Started SSL handshake.
            /// </summary>
            public double SslStart
            {
                get; set;
            }
            /// <summary>
            /// Finished SSL handshake.
            /// </summary>
            public double SslEnd
            {
                get; set;
            }
            /// <summary>
            /// Started running ServiceWorker.
            /// </summary>
            [Experimental]
            public double WorkerStart
            {
                get; set;
            }
            /// <summary>
            /// Finished Starting ServiceWorker.
            /// </summary>
            [Experimental]
            public double WorkerReady
            {
                get; set;
            }
            /// <summary>
            /// Started fetch event.
            /// </summary>
            [Experimental]
            public double WorkerFetchStart
            {
                get; set;
            }
            /// <summary>
            /// Settled fetch event respondWith promise.
            /// </summary>
            [Experimental]
            public double WorkerRespondWithSettled
            {
                get; set;
            }
            /// <summary>
            /// Started sending request.
            /// </summary>
            public double SendStart
            {
                get; set;
            }
            /// <summary>
            /// Finished sending request.
            /// </summary>
            public double SendEnd
            {
                get; set;
            }
            /// <summary>
            /// Time the server started pushing request.
            /// </summary>
            [Experimental]
            public double PushStart
            {
                get; set;
            }
            /// <summary>
            /// Time the server finished pushing request.
            /// </summary>
            [Experimental]
            public double PushEnd
            {
                get; set;
            }
            /// <summary>
            /// Finished receiving response headers.
            /// </summary>
            public double ReceiveHeadersEnd
            {
                get; set;
            }

        }
        /// <summary>
        /// Loading priority of a resource request.
        /// </summary>
        public enum ResourcePriority
        {
            [EnumValue("VeryLow")]
            VeryLow = 1,
            [EnumValue("Low")]
            Low = 2,
            [EnumValue("Medium")]
            Medium = 3,
            [EnumValue("High")]
            High = 4,
            [EnumValue("VeryHigh")]
            VeryHigh = 5,

        }
        /// <summary>
        /// Post data entry for HTTP request
        /// </summary>
        public class PostDataEntry
        {
            /// <summary>
            /// </summary>
            public string? Bytes
            {
                get; set;
            }

        }
        /// <summary>
        /// HTTP request data.
        /// </summary>
        public class Request
        {
            /// <summary>
            /// Request URL (without fragment).
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Fragment of the requested URL starting with hash, if present.
            /// </summary>
            public string? UrlFragment
            {
                get; set;
            }
            /// <summary>
            /// HTTP request method.
            /// </summary>
            public string Method
            {
                get; set;
            }
            /// <summary>
            /// HTTP request headers.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }
            /// <summary>
            /// HTTP POST request data.
            /// </summary>
            public string? PostData
            {
                get; set;
            }
            /// <summary>
            /// True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
            /// </summary>
            public bool? HasPostData
            {
                get; set;
            }
            /// <summary>
            /// Request body elements. This will be converted from base64 to binary
            /// </summary>
            [Experimental]
            public NetworkDomain.PostDataEntry[]? PostDataEntries
            {
                get; set;
            }
            /// <summary>
            /// The mixed content type of the request.
            /// </summary>
            public SecurityDomain.MixedContentType? MixedContentType
            {
                get; set;
            }
            /// <summary>
            /// Priority of the resource request at the time request is sent.
            /// </summary>
            public NetworkDomain.ResourcePriority InitialPriority
            {
                get; set;
            }
            /// <summary>
            /// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
            /// </summary>
            /// <value>
            /// unsafe-url,no-referrer-when-downgrade,no-referrer,origin,origin-when-cross-origin,same-origin,strict-origin,strict-origin-when-cross-origin
            /// </value>
            public string ReferrerPolicy
            {
                get; set;
            }
            /// <summary>
            /// Whether is loaded via link preload.
            /// </summary>
            public bool? IsLinkPreload
            {
                get; set;
            }
            /// <summary>
            /// Set for requests when the TrustToken API is used. Contains the parameters
            /// passed by the developer (e.g. via "fetch") as understood by the backend.
            /// </summary>
            [Experimental]
            public NetworkDomain.TrustTokenParams? TrustTokenParams
            {
                get; set;
            }
            /// <summary>
            /// True if this resource request is considered to be the 'same site' as the
            /// request correspondinfg to the main frame.
            /// </summary>
            [Experimental]
            public bool? IsSameSite
            {
                get; set;
            }

        }
        /// <summary>
        /// Details of a signed certificate timestamp (SCT).
        /// </summary>
        public class SignedCertificateTimestamp
        {
            /// <summary>
            /// Validation status.
            /// </summary>
            public string Status
            {
                get; set;
            }
            /// <summary>
            /// Origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// Log name / description.
            /// </summary>
            public string LogDescription
            {
                get; set;
            }
            /// <summary>
            /// Log ID.
            /// </summary>
            public string LogId
            {
                get; set;
            }
            /// <summary>
            /// Issuance date. Unlike TimeSinceEpoch, this contains the number of
            /// milliseconds since January 1, 1970, UTC, not the number of seconds.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Hash algorithm.
            /// </summary>
            public string HashAlgorithm
            {
                get; set;
            }
            /// <summary>
            /// Signature algorithm.
            /// </summary>
            public string SignatureAlgorithm
            {
                get; set;
            }
            /// <summary>
            /// Signature data.
            /// </summary>
            public string SignatureData
            {
                get; set;
            }

        }
        /// <summary>
        /// Security details about a request.
        /// </summary>
        public class SecurityDetails
        {
            /// <summary>
            /// Protocol name (e.g. "TLS 1.2" or "QUIC").
            /// </summary>
            public string Protocol
            {
                get; set;
            }
            /// <summary>
            /// Key Exchange used by the connection, or the empty string if not applicable.
            /// </summary>
            public string KeyExchange
            {
                get; set;
            }
            /// <summary>
            /// (EC)DH group used by the connection, if applicable.
            /// </summary>
            public string? KeyExchangeGroup
            {
                get; set;
            }
            /// <summary>
            /// Cipher name.
            /// </summary>
            public string Cipher
            {
                get; set;
            }
            /// <summary>
            /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
            /// </summary>
            public string? Mac
            {
                get; set;
            }
            /// <summary>
            /// Certificate ID value.
            /// </summary>
            public int CertificateId
            {
                get; set;
            }
            /// <summary>
            /// Certificate subject name.
            /// </summary>
            public string SubjectName
            {
                get; set;
            }
            /// <summary>
            /// Subject Alternative Name (SAN) DNS names and IP addresses.
            /// </summary>
            public string[] SanList
            {
                get; set;
            }
            /// <summary>
            /// Name of the issuing CA.
            /// </summary>
            public string Issuer
            {
                get; set;
            }
            /// <summary>
            /// Certificate valid from date.
            /// </summary>
            public double ValidFrom
            {
                get; set;
            }
            /// <summary>
            /// Certificate valid to (expiration) date
            /// </summary>
            public double ValidTo
            {
                get; set;
            }
            /// <summary>
            /// List of signed certificate timestamps (SCTs).
            /// </summary>
            public NetworkDomain.SignedCertificateTimestamp[] SignedCertificateTimestampList
            {
                get; set;
            }
            /// <summary>
            /// Whether the request complied with Certificate Transparency policy
            /// </summary>
            public NetworkDomain.CertificateTransparencyCompliance CertificateTransparencyCompliance
            {
                get; set;
            }
            /// <summary>
            /// The signature algorithm used by the server in the TLS server signature,
            /// represented as a TLS SignatureScheme code point. Omitted if not
            /// applicable or not known.
            /// </summary>
            public int? ServerSignatureAlgorithm
            {
                get; set;
            }
            /// <summary>
            /// Whether the connection used Encrypted ClientHello
            /// </summary>
            public bool EncryptedClientHello
            {
                get; set;
            }

        }
        /// <summary>
        /// Whether the request complied with Certificate Transparency policy.
        /// </summary>
        public enum CertificateTransparencyCompliance
        {
            [EnumValue("unknown")]
            Unknown = 1,
            [EnumValue("not-compliant")]
            NotCompliant = 2,
            [EnumValue("compliant")]
            Compliant = 3,

        }
        /// <summary>
        /// The reason why request was blocked.
        /// </summary>
        public enum BlockedReason
        {
            [EnumValue("other")]
            Other = 1,
            [EnumValue("csp")]
            Csp = 2,
            [EnumValue("mixed-content")]
            MixedContent = 3,
            [EnumValue("origin")]
            Origin = 4,
            [EnumValue("inspector")]
            Inspector = 5,
            [EnumValue("subresource-filter")]
            SubresourceFilter = 6,
            [EnumValue("content-type")]
            ContentType = 7,
            [EnumValue("coep-frame-resource-needs-coep-header")]
            CoepFrameResourceNeedsCoepHeader = 8,
            [EnumValue("coop-sandboxed-iframe-cannot-navigate-to-coop-page")]
            CoopSandboxedIframeCannotNavigateToCoopPage = 9,
            [EnumValue("corp-not-same-origin")]
            CorpNotSameOrigin = 10,
            [EnumValue("corp-not-same-origin-after-defaulted-to-same-origin-by-coep")]
            CorpNotSameOriginAfterDefaultedToSameOriginByCoep = 11,
            [EnumValue("corp-not-same-site")]
            CorpNotSameSite = 12,

        }
        /// <summary>
        /// The reason why request was blocked.
        /// </summary>
        public enum CorsError
        {
            [EnumValue("DisallowedByMode")]
            DisallowedByMode = 1,
            [EnumValue("InvalidResponse")]
            InvalidResponse = 2,
            [EnumValue("WildcardOriginNotAllowed")]
            WildcardOriginNotAllowed = 3,
            [EnumValue("MissingAllowOriginHeader")]
            MissingAllowOriginHeader = 4,
            [EnumValue("MultipleAllowOriginValues")]
            MultipleAllowOriginValues = 5,
            [EnumValue("InvalidAllowOriginValue")]
            InvalidAllowOriginValue = 6,
            [EnumValue("AllowOriginMismatch")]
            AllowOriginMismatch = 7,
            [EnumValue("InvalidAllowCredentials")]
            InvalidAllowCredentials = 8,
            [EnumValue("CorsDisabledScheme")]
            CorsDisabledScheme = 9,
            [EnumValue("PreflightInvalidStatus")]
            PreflightInvalidStatus = 10,
            [EnumValue("PreflightDisallowedRedirect")]
            PreflightDisallowedRedirect = 11,
            [EnumValue("PreflightWildcardOriginNotAllowed")]
            PreflightWildcardOriginNotAllowed = 12,
            [EnumValue("PreflightMissingAllowOriginHeader")]
            PreflightMissingAllowOriginHeader = 13,
            [EnumValue("PreflightMultipleAllowOriginValues")]
            PreflightMultipleAllowOriginValues = 14,
            [EnumValue("PreflightInvalidAllowOriginValue")]
            PreflightInvalidAllowOriginValue = 15,
            [EnumValue("PreflightAllowOriginMismatch")]
            PreflightAllowOriginMismatch = 16,
            [EnumValue("PreflightInvalidAllowCredentials")]
            PreflightInvalidAllowCredentials = 17,
            [EnumValue("PreflightMissingAllowExternal")]
            PreflightMissingAllowExternal = 18,
            [EnumValue("PreflightInvalidAllowExternal")]
            PreflightInvalidAllowExternal = 19,
            [EnumValue("PreflightMissingAllowPrivateNetwork")]
            PreflightMissingAllowPrivateNetwork = 20,
            [EnumValue("PreflightInvalidAllowPrivateNetwork")]
            PreflightInvalidAllowPrivateNetwork = 21,
            [EnumValue("InvalidAllowMethodsPreflightResponse")]
            InvalidAllowMethodsPreflightResponse = 22,
            [EnumValue("InvalidAllowHeadersPreflightResponse")]
            InvalidAllowHeadersPreflightResponse = 23,
            [EnumValue("MethodDisallowedByPreflightResponse")]
            MethodDisallowedByPreflightResponse = 24,
            [EnumValue("HeaderDisallowedByPreflightResponse")]
            HeaderDisallowedByPreflightResponse = 25,
            [EnumValue("RedirectContainsCredentials")]
            RedirectContainsCredentials = 26,
            [EnumValue("InsecurePrivateNetwork")]
            InsecurePrivateNetwork = 27,
            [EnumValue("InvalidPrivateNetworkAccess")]
            InvalidPrivateNetworkAccess = 28,
            [EnumValue("UnexpectedPrivateNetworkAccess")]
            UnexpectedPrivateNetworkAccess = 29,
            [EnumValue("NoCorsRedirectModeNotFollow")]
            NoCorsRedirectModeNotFollow = 30,

        }
        /// <summary>
        /// </summary>
        public class CorsErrorStatus
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.CorsError CorsError
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string FailedParameter
            {
                get; set;
            }

        }
        /// <summary>
        /// Source of serviceworker response.
        /// </summary>
        public enum ServiceWorkerResponseSource
        {
            [EnumValue("cache-storage")]
            CacheStorage = 1,
            [EnumValue("http-cache")]
            HttpCache = 2,
            [EnumValue("fallback-code")]
            FallbackCode = 3,
            [EnumValue("network")]
            Network = 4,

        }
        /// <summary>
        /// Determines what type of Trust Token operation is executed and
        /// depending on the type, some additional parameters. The values
        /// are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
        /// </summary>
        [Experimental]
        public class TrustTokenParams
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.TrustTokenOperationType Type
            {
                get; set;
            }
            /// <summary>
            /// Only set for "token-redemption" type and determine whether
            /// to request a fresh SRR or use a still valid cached SRR.
            /// </summary>
            /// <value>
            /// UseCached,Refresh
            /// </value>
            public string RefreshPolicy
            {
                get; set;
            }
            /// <summary>
            /// Origins of issuers from whom to request tokens or redemption
            /// records.
            /// </summary>
            public string[]? Issuers
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum TrustTokenOperationType
        {
            [EnumValue("Issuance")]
            Issuance = 1,
            [EnumValue("Redemption")]
            Redemption = 2,
            [EnumValue("Signing")]
            Signing = 3,

        }
        /// <summary>
        /// HTTP response data.
        /// </summary>
        public class Response
        {
            /// <summary>
            /// Response URL. This URL can be different from CachedResource.url in case of redirect.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// HTTP response status code.
            /// </summary>
            public int Status
            {
                get; set;
            }
            /// <summary>
            /// HTTP response status text.
            /// </summary>
            public string StatusText
            {
                get; set;
            }
            /// <summary>
            /// HTTP response headers.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }
            /// <summary>
            /// HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
            /// </summary>
            [Obsolete]
            public string? HeadersText
            {
                get; set;
            }
            /// <summary>
            /// Resource mimeType as determined by the browser.
            /// </summary>
            public string MimeType
            {
                get; set;
            }
            /// <summary>
            /// Refined HTTP request headers that were actually transmitted over the network.
            /// </summary>
            public NetworkDomain.Headers? RequestHeaders
            {
                get; set;
            }
            /// <summary>
            /// HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
            /// </summary>
            [Obsolete]
            public string? RequestHeadersText
            {
                get; set;
            }
            /// <summary>
            /// Specifies whether physical connection was actually reused for this request.
            /// </summary>
            public bool ConnectionReused
            {
                get; set;
            }
            /// <summary>
            /// Physical connection id that was actually used for this request.
            /// </summary>
            public double ConnectionId
            {
                get; set;
            }
            /// <summary>
            /// Remote IP address.
            /// </summary>
            public string? RemoteIPAddress
            {
                get; set;
            }
            /// <summary>
            /// Remote port.
            /// </summary>
            public int? RemotePort
            {
                get; set;
            }
            /// <summary>
            /// Specifies that the request was served from the disk cache.
            /// </summary>
            public bool? FromDiskCache
            {
                get; set;
            }
            /// <summary>
            /// Specifies that the request was served from the ServiceWorker.
            /// </summary>
            public bool? FromServiceWorker
            {
                get; set;
            }
            /// <summary>
            /// Specifies that the request was served from the prefetch cache.
            /// </summary>
            public bool? FromPrefetchCache
            {
                get; set;
            }
            /// <summary>
            /// Total number of bytes received for this request so far.
            /// </summary>
            public double EncodedDataLength
            {
                get; set;
            }
            /// <summary>
            /// Timing information for the given request.
            /// </summary>
            public NetworkDomain.ResourceTiming? Timing
            {
                get; set;
            }
            /// <summary>
            /// Response source of response from ServiceWorker.
            /// </summary>
            public NetworkDomain.ServiceWorkerResponseSource? ServiceWorkerResponseSource
            {
                get; set;
            }
            /// <summary>
            /// The time at which the returned response was generated.
            /// </summary>
            public double? ResponseTime
            {
                get; set;
            }
            /// <summary>
            /// Cache Storage Cache Name.
            /// </summary>
            public string? CacheStorageCacheName
            {
                get; set;
            }
            /// <summary>
            /// Protocol used to fetch this request.
            /// </summary>
            public string? Protocol
            {
                get; set;
            }
            /// <summary>
            /// Security state of the request resource.
            /// </summary>
            public SecurityDomain.SecurityState SecurityState
            {
                get; set;
            }
            /// <summary>
            /// Security details for the request.
            /// </summary>
            public NetworkDomain.SecurityDetails? SecurityDetails
            {
                get; set;
            }

        }
        /// <summary>
        /// WebSocket request data.
        /// </summary>
        public class WebSocketRequest
        {
            /// <summary>
            /// HTTP request headers.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }

        }
        /// <summary>
        /// WebSocket response data.
        /// </summary>
        public class WebSocketResponse
        {
            /// <summary>
            /// HTTP response status code.
            /// </summary>
            public int Status
            {
                get; set;
            }
            /// <summary>
            /// HTTP response status text.
            /// </summary>
            public string StatusText
            {
                get; set;
            }
            /// <summary>
            /// HTTP response headers.
            /// </summary>
            public NetworkDomain.Headers Headers
            {
                get; set;
            }
            /// <summary>
            /// HTTP response headers text.
            /// </summary>
            public string? HeadersText
            {
                get; set;
            }
            /// <summary>
            /// HTTP request headers.
            /// </summary>
            public NetworkDomain.Headers? RequestHeaders
            {
                get; set;
            }
            /// <summary>
            /// HTTP request headers text.
            /// </summary>
            public string? RequestHeadersText
            {
                get; set;
            }

        }
        /// <summary>
        /// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
        /// </summary>
        public class WebSocketFrame
        {
            /// <summary>
            /// WebSocket message opcode.
            /// </summary>
            public double Opcode
            {
                get; set;
            }
            /// <summary>
            /// WebSocket message mask.
            /// </summary>
            public bool Mask
            {
                get; set;
            }
            /// <summary>
            /// WebSocket message payload data.
            /// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
            /// If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
            /// </summary>
            public string PayloadData
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the cached resource.
        /// </summary>
        public class CachedResource
        {
            /// <summary>
            /// Resource URL. This is the url of the original network request.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Type of this resource.
            /// </summary>
            public NetworkDomain.ResourceType Type
            {
                get; set;
            }
            /// <summary>
            /// Cached response data.
            /// </summary>
            public NetworkDomain.Response? Response
            {
                get; set;
            }
            /// <summary>
            /// Cached response body size.
            /// </summary>
            public double BodySize
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the request initiator.
        /// </summary>
        public class Initiator
        {
            /// <summary>
            /// Type of this initiator.
            /// </summary>
            /// <value>
            /// parser,script,preload,SignedExchange,preflight,other
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Initiator JavaScript stack trace, set for Script only.
            /// </summary>
            public RuntimeDomain.StackTrace? Stack
            {
                get; set;
            }
            /// <summary>
            /// Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// Initiator line number, set for Parser type or for Script type (when script is importing
            /// module) (0-based).
            /// </summary>
            public double? LineNumber
            {
                get; set;
            }
            /// <summary>
            /// Initiator column number, set for Parser type or for Script type (when script is importing
            /// module) (0-based).
            /// </summary>
            public double? ColumnNumber
            {
                get; set;
            }
            /// <summary>
            /// Set if another request triggered this request (e.g. preflight).
            /// </summary>
            public string? RequestId
            {
                get; set;
            }

        }
        /// <summary>
        /// Cookie object
        /// </summary>
        public class Cookie
        {
            /// <summary>
            /// Cookie name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Cookie value.
            /// </summary>
            public string Value
            {
                get; set;
            }
            /// <summary>
            /// Cookie domain.
            /// </summary>
            public string Domain
            {
                get; set;
            }
            /// <summary>
            /// Cookie path.
            /// </summary>
            public string Path
            {
                get; set;
            }
            /// <summary>
            /// Cookie expiration date as the number of seconds since the UNIX epoch.
            /// </summary>
            public double Expires
            {
                get; set;
            }
            /// <summary>
            /// Cookie size.
            /// </summary>
            public int Size
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is http-only.
            /// </summary>
            public bool HttpOnly
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is secure.
            /// </summary>
            public bool Secure
            {
                get; set;
            }
            /// <summary>
            /// True in case of session cookie.
            /// </summary>
            public bool Session
            {
                get; set;
            }
            /// <summary>
            /// Cookie SameSite type.
            /// </summary>
            public NetworkDomain.CookieSameSite? SameSite
            {
                get; set;
            }
            /// <summary>
            /// Cookie Priority
            /// </summary>
            [Experimental]
            public NetworkDomain.CookiePriority Priority
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is SameParty.
            /// </summary>
            [Experimental]
            public bool SameParty
            {
                get; set;
            }
            /// <summary>
            /// Cookie source scheme type.
            /// </summary>
            [Experimental]
            public NetworkDomain.CookieSourceScheme SourceScheme
            {
                get; set;
            }
            /// <summary>
            /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
            /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
            /// This is a temporary ability and it will be removed in the future.
            /// </summary>
            [Experimental]
            public int SourcePort
            {
                get; set;
            }
            /// <summary>
            /// Cookie partition key. The site of the top-level URL the browser was visiting at the start
            /// of the request to the endpoint that set the cookie.
            /// </summary>
            [Experimental]
            public string? PartitionKey
            {
                get; set;
            }
            /// <summary>
            /// True if cookie partition key is opaque.
            /// </summary>
            [Experimental]
            public bool? PartitionKeyOpaque
            {
                get; set;
            }

        }
        /// <summary>
        /// Types of reasons why a cookie may not be stored from a response.
        /// </summary>
        [Experimental]
        public enum SetCookieBlockedReason
        {
            [EnumValue("SecureOnly")]
            SecureOnly = 1,
            [EnumValue("SameSiteStrict")]
            SameSiteStrict = 2,
            [EnumValue("SameSiteLax")]
            SameSiteLax = 3,
            [EnumValue("SameSiteUnspecifiedTreatedAsLax")]
            SameSiteUnspecifiedTreatedAsLax = 4,
            [EnumValue("SameSiteNoneInsecure")]
            SameSiteNoneInsecure = 5,
            [EnumValue("UserPreferences")]
            UserPreferences = 6,
            [EnumValue("SyntaxError")]
            SyntaxError = 7,
            [EnumValue("SchemeNotSupported")]
            SchemeNotSupported = 8,
            [EnumValue("OverwriteSecure")]
            OverwriteSecure = 9,
            [EnumValue("InvalidDomain")]
            InvalidDomain = 10,
            [EnumValue("InvalidPrefix")]
            InvalidPrefix = 11,
            [EnumValue("UnknownError")]
            UnknownError = 12,
            [EnumValue("SchemefulSameSiteStrict")]
            SchemefulSameSiteStrict = 13,
            [EnumValue("SchemefulSameSiteLax")]
            SchemefulSameSiteLax = 14,
            [EnumValue("SchemefulSameSiteUnspecifiedTreatedAsLax")]
            SchemefulSameSiteUnspecifiedTreatedAsLax = 15,
            [EnumValue("SamePartyFromCrossPartyContext")]
            SamePartyFromCrossPartyContext = 16,
            [EnumValue("SamePartyConflictsWithOtherAttributes")]
            SamePartyConflictsWithOtherAttributes = 17,
            [EnumValue("NameValuePairExceedsMaxSize")]
            NameValuePairExceedsMaxSize = 18,

        }
        /// <summary>
        /// Types of reasons why a cookie may not be sent with a request.
        /// </summary>
        [Experimental]
        public enum CookieBlockedReason
        {
            [EnumValue("SecureOnly")]
            SecureOnly = 1,
            [EnumValue("NotOnPath")]
            NotOnPath = 2,
            [EnumValue("DomainMismatch")]
            DomainMismatch = 3,
            [EnumValue("SameSiteStrict")]
            SameSiteStrict = 4,
            [EnumValue("SameSiteLax")]
            SameSiteLax = 5,
            [EnumValue("SameSiteUnspecifiedTreatedAsLax")]
            SameSiteUnspecifiedTreatedAsLax = 6,
            [EnumValue("SameSiteNoneInsecure")]
            SameSiteNoneInsecure = 7,
            [EnumValue("UserPreferences")]
            UserPreferences = 8,
            [EnumValue("UnknownError")]
            UnknownError = 9,
            [EnumValue("SchemefulSameSiteStrict")]
            SchemefulSameSiteStrict = 10,
            [EnumValue("SchemefulSameSiteLax")]
            SchemefulSameSiteLax = 11,
            [EnumValue("SchemefulSameSiteUnspecifiedTreatedAsLax")]
            SchemefulSameSiteUnspecifiedTreatedAsLax = 12,
            [EnumValue("SamePartyFromCrossPartyContext")]
            SamePartyFromCrossPartyContext = 13,
            [EnumValue("NameValuePairExceedsMaxSize")]
            NameValuePairExceedsMaxSize = 14,

        }
        /// <summary>
        /// A cookie which was not stored from a response with the corresponding reason.
        /// </summary>
        [Experimental]
        public class BlockedSetCookieWithReason
        {
            /// <summary>
            /// The reason(s) this cookie was blocked.
            /// </summary>
            public NetworkDomain.SetCookieBlockedReason[] BlockedReasons
            {
                get; set;
            }
            /// <summary>
            /// The string representing this individual cookie as it would appear in the header.
            /// This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
            /// </summary>
            public string CookieLine
            {
                get; set;
            }
            /// <summary>
            /// The cookie object which represents the cookie which was not stored. It is optional because
            /// sometimes complete cookie information is not available, such as in the case of parsing
            /// errors.
            /// </summary>
            public NetworkDomain.Cookie? Cookie
            {
                get; set;
            }

        }
        /// <summary>
        /// A cookie with was not sent with a request with the corresponding reason.
        /// </summary>
        [Experimental]
        public class BlockedCookieWithReason
        {
            /// <summary>
            /// The reason(s) the cookie was blocked.
            /// </summary>
            public NetworkDomain.CookieBlockedReason[] BlockedReasons
            {
                get; set;
            }
            /// <summary>
            /// The cookie object representing the cookie which was not sent.
            /// </summary>
            public NetworkDomain.Cookie Cookie
            {
                get; set;
            }

        }
        /// <summary>
        /// Cookie parameter object
        /// </summary>
        public class CookieParam
        {
            /// <summary>
            /// Cookie name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Cookie value.
            /// </summary>
            public string Value
            {
                get; set;
            }
            /// <summary>
            /// The request-URI to associate with the setting of the cookie. This value can affect the
            /// default domain, path, source port, and source scheme values of the created cookie.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// Cookie domain.
            /// </summary>
            public string? Domain
            {
                get; set;
            }
            /// <summary>
            /// Cookie path.
            /// </summary>
            public string? Path
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is secure.
            /// </summary>
            public bool? Secure
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is http-only.
            /// </summary>
            public bool? HttpOnly
            {
                get; set;
            }
            /// <summary>
            /// Cookie SameSite type.
            /// </summary>
            public NetworkDomain.CookieSameSite? SameSite
            {
                get; set;
            }
            /// <summary>
            /// Cookie expiration date, session cookie if not set
            /// </summary>
            public double? Expires
            {
                get; set;
            }
            /// <summary>
            /// Cookie Priority.
            /// </summary>
            [Experimental]
            public NetworkDomain.CookiePriority? Priority
            {
                get; set;
            }
            /// <summary>
            /// True if cookie is SameParty.
            /// </summary>
            [Experimental]
            public bool? SameParty
            {
                get; set;
            }
            /// <summary>
            /// Cookie source scheme type.
            /// </summary>
            [Experimental]
            public NetworkDomain.CookieSourceScheme? SourceScheme
            {
                get; set;
            }
            /// <summary>
            /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
            /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
            /// This is a temporary ability and it will be removed in the future.
            /// </summary>
            [Experimental]
            public int? SourcePort
            {
                get; set;
            }
            /// <summary>
            /// Cookie partition key. The site of the top-level URL the browser was visiting at the start
            /// of the request to the endpoint that set the cookie.
            /// If not set, the cookie will be set as not partitioned.
            /// </summary>
            [Experimental]
            public string? PartitionKey
            {
                get; set;
            }

        }
        /// <summary>
        /// Authorization challenge for HTTP status code 401 or 407.
        /// </summary>
        [Experimental]
        public class AuthChallenge
        {
            /// <summary>
            /// Source of the authentication challenge.
            /// </summary>
            /// <value>
            /// Server,Proxy
            /// </value>
            public string? Source
            {
                get; set;
            }
            /// <summary>
            /// Origin of the challenger.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// The authentication scheme used, such as basic or digest
            /// </summary>
            public string Scheme
            {
                get; set;
            }
            /// <summary>
            /// The realm of the challenge. May be empty.
            /// </summary>
            public string Realm
            {
                get; set;
            }

        }
        /// <summary>
        /// Response to an AuthChallenge.
        /// </summary>
        [Experimental]
        public class AuthChallengeResponse
        {
            /// <summary>
            /// The decision on what to do in response to the authorization challenge.  Default means
            /// deferring to the default behavior of the net stack, which will likely either the Cancel
            /// authentication or display a popup dialog box.
            /// </summary>
            /// <value>
            /// Default,CancelAuth,ProvideCredentials
            /// </value>
            public string Response
            {
                get; set;
            }
            /// <summary>
            /// The username to provide, possibly empty. Should only be set if response is
            /// ProvideCredentials.
            /// </summary>
            public string? Username
            {
                get; set;
            }
            /// <summary>
            /// The password to provide, possibly empty. Should only be set if response is
            /// ProvideCredentials.
            /// </summary>
            public string? Password
            {
                get; set;
            }

        }
        /// <summary>
        /// Stages of the interception to begin intercepting. Request will intercept before the request is
        /// sent. Response will intercept after the response is received.
        /// </summary>
        [Experimental]
        public enum InterceptionStage
        {
            [EnumValue("Request")]
            Request = 1,
            [EnumValue("HeadersReceived")]
            HeadersReceived = 2,

        }
        /// <summary>
        /// Request pattern for interception.
        /// </summary>
        [Experimental]
        public class RequestPattern
        {
            /// <summary>
            /// Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
            /// backslash. Omitting is equivalent to `"*"`.
            /// </summary>
            public string? UrlPattern
            {
                get; set;
            }
            /// <summary>
            /// If set, only requests for matching resource types will be intercepted.
            /// </summary>
            public NetworkDomain.ResourceType? ResourceType
            {
                get; set;
            }
            /// <summary>
            /// Stage at which to begin intercepting requests. Default is Request.
            /// </summary>
            public NetworkDomain.InterceptionStage? InterceptionStage
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about a signed exchange signature.
        /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
        /// </summary>
        [Experimental]
        public class SignedExchangeSignature
        {
            /// <summary>
            /// Signed exchange signature label.
            /// </summary>
            public string Label
            {
                get; set;
            }
            /// <summary>
            /// The hex string of signed exchange signature.
            /// </summary>
            public string Signature
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange signature integrity.
            /// </summary>
            public string Integrity
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange signature cert Url.
            /// </summary>
            public string? CertUrl
            {
                get; set;
            }
            /// <summary>
            /// The hex string of signed exchange signature cert sha256.
            /// </summary>
            public string? CertSha256
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange signature validity Url.
            /// </summary>
            public string ValidityUrl
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange signature date.
            /// </summary>
            public int Date
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange signature expires.
            /// </summary>
            public int Expires
            {
                get; set;
            }
            /// <summary>
            /// The encoded certificates.
            /// </summary>
            public string[]? Certificates
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about a signed exchange header.
        /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
        /// </summary>
        [Experimental]
        public class SignedExchangeHeader
        {
            /// <summary>
            /// Signed exchange request URL.
            /// </summary>
            public string RequestUrl
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange response code.
            /// </summary>
            public int ResponseCode
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange response headers.
            /// </summary>
            public NetworkDomain.Headers ResponseHeaders
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange response signature.
            /// </summary>
            public NetworkDomain.SignedExchangeSignature[] Signatures
            {
                get; set;
            }
            /// <summary>
            /// Signed exchange header integrity hash in the form of "sha256-<base64-hash-value>".
            /// </summary>
            public string HeaderIntegrity
            {
                get; set;
            }

        }
        /// <summary>
        /// Field type for a signed exchange related error.
        /// </summary>
        [Experimental]
        public enum SignedExchangeErrorField
        {
            [EnumValue("signatureSig")]
            SignatureSig = 1,
            [EnumValue("signatureIntegrity")]
            SignatureIntegrity = 2,
            [EnumValue("signatureCertUrl")]
            SignatureCertUrl = 3,
            [EnumValue("signatureCertSha256")]
            SignatureCertSha256 = 4,
            [EnumValue("signatureValidityUrl")]
            SignatureValidityUrl = 5,
            [EnumValue("signatureTimestamps")]
            SignatureTimestamps = 6,

        }
        /// <summary>
        /// Information about a signed exchange response.
        /// </summary>
        [Experimental]
        public class SignedExchangeError
        {
            /// <summary>
            /// Error message.
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// The index of the signature which caused the error.
            /// </summary>
            public int? SignatureIndex
            {
                get; set;
            }
            /// <summary>
            /// The field which caused the error.
            /// </summary>
            public NetworkDomain.SignedExchangeErrorField? ErrorField
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about a signed exchange response.
        /// </summary>
        [Experimental]
        public class SignedExchangeInfo
        {
            /// <summary>
            /// The outer response of signed HTTP exchange which was received from network.
            /// </summary>
            public NetworkDomain.Response OuterResponse
            {
                get; set;
            }
            /// <summary>
            /// Information about the signed exchange header.
            /// </summary>
            public NetworkDomain.SignedExchangeHeader? Header
            {
                get; set;
            }
            /// <summary>
            /// Security details for the signed exchange header.
            /// </summary>
            public NetworkDomain.SecurityDetails? SecurityDetails
            {
                get; set;
            }
            /// <summary>
            /// Errors occurred while handling the signed exchagne.
            /// </summary>
            public NetworkDomain.SignedExchangeError[]? Errors
            {
                get; set;
            }

        }
        /// <summary>
        /// List of content encodings supported by the backend.
        /// </summary>
        [Experimental]
        public enum ContentEncoding
        {
            [EnumValue("deflate")]
            Deflate = 1,
            [EnumValue("gzip")]
            Gzip = 2,
            [EnumValue("br")]
            Br = 3,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum PrivateNetworkRequestPolicy
        {
            [EnumValue("Allow")]
            Allow = 1,
            [EnumValue("BlockFromInsecureToMorePrivate")]
            BlockFromInsecureToMorePrivate = 2,
            [EnumValue("WarnFromInsecureToMorePrivate")]
            WarnFromInsecureToMorePrivate = 3,
            [EnumValue("PreflightBlock")]
            PreflightBlock = 4,
            [EnumValue("PreflightWarn")]
            PreflightWarn = 5,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum IPAddressSpace
        {
            [EnumValue("Local")]
            Local = 1,
            [EnumValue("Private")]
            Private = 2,
            [EnumValue("Public")]
            Public = 3,
            [EnumValue("Unknown")]
            Unknown = 4,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class ConnectTiming
        {
            /// <summary>
            /// Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
            /// milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for
            /// the same request (but not for redirected requests).
            /// </summary>
            public double RequestTime
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class ClientSecurityState
        {
            /// <summary>
            /// </summary>
            public bool InitiatorIsSecureContext
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.IPAddressSpace InitiatorIPAddressSpace
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.PrivateNetworkRequestPolicy PrivateNetworkRequestPolicy
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum CrossOriginOpenerPolicyValue
        {
            [EnumValue("SameOrigin")]
            SameOrigin = 1,
            [EnumValue("SameOriginAllowPopups")]
            SameOriginAllowPopups = 2,
            [EnumValue("RestrictProperties")]
            RestrictProperties = 3,
            [EnumValue("UnsafeNone")]
            UnsafeNone = 4,
            [EnumValue("SameOriginPlusCoep")]
            SameOriginPlusCoep = 5,
            [EnumValue("RestrictPropertiesPlusCoep")]
            RestrictPropertiesPlusCoep = 6,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class CrossOriginOpenerPolicyStatus
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.CrossOriginOpenerPolicyValue Value
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.CrossOriginOpenerPolicyValue ReportOnlyValue
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? ReportingEndpoint
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? ReportOnlyReportingEndpoint
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum CrossOriginEmbedderPolicyValue
        {
            [EnumValue("None")]
            None = 1,
            [EnumValue("Credentialless")]
            Credentialless = 2,
            [EnumValue("RequireCorp")]
            RequireCorp = 3,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class CrossOriginEmbedderPolicyStatus
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.CrossOriginEmbedderPolicyValue Value
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.CrossOriginEmbedderPolicyValue ReportOnlyValue
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? ReportingEndpoint
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? ReportOnlyReportingEndpoint
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class SecurityIsolationStatus
        {
            /// <summary>
            /// </summary>
            public NetworkDomain.CrossOriginOpenerPolicyStatus? Coop
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.CrossOriginEmbedderPolicyStatus? Coep
            {
                get; set;
            }

        }
        /// <summary>
        /// The status of a Reporting API report.
        /// </summary>
        [Experimental]
        public enum ReportStatus
        {
            [EnumValue("Queued")]
            Queued = 1,
            [EnumValue("Pending")]
            Pending = 2,
            [EnumValue("MarkedForRemoval")]
            MarkedForRemoval = 3,
            [EnumValue("Success")]
            Success = 4,

        }
        /// <summary>
        /// An object representing a report generated by the Reporting API.
        /// </summary>
        [Experimental]
        public class ReportingApiReport
        {
            /// <summary>
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// The URL of the document that triggered the report.
            /// </summary>
            public string InitiatorUrl
            {
                get; set;
            }
            /// <summary>
            /// The name of the endpoint group that should be used to deliver the report.
            /// </summary>
            public string Destination
            {
                get; set;
            }
            /// <summary>
            /// The type of the report (specifies the set of data that is contained in the report body).
            /// </summary>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// When the report was generated.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// How many uploads deep the related request was.
            /// </summary>
            public int Depth
            {
                get; set;
            }
            /// <summary>
            /// The number of delivery attempts made so far, not including an active attempt.
            /// </summary>
            public int CompletedAttempts
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public object Body
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public NetworkDomain.ReportStatus Status
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class ReportingApiEndpoint
        {
            /// <summary>
            /// The URL of the endpoint to which reports may be delivered.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Name of the endpoint group.
            /// </summary>
            public string GroupName
            {
                get; set;
            }

        }
        /// <summary>
        /// An object providing the result of a network resource load.
        /// </summary>
        [Experimental]
        public class LoadNetworkResourcePageResult
        {
            /// <summary>
            /// </summary>
            public bool Success
            {
                get; set;
            }
            /// <summary>
            /// Optional values used for error reporting.
            /// </summary>
            public double? NetError
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? NetErrorName
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? HttpStatusCode
            {
                get; set;
            }
            /// <summary>
            /// If successful, one of the following two fields holds the result.
            /// </summary>
            public string? Stream
            {
                get; set;
            }
            /// <summary>
            /// Response headers.
            /// </summary>
            public NetworkDomain.Headers? Headers
            {
                get; set;
            }

        }
        /// <summary>
        /// An options object that may be extended later to better support CORS,
        /// CORB and streaming.
        /// </summary>
        [Experimental]
        public class LoadNetworkResourceOptions
        {
            /// <summary>
            /// </summary>
            public bool DisableCache
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IncludeCredentials
            {
                get; set;
            }

        }

    }
    public class OverlayDomain : BaseDomain
    {
        public OverlayDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Overlay";

            }

        }
        /// <summary>
        /// Fired when the node should be inspected. This happens after call to `setInspectMode` or when
        /// user manually inspects an element.
        /// </summary>
        public event EventHandler<InspectNodeRequestedParams>? InspectNodeRequested;
        /// <summary>
        /// Fired when the node should be highlighted. This happens after call to `setInspectMode`.
        /// </summary>
        public event EventHandler<NodeHighlightRequestedParams>? NodeHighlightRequested;
        /// <summary>
        /// Fired when user asks to capture screenshot of some area on the page.
        /// </summary>
        public event EventHandler<ScreenshotRequestedParams>? ScreenshotRequested;
        /// <summary>
        /// Fired when user cancels the inspect mode.
        /// </summary>
        public event EventHandler<InspectModeCanceledParams>? InspectModeCanceled;
        /// <summary>
        /// Disables domain notifications.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables domain notifications.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// For testing.
        /// </summary>
        public async ValueTask<GetHighlightObjectForTestResult> GetHighlightObjectForTestAsync(GetHighlightObjectForTestParams getHighlightObjectForTestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getHighlightObjectForTestParams, cancellationToken);

        }
        /// <summary>
        /// For Persistent Grid testing.
        /// </summary>
        public async ValueTask<GetGridHighlightObjectsForTestResult> GetGridHighlightObjectsForTestAsync(GetGridHighlightObjectsForTestParams getGridHighlightObjectsForTestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getGridHighlightObjectsForTestParams, cancellationToken);

        }
        /// <summary>
        /// For Source Order Viewer testing.
        /// </summary>
        public async ValueTask<GetSourceOrderHighlightObjectForTestResult> GetSourceOrderHighlightObjectForTestAsync(GetSourceOrderHighlightObjectForTestParams getSourceOrderHighlightObjectForTestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getSourceOrderHighlightObjectForTestParams, cancellationToken);

        }
        /// <summary>
        /// Hides any highlight.
        /// </summary>
        public async ValueTask<HideHighlightResult> HideHighlightAsync(HideHighlightParams hideHighlightParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(hideHighlightParams, cancellationToken);

        }
        /// <summary>
        /// Highlights owner element of the frame with given id.
        /// Deprecated: Doesn't work reliablity and cannot be fixed due to process
        /// separatation (the owner node might be in a different process). Determine
        /// the owner node in the client and use highlightNode.
        /// </summary>
        [Obsolete]
        public async ValueTask<HighlightFrameResult> HighlightFrameAsync(HighlightFrameParams highlightFrameParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightFrameParams, cancellationToken);

        }
        /// <summary>
        /// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
        /// objectId must be specified.
        /// </summary>
        public async ValueTask<HighlightNodeResult> HighlightNodeAsync(HighlightNodeParams highlightNodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightNodeParams, cancellationToken);

        }
        /// <summary>
        /// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
        /// </summary>
        public async ValueTask<HighlightQuadResult> HighlightQuadAsync(HighlightQuadParams highlightQuadParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightQuadParams, cancellationToken);

        }
        /// <summary>
        /// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
        /// </summary>
        public async ValueTask<HighlightRectResult> HighlightRectAsync(HighlightRectParams highlightRectParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightRectParams, cancellationToken);

        }
        /// <summary>
        /// Highlights the source order of the children of the DOM node with given id or with the given
        /// JavaScript object wrapper. Either nodeId or objectId must be specified.
        /// </summary>
        public async ValueTask<HighlightSourceOrderResult> HighlightSourceOrderAsync(HighlightSourceOrderParams highlightSourceOrderParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(highlightSourceOrderParams, cancellationToken);

        }
        /// <summary>
        /// Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
        /// Backend then generates 'inspectNodeRequested' event upon element selection.
        /// </summary>
        public async ValueTask<SetInspectModeResult> SetInspectModeAsync(SetInspectModeParams setInspectModeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInspectModeParams, cancellationToken);

        }
        /// <summary>
        /// Highlights owner element of all frames detected to be ads.
        /// </summary>
        public async ValueTask<SetShowAdHighlightsResult> SetShowAdHighlightsAsync(SetShowAdHighlightsParams setShowAdHighlightsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowAdHighlightsParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SetPausedInDebuggerMessageResult> SetPausedInDebuggerMessageAsync(SetPausedInDebuggerMessageParams setPausedInDebuggerMessageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPausedInDebuggerMessageParams, cancellationToken);

        }
        /// <summary>
        /// Requests that backend shows debug borders on layers
        /// </summary>
        public async ValueTask<SetShowDebugBordersResult> SetShowDebugBordersAsync(SetShowDebugBordersParams setShowDebugBordersParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowDebugBordersParams, cancellationToken);

        }
        /// <summary>
        /// Requests that backend shows the FPS counter
        /// </summary>
        public async ValueTask<SetShowFPSCounterResult> SetShowFPSCounterAsync(SetShowFPSCounterParams setShowFPSCounterParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowFPSCounterParams, cancellationToken);

        }
        /// <summary>
        /// Highlight multiple elements with the CSS Grid overlay.
        /// </summary>
        public async ValueTask<SetShowGridOverlaysResult> SetShowGridOverlaysAsync(SetShowGridOverlaysParams setShowGridOverlaysParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowGridOverlaysParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SetShowFlexOverlaysResult> SetShowFlexOverlaysAsync(SetShowFlexOverlaysParams setShowFlexOverlaysParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowFlexOverlaysParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SetShowScrollSnapOverlaysResult> SetShowScrollSnapOverlaysAsync(SetShowScrollSnapOverlaysParams setShowScrollSnapOverlaysParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowScrollSnapOverlaysParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SetShowContainerQueryOverlaysResult> SetShowContainerQueryOverlaysAsync(SetShowContainerQueryOverlaysParams setShowContainerQueryOverlaysParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowContainerQueryOverlaysParams, cancellationToken);

        }
        /// <summary>
        /// Requests that backend shows paint rectangles
        /// </summary>
        public async ValueTask<SetShowPaintRectsResult> SetShowPaintRectsAsync(SetShowPaintRectsParams setShowPaintRectsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowPaintRectsParams, cancellationToken);

        }
        /// <summary>
        /// Requests that backend shows layout shift regions
        /// </summary>
        public async ValueTask<SetShowLayoutShiftRegionsResult> SetShowLayoutShiftRegionsAsync(SetShowLayoutShiftRegionsParams setShowLayoutShiftRegionsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowLayoutShiftRegionsParams, cancellationToken);

        }
        /// <summary>
        /// Requests that backend shows scroll bottleneck rects
        /// </summary>
        public async ValueTask<SetShowScrollBottleneckRectsResult> SetShowScrollBottleneckRectsAsync(SetShowScrollBottleneckRectsParams setShowScrollBottleneckRectsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowScrollBottleneckRectsParams, cancellationToken);

        }
        /// <summary>
        /// Deprecated, no longer has any effect.
        /// </summary>
        [Obsolete]
        public async ValueTask<SetShowHitTestBordersResult> SetShowHitTestBordersAsync(SetShowHitTestBordersParams setShowHitTestBordersParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowHitTestBordersParams, cancellationToken);

        }
        /// <summary>
        /// Request that backend shows an overlay with web vital metrics.
        /// </summary>
        public async ValueTask<SetShowWebVitalsResult> SetShowWebVitalsAsync(SetShowWebVitalsParams setShowWebVitalsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowWebVitalsParams, cancellationToken);

        }
        /// <summary>
        /// Paints viewport size upon main frame resize.
        /// </summary>
        public async ValueTask<SetShowViewportSizeOnResizeResult> SetShowViewportSizeOnResizeAsync(SetShowViewportSizeOnResizeParams setShowViewportSizeOnResizeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowViewportSizeOnResizeParams, cancellationToken);

        }
        /// <summary>
        /// Add a dual screen device hinge
        /// </summary>
        public async ValueTask<SetShowHingeResult> SetShowHingeAsync(SetShowHingeParams setShowHingeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowHingeParams, cancellationToken);

        }
        /// <summary>
        /// Show elements in isolation mode with overlays.
        /// </summary>
        public async ValueTask<SetShowIsolatedElementsResult> SetShowIsolatedElementsAsync(SetShowIsolatedElementsParams setShowIsolatedElementsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setShowIsolatedElementsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "inspectNodeRequested": RaiseEvent(InspectNodeRequested, messageBytes);
                    break;
                case "nodeHighlightRequested": RaiseEvent(NodeHighlightRequested, messageBytes);
                    break;
                case "screenshotRequested": RaiseEvent(ScreenshotRequested, messageBytes);
                    break;
                case "inspectModeCanceled": RaiseEvent(InspectModeCanceled, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class InspectNodeRequestedParams
        {
            /// <summary>
            /// Id of the node to inspect.
            /// </summary>
            public int BackendNodeId
            {
                get; set;
            }

        }
        public class NodeHighlightRequestedParams
        {
            /// <summary>
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class ScreenshotRequestedParams
        {
            /// <summary>
            /// Viewport to capture, in device independent pixels (dip).
            /// </summary>
            public PageDomain.Viewport Viewport
            {
                get; set;
            }

        }
        public class InspectModeCanceledParams
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Overlay.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Overlay.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetHighlightObjectForTestParams : IMethodParams<GetHighlightObjectForTestParams, GetHighlightObjectForTestResult>
        {
            public string GetMethod()
            {
                return "Overlay.getHighlightObjectForTest";

            }
            /// <summary>
            /// Id of the node to get highlight object for.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Whether to include distance info.
            /// </summary>
            public bool? IncludeDistance
            {
                get; set;
            }
            /// <summary>
            /// Whether to include style info.
            /// </summary>
            public bool? IncludeStyle
            {
                get; set;
            }
            /// <summary>
            /// The color format to get config with (default: hex).
            /// </summary>
            public OverlayDomain.ColorFormat? ColorFormat
            {
                get; set;
            }
            /// <summary>
            /// Whether to show accessibility info (default: true).
            /// </summary>
            public bool? ShowAccessibilityInfo
            {
                get; set;
            }

        }
        public class GetHighlightObjectForTestResult
        {
            /// <summary>
            /// Highlight data for the node.
            /// </summary>
            public object Highlight
            {
                get; set;
            }

        }
        public class GetGridHighlightObjectsForTestParams : IMethodParams<GetGridHighlightObjectsForTestParams, GetGridHighlightObjectsForTestResult>
        {
            public string GetMethod()
            {
                return "Overlay.getGridHighlightObjectsForTest";

            }
            /// <summary>
            /// Ids of the node to get highlight object for.
            /// </summary>
            public int[] NodeIds
            {
                get; set;
            }

        }
        public class GetGridHighlightObjectsForTestResult
        {
            /// <summary>
            /// Grid Highlight data for the node ids provided.
            /// </summary>
            public object Highlights
            {
                get; set;
            }

        }
        public class GetSourceOrderHighlightObjectForTestParams : IMethodParams<GetSourceOrderHighlightObjectForTestParams, GetSourceOrderHighlightObjectForTestResult>
        {
            public string GetMethod()
            {
                return "Overlay.getSourceOrderHighlightObjectForTest";

            }
            /// <summary>
            /// Id of the node to highlight.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        public class GetSourceOrderHighlightObjectForTestResult
        {
            /// <summary>
            /// Source order highlight data for the node id provided.
            /// </summary>
            public object Highlight
            {
                get; set;
            }

        }
        public class HideHighlightParams : IMethodParams<HideHighlightParams, HideHighlightResult>
        {
            public string GetMethod()
            {
                return "Overlay.hideHighlight";

            }

        }
        public class HideHighlightResult
        {

        }
        public class HighlightFrameParams : IMethodParams<HighlightFrameParams, HighlightFrameResult>
        {
            public string GetMethod()
            {
                return "Overlay.highlightFrame";

            }
            /// <summary>
            /// Identifier of the frame to highlight.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// The content box highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ContentColor
            {
                get; set;
            }
            /// <summary>
            /// The content box highlight outline color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ContentOutlineColor
            {
                get; set;
            }

        }
        public class HighlightFrameResult
        {

        }
        public class HighlightNodeParams : IMethodParams<HighlightNodeParams, HighlightNodeResult>
        {
            public string GetMethod()
            {
                return "Overlay.highlightNode";

            }
            /// <summary>
            /// A descriptor for the highlight appearance.
            /// </summary>
            public OverlayDomain.HighlightConfig HighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the node to highlight.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node to highlight.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node to be highlighted.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Selectors to highlight relevant nodes.
            /// </summary>
            public string? Selector
            {
                get; set;
            }

        }
        public class HighlightNodeResult
        {

        }
        public class HighlightQuadParams : IMethodParams<HighlightQuadParams, HighlightQuadResult>
        {
            public string GetMethod()
            {
                return "Overlay.highlightQuad";

            }
            /// <summary>
            /// Quad to highlight
            /// </summary>
            public double[] Quad
            {
                get; set;
            }
            /// <summary>
            /// The highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? Color
            {
                get; set;
            }
            /// <summary>
            /// The highlight outline color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? OutlineColor
            {
                get; set;
            }

        }
        public class HighlightQuadResult
        {

        }
        public class HighlightRectParams : IMethodParams<HighlightRectParams, HighlightRectResult>
        {
            public string GetMethod()
            {
                return "Overlay.highlightRect";

            }
            /// <summary>
            /// X coordinate
            /// </summary>
            public int X
            {
                get; set;
            }
            /// <summary>
            /// Y coordinate
            /// </summary>
            public int Y
            {
                get; set;
            }
            /// <summary>
            /// Rectangle width
            /// </summary>
            public int Width
            {
                get; set;
            }
            /// <summary>
            /// Rectangle height
            /// </summary>
            public int Height
            {
                get; set;
            }
            /// <summary>
            /// The highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? Color
            {
                get; set;
            }
            /// <summary>
            /// The highlight outline color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? OutlineColor
            {
                get; set;
            }

        }
        public class HighlightRectResult
        {

        }
        public class HighlightSourceOrderParams : IMethodParams<HighlightSourceOrderParams, HighlightSourceOrderResult>
        {
            public string GetMethod()
            {
                return "Overlay.highlightSourceOrder";

            }
            /// <summary>
            /// A descriptor for the appearance of the overlay drawing.
            /// </summary>
            public OverlayDomain.SourceOrderConfig SourceOrderConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the node to highlight.
            /// </summary>
            public int? NodeId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the backend node to highlight.
            /// </summary>
            public int? BackendNodeId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript object id of the node to be highlighted.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        public class HighlightSourceOrderResult
        {

        }
        public class SetInspectModeParams : IMethodParams<SetInspectModeParams, SetInspectModeResult>
        {
            public string GetMethod()
            {
                return "Overlay.setInspectMode";

            }
            /// <summary>
            /// Set an inspection mode.
            /// </summary>
            public OverlayDomain.InspectMode Mode
            {
                get; set;
            }
            /// <summary>
            /// A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled
            /// == false`.
            /// </summary>
            public OverlayDomain.HighlightConfig? HighlightConfig
            {
                get; set;
            }

        }
        public class SetInspectModeResult
        {

        }
        public class SetShowAdHighlightsParams : IMethodParams<SetShowAdHighlightsParams, SetShowAdHighlightsResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowAdHighlights";

            }
            /// <summary>
            /// True for showing ad highlights
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowAdHighlightsResult
        {

        }
        public class SetPausedInDebuggerMessageParams : IMethodParams<SetPausedInDebuggerMessageParams, SetPausedInDebuggerMessageResult>
        {
            public string GetMethod()
            {
                return "Overlay.setPausedInDebuggerMessage";

            }
            /// <summary>
            /// The message to display, also triggers resume and step over controls.
            /// </summary>
            public string? Message
            {
                get; set;
            }

        }
        public class SetPausedInDebuggerMessageResult
        {

        }
        public class SetShowDebugBordersParams : IMethodParams<SetShowDebugBordersParams, SetShowDebugBordersResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowDebugBorders";

            }
            /// <summary>
            /// True for showing debug borders
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowDebugBordersResult
        {

        }
        public class SetShowFPSCounterParams : IMethodParams<SetShowFPSCounterParams, SetShowFPSCounterResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowFPSCounter";

            }
            /// <summary>
            /// True for showing the FPS counter
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowFPSCounterResult
        {

        }
        public class SetShowGridOverlaysParams : IMethodParams<SetShowGridOverlaysParams, SetShowGridOverlaysResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowGridOverlays";

            }
            /// <summary>
            /// An array of node identifiers and descriptors for the highlight appearance.
            /// </summary>
            public OverlayDomain.GridNodeHighlightConfig[] GridNodeHighlightConfigs
            {
                get; set;
            }

        }
        public class SetShowGridOverlaysResult
        {

        }
        public class SetShowFlexOverlaysParams : IMethodParams<SetShowFlexOverlaysParams, SetShowFlexOverlaysResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowFlexOverlays";

            }
            /// <summary>
            /// An array of node identifiers and descriptors for the highlight appearance.
            /// </summary>
            public OverlayDomain.FlexNodeHighlightConfig[] FlexNodeHighlightConfigs
            {
                get; set;
            }

        }
        public class SetShowFlexOverlaysResult
        {

        }
        public class SetShowScrollSnapOverlaysParams : IMethodParams<SetShowScrollSnapOverlaysParams, SetShowScrollSnapOverlaysResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowScrollSnapOverlays";

            }
            /// <summary>
            /// An array of node identifiers and descriptors for the highlight appearance.
            /// </summary>
            public OverlayDomain.ScrollSnapHighlightConfig[] ScrollSnapHighlightConfigs
            {
                get; set;
            }

        }
        public class SetShowScrollSnapOverlaysResult
        {

        }
        public class SetShowContainerQueryOverlaysParams : IMethodParams<SetShowContainerQueryOverlaysParams, SetShowContainerQueryOverlaysResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowContainerQueryOverlays";

            }
            /// <summary>
            /// An array of node identifiers and descriptors for the highlight appearance.
            /// </summary>
            public OverlayDomain.ContainerQueryHighlightConfig[] ContainerQueryHighlightConfigs
            {
                get; set;
            }

        }
        public class SetShowContainerQueryOverlaysResult
        {

        }
        public class SetShowPaintRectsParams : IMethodParams<SetShowPaintRectsParams, SetShowPaintRectsResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowPaintRects";

            }
            /// <summary>
            /// True for showing paint rectangles
            /// </summary>
            public bool Result
            {
                get; set;
            }

        }
        public class SetShowPaintRectsResult
        {

        }
        public class SetShowLayoutShiftRegionsParams : IMethodParams<SetShowLayoutShiftRegionsParams, SetShowLayoutShiftRegionsResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowLayoutShiftRegions";

            }
            /// <summary>
            /// True for showing layout shift regions
            /// </summary>
            public bool Result
            {
                get; set;
            }

        }
        public class SetShowLayoutShiftRegionsResult
        {

        }
        public class SetShowScrollBottleneckRectsParams : IMethodParams<SetShowScrollBottleneckRectsParams, SetShowScrollBottleneckRectsResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowScrollBottleneckRects";

            }
            /// <summary>
            /// True for showing scroll bottleneck rects
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowScrollBottleneckRectsResult
        {

        }
        public class SetShowHitTestBordersParams : IMethodParams<SetShowHitTestBordersParams, SetShowHitTestBordersResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowHitTestBorders";

            }
            /// <summary>
            /// True for showing hit-test borders
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowHitTestBordersResult
        {

        }
        public class SetShowWebVitalsParams : IMethodParams<SetShowWebVitalsParams, SetShowWebVitalsResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowWebVitals";

            }
            /// <summary>
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowWebVitalsResult
        {

        }
        public class SetShowViewportSizeOnResizeParams : IMethodParams<SetShowViewportSizeOnResizeParams, SetShowViewportSizeOnResizeResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowViewportSizeOnResize";

            }
            /// <summary>
            /// Whether to paint size or not.
            /// </summary>
            public bool Show
            {
                get; set;
            }

        }
        public class SetShowViewportSizeOnResizeResult
        {

        }
        public class SetShowHingeParams : IMethodParams<SetShowHingeParams, SetShowHingeResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowHinge";

            }
            /// <summary>
            /// hinge data, null means hideHinge
            /// </summary>
            public OverlayDomain.HingeConfig? HingeConfig
            {
                get; set;
            }

        }
        public class SetShowHingeResult
        {

        }
        public class SetShowIsolatedElementsParams : IMethodParams<SetShowIsolatedElementsParams, SetShowIsolatedElementsResult>
        {
            public string GetMethod()
            {
                return "Overlay.setShowIsolatedElements";

            }
            /// <summary>
            /// An array of node identifiers and descriptors for the highlight appearance.
            /// </summary>
            public OverlayDomain.IsolatedElementHighlightConfig[] IsolatedElementHighlightConfigs
            {
                get; set;
            }

        }
        public class SetShowIsolatedElementsResult
        {

        }
        /// <summary>
        /// Configuration data for drawing the source order of an elements children.
        /// </summary>
        public class SourceOrderConfig
        {
            /// <summary>
            /// the color to outline the givent element in.
            /// </summary>
            public DOMDomain.RGBA ParentOutlineColor
            {
                get; set;
            }
            /// <summary>
            /// the color to outline the child elements in.
            /// </summary>
            public DOMDomain.RGBA ChildOutlineColor
            {
                get; set;
            }

        }
        /// <summary>
        /// Configuration data for the highlighting of Grid elements.
        /// </summary>
        public class GridHighlightConfig
        {
            /// <summary>
            /// Whether the extension lines from grid cells to the rulers should be shown (default: false).
            /// </summary>
            public bool? ShowGridExtensionLines
            {
                get; set;
            }
            /// <summary>
            /// Show Positive line number labels (default: false).
            /// </summary>
            public bool? ShowPositiveLineNumbers
            {
                get; set;
            }
            /// <summary>
            /// Show Negative line number labels (default: false).
            /// </summary>
            public bool? ShowNegativeLineNumbers
            {
                get; set;
            }
            /// <summary>
            /// Show area name labels (default: false).
            /// </summary>
            public bool? ShowAreaNames
            {
                get; set;
            }
            /// <summary>
            /// Show line name labels (default: false).
            /// </summary>
            public bool? ShowLineNames
            {
                get; set;
            }
            /// <summary>
            /// Show track size labels (default: false).
            /// </summary>
            public bool? ShowTrackSizes
            {
                get; set;
            }
            /// <summary>
            /// The grid container border highlight color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? GridBorderColor
            {
                get; set;
            }
            /// <summary>
            /// The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
            /// </summary>
            [Obsolete]
            public DOMDomain.RGBA? CellBorderColor
            {
                get; set;
            }
            /// <summary>
            /// The row line color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? RowLineColor
            {
                get; set;
            }
            /// <summary>
            /// The column line color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ColumnLineColor
            {
                get; set;
            }
            /// <summary>
            /// Whether the grid border is dashed (default: false).
            /// </summary>
            public bool? GridBorderDash
            {
                get; set;
            }
            /// <summary>
            /// Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
            /// </summary>
            [Obsolete]
            public bool? CellBorderDash
            {
                get; set;
            }
            /// <summary>
            /// Whether row lines are dashed (default: false).
            /// </summary>
            public bool? RowLineDash
            {
                get; set;
            }
            /// <summary>
            /// Whether column lines are dashed (default: false).
            /// </summary>
            public bool? ColumnLineDash
            {
                get; set;
            }
            /// <summary>
            /// The row gap highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? RowGapColor
            {
                get; set;
            }
            /// <summary>
            /// The row gap hatching fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? RowHatchColor
            {
                get; set;
            }
            /// <summary>
            /// The column gap highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ColumnGapColor
            {
                get; set;
            }
            /// <summary>
            /// The column gap hatching fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ColumnHatchColor
            {
                get; set;
            }
            /// <summary>
            /// The named grid areas border color (Default: transparent).
            /// </summary>
            public DOMDomain.RGBA? AreaBorderColor
            {
                get; set;
            }
            /// <summary>
            /// The grid container background color (Default: transparent).
            /// </summary>
            public DOMDomain.RGBA? GridBackgroundColor
            {
                get; set;
            }

        }
        /// <summary>
        /// Configuration data for the highlighting of Flex container elements.
        /// </summary>
        public class FlexContainerHighlightConfig
        {
            /// <summary>
            /// The style of the container border
            /// </summary>
            public OverlayDomain.LineStyle? ContainerBorder
            {
                get; set;
            }
            /// <summary>
            /// The style of the separator between lines
            /// </summary>
            public OverlayDomain.LineStyle? LineSeparator
            {
                get; set;
            }
            /// <summary>
            /// The style of the separator between items
            /// </summary>
            public OverlayDomain.LineStyle? ItemSeparator
            {
                get; set;
            }
            /// <summary>
            /// Style of content-distribution space on the main axis (justify-content).
            /// </summary>
            public OverlayDomain.BoxStyle? MainDistributedSpace
            {
                get; set;
            }
            /// <summary>
            /// Style of content-distribution space on the cross axis (align-content).
            /// </summary>
            public OverlayDomain.BoxStyle? CrossDistributedSpace
            {
                get; set;
            }
            /// <summary>
            /// Style of empty space caused by row gaps (gap/row-gap).
            /// </summary>
            public OverlayDomain.BoxStyle? RowGapSpace
            {
                get; set;
            }
            /// <summary>
            /// Style of empty space caused by columns gaps (gap/column-gap).
            /// </summary>
            public OverlayDomain.BoxStyle? ColumnGapSpace
            {
                get; set;
            }
            /// <summary>
            /// Style of the self-alignment line (align-items).
            /// </summary>
            public OverlayDomain.LineStyle? CrossAlignment
            {
                get; set;
            }

        }
        /// <summary>
        /// Configuration data for the highlighting of Flex item elements.
        /// </summary>
        public class FlexItemHighlightConfig
        {
            /// <summary>
            /// Style of the box representing the item's base size
            /// </summary>
            public OverlayDomain.BoxStyle? BaseSizeBox
            {
                get; set;
            }
            /// <summary>
            /// Style of the border around the box representing the item's base size
            /// </summary>
            public OverlayDomain.LineStyle? BaseSizeBorder
            {
                get; set;
            }
            /// <summary>
            /// Style of the arrow representing if the item grew or shrank
            /// </summary>
            public OverlayDomain.LineStyle? FlexibilityArrow
            {
                get; set;
            }

        }
        /// <summary>
        /// Style information for drawing a line.
        /// </summary>
        public class LineStyle
        {
            /// <summary>
            /// The color of the line (default: transparent)
            /// </summary>
            public DOMDomain.RGBA? Color
            {
                get; set;
            }
            /// <summary>
            /// The line pattern (default: solid)
            /// </summary>
            /// <value>
            /// dashed,dotted
            /// </value>
            public string? Pattern
            {
                get; set;
            }

        }
        /// <summary>
        /// Style information for drawing a box.
        /// </summary>
        public class BoxStyle
        {
            /// <summary>
            /// The background color for the box (default: transparent)
            /// </summary>
            public DOMDomain.RGBA? FillColor
            {
                get; set;
            }
            /// <summary>
            /// The hatching color for the box (default: transparent)
            /// </summary>
            public DOMDomain.RGBA? HatchColor
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum ContrastAlgorithm
        {
            [EnumValue("aa")]
            Aa = 1,
            [EnumValue("aaa")]
            Aaa = 2,
            [EnumValue("apca")]
            Apca = 3,

        }
        /// <summary>
        /// Configuration data for the highlighting of page elements.
        /// </summary>
        public class HighlightConfig
        {
            /// <summary>
            /// Whether the node info tooltip should be shown (default: false).
            /// </summary>
            public bool? ShowInfo
            {
                get; set;
            }
            /// <summary>
            /// Whether the node styles in the tooltip (default: false).
            /// </summary>
            public bool? ShowStyles
            {
                get; set;
            }
            /// <summary>
            /// Whether the rulers should be shown (default: false).
            /// </summary>
            public bool? ShowRulers
            {
                get; set;
            }
            /// <summary>
            /// Whether the a11y info should be shown (default: true).
            /// </summary>
            public bool? ShowAccessibilityInfo
            {
                get; set;
            }
            /// <summary>
            /// Whether the extension lines from node to the rulers should be shown (default: false).
            /// </summary>
            public bool? ShowExtensionLines
            {
                get; set;
            }
            /// <summary>
            /// The content box highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ContentColor
            {
                get; set;
            }
            /// <summary>
            /// The padding highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? PaddingColor
            {
                get; set;
            }
            /// <summary>
            /// The border highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? BorderColor
            {
                get; set;
            }
            /// <summary>
            /// The margin highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? MarginColor
            {
                get; set;
            }
            /// <summary>
            /// The event target element highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? EventTargetColor
            {
                get; set;
            }
            /// <summary>
            /// The shape outside fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ShapeColor
            {
                get; set;
            }
            /// <summary>
            /// The shape margin fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ShapeMarginColor
            {
                get; set;
            }
            /// <summary>
            /// The grid layout color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? CssGridColor
            {
                get; set;
            }
            /// <summary>
            /// The color format used to format color styles (default: hex).
            /// </summary>
            public OverlayDomain.ColorFormat? ColorFormat
            {
                get; set;
            }
            /// <summary>
            /// The grid layout highlight configuration (default: all transparent).
            /// </summary>
            public OverlayDomain.GridHighlightConfig? GridHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// The flex container highlight configuration (default: all transparent).
            /// </summary>
            public OverlayDomain.FlexContainerHighlightConfig? FlexContainerHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// The flex item highlight configuration (default: all transparent).
            /// </summary>
            public OverlayDomain.FlexItemHighlightConfig? FlexItemHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// The contrast algorithm to use for the contrast ratio (default: aa).
            /// </summary>
            public OverlayDomain.ContrastAlgorithm? ContrastAlgorithm
            {
                get; set;
            }
            /// <summary>
            /// The container query container highlight configuration (default: all transparent).
            /// </summary>
            public OverlayDomain.ContainerQueryContainerHighlightConfig? ContainerQueryContainerHighlightConfig
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum ColorFormat
        {
            [EnumValue("rgb")]
            Rgb = 1,
            [EnumValue("hsl")]
            Hsl = 2,
            [EnumValue("hwb")]
            Hwb = 3,
            [EnumValue("hex")]
            Hex = 4,

        }
        /// <summary>
        /// Configurations for Persistent Grid Highlight
        /// </summary>
        public class GridNodeHighlightConfig
        {
            /// <summary>
            /// A descriptor for the highlight appearance.
            /// </summary>
            public OverlayDomain.GridHighlightConfig GridHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the node to highlight.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class FlexNodeHighlightConfig
        {
            /// <summary>
            /// A descriptor for the highlight appearance of flex containers.
            /// </summary>
            public OverlayDomain.FlexContainerHighlightConfig FlexContainerHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the node to highlight.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class ScrollSnapContainerHighlightConfig
        {
            /// <summary>
            /// The style of the snapport border (default: transparent)
            /// </summary>
            public OverlayDomain.LineStyle? SnapportBorder
            {
                get; set;
            }
            /// <summary>
            /// The style of the snap area border (default: transparent)
            /// </summary>
            public OverlayDomain.LineStyle? SnapAreaBorder
            {
                get; set;
            }
            /// <summary>
            /// The margin highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ScrollMarginColor
            {
                get; set;
            }
            /// <summary>
            /// The padding highlight fill color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ScrollPaddingColor
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class ScrollSnapHighlightConfig
        {
            /// <summary>
            /// A descriptor for the highlight appearance of scroll snap containers.
            /// </summary>
            public OverlayDomain.ScrollSnapContainerHighlightConfig ScrollSnapContainerHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the node to highlight.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// Configuration for dual screen hinge
        /// </summary>
        public class HingeConfig
        {
            /// <summary>
            /// A rectangle represent hinge
            /// </summary>
            public DOMDomain.Rect Rect
            {
                get; set;
            }
            /// <summary>
            /// The content box highlight fill color (default: a dark color).
            /// </summary>
            public DOMDomain.RGBA? ContentColor
            {
                get; set;
            }
            /// <summary>
            /// The content box highlight outline color (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? OutlineColor
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class ContainerQueryHighlightConfig
        {
            /// <summary>
            /// A descriptor for the highlight appearance of container query containers.
            /// </summary>
            public OverlayDomain.ContainerQueryContainerHighlightConfig ContainerQueryContainerHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the container node to highlight.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class ContainerQueryContainerHighlightConfig
        {
            /// <summary>
            /// The style of the container border.
            /// </summary>
            public OverlayDomain.LineStyle? ContainerBorder
            {
                get; set;
            }
            /// <summary>
            /// The style of the descendants' borders.
            /// </summary>
            public OverlayDomain.LineStyle? DescendantBorder
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class IsolatedElementHighlightConfig
        {
            /// <summary>
            /// A descriptor for the highlight appearance of an element in isolation mode.
            /// </summary>
            public OverlayDomain.IsolationModeHighlightConfig IsolationModeHighlightConfig
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the isolated element to highlight.
            /// </summary>
            public int NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class IsolationModeHighlightConfig
        {
            /// <summary>
            /// The fill color of the resizers (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ResizerColor
            {
                get; set;
            }
            /// <summary>
            /// The fill color for resizer handles (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? ResizerHandleColor
            {
                get; set;
            }
            /// <summary>
            /// The fill color for the mask covering non-isolated elements (default: transparent).
            /// </summary>
            public DOMDomain.RGBA? MaskColor
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum InspectMode
        {
            [EnumValue("searchForNode")]
            SearchForNode = 1,
            [EnumValue("searchForUAShadowDOM")]
            SearchForUAShadowDOM = 2,
            [EnumValue("captureAreaScreenshot")]
            CaptureAreaScreenshot = 3,
            [EnumValue("showDistances")]
            ShowDistances = 4,
            [EnumValue("none")]
            None = 5,

        }

    }
    public class PageDomain : BaseDomain
    {
        public PageDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Page";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<DomContentEventFiredParams>? DomContentEventFired;
        /// <summary>
        /// Emitted only when `page.interceptFileChooser` is enabled.
        /// </summary>
        public event EventHandler<FileChooserOpenedParams>? FileChooserOpened;
        /// <summary>
        /// Fired when frame has been attached to its parent.
        /// </summary>
        public event EventHandler<FrameAttachedParams>? FrameAttached;
        /// <summary>
        /// Fired when frame no longer has a scheduled navigation.
        /// </summary>
        [Obsolete]
        public event EventHandler<FrameClearedScheduledNavigationParams>? FrameClearedScheduledNavigation;
        /// <summary>
        /// Fired when frame has been detached from its parent.
        /// </summary>
        public event EventHandler<FrameDetachedParams>? FrameDetached;
        /// <summary>
        /// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
        /// </summary>
        public event EventHandler<FrameNavigatedParams>? FrameNavigated;
        /// <summary>
        /// Fired when opening document to write to.
        /// </summary>
        [Experimental]
        public event EventHandler<DocumentOpenedParams>? DocumentOpened;
        /// <summary>
        /// </summary>
        [Experimental]
        public event EventHandler<FrameResizedParams>? FrameResized;
        /// <summary>
        /// Fired when a renderer-initiated navigation is requested.
        /// Navigation may still be cancelled after the event is issued.
        /// </summary>
        [Experimental]
        public event EventHandler<FrameRequestedNavigationParams>? FrameRequestedNavigation;
        /// <summary>
        /// Fired when frame schedules a potential navigation.
        /// </summary>
        [Obsolete]
        public event EventHandler<FrameScheduledNavigationParams>? FrameScheduledNavigation;
        /// <summary>
        /// Fired when frame has started loading.
        /// </summary>
        [Experimental]
        public event EventHandler<FrameStartedLoadingParams>? FrameStartedLoading;
        /// <summary>
        /// Fired when frame has stopped loading.
        /// </summary>
        [Experimental]
        public event EventHandler<FrameStoppedLoadingParams>? FrameStoppedLoading;
        /// <summary>
        /// Fired when page is about to start a download.
        /// Deprecated. Use Browser.downloadWillBegin instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public event EventHandler<DownloadWillBeginParams>? DownloadWillBegin;
        /// <summary>
        /// Fired when download makes progress. Last call has |done| == true.
        /// Deprecated. Use Browser.downloadProgress instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public event EventHandler<DownloadProgressParams>? DownloadProgress;
        /// <summary>
        /// Fired when interstitial page was hidden
        /// </summary>
        public event EventHandler<InterstitialHiddenParams>? InterstitialHidden;
        /// <summary>
        /// Fired when interstitial page was shown
        /// </summary>
        public event EventHandler<InterstitialShownParams>? InterstitialShown;
        /// <summary>
        /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
        /// closed.
        /// </summary>
        public event EventHandler<JavascriptDialogClosedParams>? JavascriptDialogClosed;
        /// <summary>
        /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
        /// open.
        /// </summary>
        public event EventHandler<JavascriptDialogOpeningParams>? JavascriptDialogOpening;
        /// <summary>
        /// Fired for top level page lifecycle events such as navigation, load, paint, etc.
        /// </summary>
        public event EventHandler<LifecycleEventParams>? LifecycleEvent;
        /// <summary>
        /// Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
        /// not assume any ordering with the Page.frameNavigated event. This event is fired only for
        /// main-frame history navigation where the document changes (non-same-document navigations),
        /// when bfcache navigation fails.
        /// </summary>
        [Experimental]
        public event EventHandler<BackForwardCacheNotUsedParams>? BackForwardCacheNotUsed;
        /// <summary>
        /// Fired when a prerender attempt is completed.
        /// </summary>
        public event EventHandler<PrerenderAttemptCompletedParams>? PrerenderAttemptCompleted;
        /// <summary>
        /// </summary>
        public event EventHandler<LoadEventFiredParams>? LoadEventFired;
        /// <summary>
        /// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
        /// </summary>
        [Experimental]
        public event EventHandler<NavigatedWithinDocumentParams>? NavigatedWithinDocument;
        /// <summary>
        /// Compressed image data requested by the `startScreencast`.
        /// </summary>
        [Experimental]
        public event EventHandler<ScreencastFrameParams>? ScreencastFrame;
        /// <summary>
        /// Fired when the page with currently enabled screencast was shown or hidden `.
        /// </summary>
        [Experimental]
        public event EventHandler<ScreencastVisibilityChangedParams>? ScreencastVisibilityChanged;
        /// <summary>
        /// Fired when a new window is going to be opened, via window.open(), link click, form submission,
        /// etc.
        /// </summary>
        public event EventHandler<WindowOpenParams>? WindowOpen;
        /// <summary>
        /// Issued for every compilation cache generated. Is only available
        /// if Page.setGenerateCompilationCache is enabled.
        /// </summary>
        [Experimental]
        public event EventHandler<CompilationCacheProducedParams>? CompilationCacheProduced;
        /// <summary>
        /// Deprecated, please use addScriptToEvaluateOnNewDocument instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<AddScriptToEvaluateOnLoadResult> AddScriptToEvaluateOnLoadAsync(AddScriptToEvaluateOnLoadParams addScriptToEvaluateOnLoadParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addScriptToEvaluateOnLoadParams, cancellationToken);

        }
        /// <summary>
        /// Evaluates given script in every frame upon creation (before loading frame's scripts).
        /// </summary>
        public async ValueTask<AddScriptToEvaluateOnNewDocumentResult> AddScriptToEvaluateOnNewDocumentAsync(AddScriptToEvaluateOnNewDocumentParams addScriptToEvaluateOnNewDocumentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addScriptToEvaluateOnNewDocumentParams, cancellationToken);

        }
        /// <summary>
        /// Brings page to front (activates tab).
        /// </summary>
        public async ValueTask<BringToFrontResult> BringToFrontAsync(BringToFrontParams bringToFrontParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(bringToFrontParams, cancellationToken);

        }
        /// <summary>
        /// Capture page screenshot.
        /// </summary>
        public async ValueTask<CaptureScreenshotResult> CaptureScreenshotAsync(CaptureScreenshotParams captureScreenshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(captureScreenshotParams, cancellationToken);

        }
        /// <summary>
        /// Returns a snapshot of the page as a string. For MHTML format, the serialization includes
        /// iframes, shadow DOM, external resources, and element-inline styles.
        /// </summary>
        [Experimental]
        public async ValueTask<CaptureSnapshotResult> CaptureSnapshotAsync(CaptureSnapshotParams captureSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(captureSnapshotParams, cancellationToken);

        }
        /// <summary>
        /// Clears the overridden device metrics.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<ClearDeviceMetricsOverrideResult> ClearDeviceMetricsOverrideAsync(ClearDeviceMetricsOverrideParams clearDeviceMetricsOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearDeviceMetricsOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Clears the overridden Device Orientation.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<ClearDeviceOrientationOverrideResult> ClearDeviceOrientationOverrideAsync(ClearDeviceOrientationOverrideParams clearDeviceOrientationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearDeviceOrientationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Clears the overridden Geolocation Position and Error.
        /// </summary>
        [Obsolete]
        public async ValueTask<ClearGeolocationOverrideResult> ClearGeolocationOverrideAsync(ClearGeolocationOverrideParams clearGeolocationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearGeolocationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Creates an isolated world for the given frame.
        /// </summary>
        public async ValueTask<CreateIsolatedWorldResult> CreateIsolatedWorldAsync(CreateIsolatedWorldParams createIsolatedWorldParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(createIsolatedWorldParams, cancellationToken);

        }
        /// <summary>
        /// Deletes browser cookie with given name, domain and path.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<DeleteCookieResult> DeleteCookieAsync(DeleteCookieParams deleteCookieParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deleteCookieParams, cancellationToken);

        }
        /// <summary>
        /// Disables page domain notifications.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables page domain notifications.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetAppManifestResult> GetAppManifestAsync(GetAppManifestParams getAppManifestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getAppManifestParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<GetInstallabilityErrorsResult> GetInstallabilityErrorsAsync(GetInstallabilityErrorsParams getInstallabilityErrorsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getInstallabilityErrorsParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<GetManifestIconsResult> GetManifestIconsAsync(GetManifestIconsParams getManifestIconsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getManifestIconsParams, cancellationToken);

        }
        /// <summary>
        /// Returns the unique (PWA) app id.
        /// Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
        /// </summary>
        [Experimental]
        public async ValueTask<GetAppIdResult> GetAppIdAsync(GetAppIdParams getAppIdParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getAppIdParams, cancellationToken);

        }
        /// <summary>
        /// Returns all browser cookies. Depending on the backend support, will return detailed cookie
        /// information in the `cookies` field.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<GetCookiesResult> GetCookiesAsync(GetCookiesParams getCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Returns present frame tree structure.
        /// </summary>
        public async ValueTask<GetFrameTreeResult> GetFrameTreeAsync(GetFrameTreeParams getFrameTreeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getFrameTreeParams, cancellationToken);

        }
        /// <summary>
        /// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
        /// </summary>
        public async ValueTask<GetLayoutMetricsResult> GetLayoutMetricsAsync(GetLayoutMetricsParams getLayoutMetricsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getLayoutMetricsParams, cancellationToken);

        }
        /// <summary>
        /// Returns navigation history for the current page.
        /// </summary>
        public async ValueTask<GetNavigationHistoryResult> GetNavigationHistoryAsync(GetNavigationHistoryParams getNavigationHistoryParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getNavigationHistoryParams, cancellationToken);

        }
        /// <summary>
        /// Resets navigation history for the current page.
        /// </summary>
        public async ValueTask<ResetNavigationHistoryResult> ResetNavigationHistoryAsync(ResetNavigationHistoryParams resetNavigationHistoryParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resetNavigationHistoryParams, cancellationToken);

        }
        /// <summary>
        /// Returns content of the given resource.
        /// </summary>
        [Experimental]
        public async ValueTask<GetResourceContentResult> GetResourceContentAsync(GetResourceContentParams getResourceContentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getResourceContentParams, cancellationToken);

        }
        /// <summary>
        /// Returns present frame / resource tree structure.
        /// </summary>
        [Experimental]
        public async ValueTask<GetResourceTreeResult> GetResourceTreeAsync(GetResourceTreeParams getResourceTreeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getResourceTreeParams, cancellationToken);

        }
        /// <summary>
        /// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
        /// </summary>
        public async ValueTask<HandleJavaScriptDialogResult> HandleJavaScriptDialogAsync(HandleJavaScriptDialogParams handleJavaScriptDialogParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(handleJavaScriptDialogParams, cancellationToken);

        }
        /// <summary>
        /// Navigates current page to the given URL.
        /// </summary>
        public async ValueTask<NavigateResult> NavigateAsync(NavigateParams navigateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(navigateParams, cancellationToken);

        }
        /// <summary>
        /// Navigates current page to the given history entry.
        /// </summary>
        public async ValueTask<NavigateToHistoryEntryResult> NavigateToHistoryEntryAsync(NavigateToHistoryEntryParams navigateToHistoryEntryParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(navigateToHistoryEntryParams, cancellationToken);

        }
        /// <summary>
        /// Print page as PDF.
        /// </summary>
        public async ValueTask<PrintToPDFResult> PrintToPDFAsync(PrintToPDFParams printToPDFParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(printToPDFParams, cancellationToken);

        }
        /// <summary>
        /// Reloads given page optionally ignoring the cache.
        /// </summary>
        public async ValueTask<ReloadResult> ReloadAsync(ReloadParams reloadParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(reloadParams, cancellationToken);

        }
        /// <summary>
        /// Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<RemoveScriptToEvaluateOnLoadResult> RemoveScriptToEvaluateOnLoadAsync(RemoveScriptToEvaluateOnLoadParams removeScriptToEvaluateOnLoadParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeScriptToEvaluateOnLoadParams, cancellationToken);

        }
        /// <summary>
        /// Removes given script from the list.
        /// </summary>
        public async ValueTask<RemoveScriptToEvaluateOnNewDocumentResult> RemoveScriptToEvaluateOnNewDocumentAsync(RemoveScriptToEvaluateOnNewDocumentParams removeScriptToEvaluateOnNewDocumentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeScriptToEvaluateOnNewDocumentParams, cancellationToken);

        }
        /// <summary>
        /// Acknowledges that a screencast frame has been received by the frontend.
        /// </summary>
        [Experimental]
        public async ValueTask<ScreencastFrameAckResult> ScreencastFrameAckAsync(ScreencastFrameAckParams screencastFrameAckParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(screencastFrameAckParams, cancellationToken);

        }
        /// <summary>
        /// Searches for given string in resource content.
        /// </summary>
        [Experimental]
        public async ValueTask<SearchInResourceResult> SearchInResourceAsync(SearchInResourceParams searchInResourceParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(searchInResourceParams, cancellationToken);

        }
        /// <summary>
        /// Enable Chrome's experimental ad filter on all sites.
        /// </summary>
        [Experimental]
        public async ValueTask<SetAdBlockingEnabledResult> SetAdBlockingEnabledAsync(SetAdBlockingEnabledParams setAdBlockingEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAdBlockingEnabledParams, cancellationToken);

        }
        /// <summary>
        /// Enable page Content Security Policy by-passing.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBypassCSPResult> SetBypassCSPAsync(SetBypassCSPParams setBypassCSPParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBypassCSPParams, cancellationToken);

        }
        /// <summary>
        /// Get Permissions Policy state on given frame.
        /// </summary>
        [Experimental]
        public async ValueTask<GetPermissionsPolicyStateResult> GetPermissionsPolicyStateAsync(GetPermissionsPolicyStateParams getPermissionsPolicyStateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getPermissionsPolicyStateParams, cancellationToken);

        }
        /// <summary>
        /// Get Origin Trials on given frame.
        /// </summary>
        [Experimental]
        public async ValueTask<GetOriginTrialsResult> GetOriginTrialsAsync(GetOriginTrialsParams getOriginTrialsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getOriginTrialsParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
        /// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
        /// query results).
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetDeviceMetricsOverrideResult> SetDeviceMetricsOverrideAsync(SetDeviceMetricsOverrideParams setDeviceMetricsOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDeviceMetricsOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the Device Orientation.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetDeviceOrientationOverrideResult> SetDeviceOrientationOverrideAsync(SetDeviceOrientationOverrideParams setDeviceOrientationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDeviceOrientationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Set generic font families.
        /// </summary>
        [Experimental]
        public async ValueTask<SetFontFamiliesResult> SetFontFamiliesAsync(SetFontFamiliesParams setFontFamiliesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setFontFamiliesParams, cancellationToken);

        }
        /// <summary>
        /// Set default font sizes.
        /// </summary>
        [Experimental]
        public async ValueTask<SetFontSizesResult> SetFontSizesAsync(SetFontSizesParams setFontSizesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setFontSizesParams, cancellationToken);

        }
        /// <summary>
        /// Sets given markup as the document's HTML.
        /// </summary>
        public async ValueTask<SetDocumentContentResult> SetDocumentContentAsync(SetDocumentContentParams setDocumentContentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDocumentContentParams, cancellationToken);

        }
        /// <summary>
        /// Set the behavior when downloading a file.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetDownloadBehaviorResult> SetDownloadBehaviorAsync(SetDownloadBehaviorParams setDownloadBehaviorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDownloadBehaviorParams, cancellationToken);

        }
        /// <summary>
        /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
        /// unavailable.
        /// </summary>
        [Obsolete]
        public async ValueTask<SetGeolocationOverrideResult> SetGeolocationOverrideAsync(SetGeolocationOverrideParams setGeolocationOverrideParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setGeolocationOverrideParams, cancellationToken);

        }
        /// <summary>
        /// Controls whether page will emit lifecycle events.
        /// </summary>
        [Experimental]
        public async ValueTask<SetLifecycleEventsEnabledResult> SetLifecycleEventsEnabledAsync(SetLifecycleEventsEnabledParams setLifecycleEventsEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setLifecycleEventsEnabledParams, cancellationToken);

        }
        /// <summary>
        /// Toggles mouse event-based touch event emulation.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetTouchEmulationEnabledResult> SetTouchEmulationEnabledAsync(SetTouchEmulationEnabledParams setTouchEmulationEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setTouchEmulationEnabledParams, cancellationToken);

        }
        /// <summary>
        /// Starts sending each frame using the `screencastFrame` event.
        /// </summary>
        [Experimental]
        public async ValueTask<StartScreencastResult> StartScreencastAsync(StartScreencastParams startScreencastParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startScreencastParams, cancellationToken);

        }
        /// <summary>
        /// Force the page stop all navigations and pending resource fetches.
        /// </summary>
        public async ValueTask<StopLoadingResult> StopLoadingAsync(StopLoadingParams stopLoadingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopLoadingParams, cancellationToken);

        }
        /// <summary>
        /// Crashes renderer on the IO thread, generates minidumps.
        /// </summary>
        [Experimental]
        public async ValueTask<CrashResult> CrashAsync(CrashParams crashParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(crashParams, cancellationToken);

        }
        /// <summary>
        /// Tries to close page, running its beforeunload hooks, if any.
        /// </summary>
        [Experimental]
        public async ValueTask<CloseResult> CloseAsync(CloseParams closeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(closeParams, cancellationToken);

        }
        /// <summary>
        /// Tries to update the web lifecycle state of the page.
        /// It will transition the page to the given state according to:
        /// https://github.com/WICG/web-lifecycle/
        /// </summary>
        [Experimental]
        public async ValueTask<SetWebLifecycleStateResult> SetWebLifecycleStateAsync(SetWebLifecycleStateParams setWebLifecycleStateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setWebLifecycleStateParams, cancellationToken);

        }
        /// <summary>
        /// Stops sending each frame in the `screencastFrame`.
        /// </summary>
        [Experimental]
        public async ValueTask<StopScreencastResult> StopScreencastAsync(StopScreencastParams stopScreencastParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopScreencastParams, cancellationToken);

        }
        /// <summary>
        /// Requests backend to produce compilation cache for the specified scripts.
        /// `scripts` are appeneded to the list of scripts for which the cache
        /// would be produced. The list may be reset during page navigation.
        /// When script with a matching URL is encountered, the cache is optionally
        /// produced upon backend discretion, based on internal heuristics.
        /// See also: `Page.compilationCacheProduced`.
        /// </summary>
        [Experimental]
        public async ValueTask<ProduceCompilationCacheResult> ProduceCompilationCacheAsync(ProduceCompilationCacheParams produceCompilationCacheParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(produceCompilationCacheParams, cancellationToken);

        }
        /// <summary>
        /// Seeds compilation cache for given url. Compilation cache does not survive
        /// cross-process navigation.
        /// </summary>
        [Experimental]
        public async ValueTask<AddCompilationCacheResult> AddCompilationCacheAsync(AddCompilationCacheParams addCompilationCacheParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addCompilationCacheParams, cancellationToken);

        }
        /// <summary>
        /// Clears seeded compilation cache.
        /// </summary>
        [Experimental]
        public async ValueTask<ClearCompilationCacheResult> ClearCompilationCacheAsync(ClearCompilationCacheParams clearCompilationCacheParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearCompilationCacheParams, cancellationToken);

        }
        /// <summary>
        /// Sets the Secure Payment Confirmation transaction mode.
        /// https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
        /// </summary>
        [Experimental]
        public async ValueTask<SetSPCTransactionModeResult> SetSPCTransactionModeAsync(SetSPCTransactionModeParams setSPCTransactionModeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setSPCTransactionModeParams, cancellationToken);

        }
        /// <summary>
        /// Generates a report for testing.
        /// </summary>
        [Experimental]
        public async ValueTask<GenerateTestReportResult> GenerateTestReportAsync(GenerateTestReportParams generateTestReportParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(generateTestReportParams, cancellationToken);

        }
        /// <summary>
        /// Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
        /// </summary>
        [Experimental]
        public async ValueTask<WaitForDebuggerResult> WaitForDebuggerAsync(WaitForDebuggerParams waitForDebuggerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(waitForDebuggerParams, cancellationToken);

        }
        /// <summary>
        /// Intercept file chooser requests and transfer control to protocol clients.
        /// When file chooser interception is enabled, native file chooser dialog is not shown.
        /// Instead, a protocol event `Page.fileChooserOpened` is emitted.
        /// </summary>
        [Experimental]
        public async ValueTask<SetInterceptFileChooserDialogResult> SetInterceptFileChooserDialogAsync(SetInterceptFileChooserDialogParams setInterceptFileChooserDialogParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInterceptFileChooserDialogParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "domContentEventFired": RaiseEvent(DomContentEventFired, messageBytes);
                    break;
                case "fileChooserOpened": RaiseEvent(FileChooserOpened, messageBytes);
                    break;
                case "frameAttached": RaiseEvent(FrameAttached, messageBytes);
                    break;
                case "frameClearedScheduledNavigation": RaiseEvent(FrameClearedScheduledNavigation, messageBytes);
                    break;
                case "frameDetached": RaiseEvent(FrameDetached, messageBytes);
                    break;
                case "frameNavigated": RaiseEvent(FrameNavigated, messageBytes);
                    break;
                case "documentOpened": RaiseEvent(DocumentOpened, messageBytes);
                    break;
                case "frameResized": RaiseEvent(FrameResized, messageBytes);
                    break;
                case "frameRequestedNavigation": RaiseEvent(FrameRequestedNavigation, messageBytes);
                    break;
                case "frameScheduledNavigation": RaiseEvent(FrameScheduledNavigation, messageBytes);
                    break;
                case "frameStartedLoading": RaiseEvent(FrameStartedLoading, messageBytes);
                    break;
                case "frameStoppedLoading": RaiseEvent(FrameStoppedLoading, messageBytes);
                    break;
                case "downloadWillBegin": RaiseEvent(DownloadWillBegin, messageBytes);
                    break;
                case "downloadProgress": RaiseEvent(DownloadProgress, messageBytes);
                    break;
                case "interstitialHidden": RaiseEvent(InterstitialHidden, messageBytes);
                    break;
                case "interstitialShown": RaiseEvent(InterstitialShown, messageBytes);
                    break;
                case "javascriptDialogClosed": RaiseEvent(JavascriptDialogClosed, messageBytes);
                    break;
                case "javascriptDialogOpening": RaiseEvent(JavascriptDialogOpening, messageBytes);
                    break;
                case "lifecycleEvent": RaiseEvent(LifecycleEvent, messageBytes);
                    break;
                case "backForwardCacheNotUsed": RaiseEvent(BackForwardCacheNotUsed, messageBytes);
                    break;
                case "prerenderAttemptCompleted": RaiseEvent(PrerenderAttemptCompleted, messageBytes);
                    break;
                case "loadEventFired": RaiseEvent(LoadEventFired, messageBytes);
                    break;
                case "navigatedWithinDocument": RaiseEvent(NavigatedWithinDocument, messageBytes);
                    break;
                case "screencastFrame": RaiseEvent(ScreencastFrame, messageBytes);
                    break;
                case "screencastVisibilityChanged": RaiseEvent(ScreencastVisibilityChanged, messageBytes);
                    break;
                case "windowOpen": RaiseEvent(WindowOpen, messageBytes);
                    break;
                case "compilationCacheProduced": RaiseEvent(CompilationCacheProduced, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class DomContentEventFiredParams
        {
            /// <summary>
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class FileChooserOpenedParams
        {
            /// <summary>
            /// Id of the frame containing input node.
            /// </summary>
            [Experimental]
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Input mode.
            /// </summary>
            /// <value>
            /// selectSingle,selectMultiple
            /// </value>
            public string Mode
            {
                get; set;
            }
            /// <summary>
            /// Input node id. Only present for file choosers opened via an <input type="file"> element.
            /// </summary>
            [Experimental]
            public int? BackendNodeId
            {
                get; set;
            }

        }
        public class FrameAttachedParams
        {
            /// <summary>
            /// Id of the frame that has been attached.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Parent frame identifier.
            /// </summary>
            public string ParentFrameId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript stack trace of when frame was attached, only set if frame initiated from script.
            /// </summary>
            public RuntimeDomain.StackTrace? Stack
            {
                get; set;
            }
            /// <summary>
            /// Identifies the bottom-most script which caused the frame to be labelled
            /// as an ad. Only sent if frame is labelled as an ad and id is available.
            /// </summary>
            [Experimental]
            public PageDomain.AdScriptId? AdScriptId
            {
                get; set;
            }

        }
        public class FrameClearedScheduledNavigationParams
        {
            /// <summary>
            /// Id of the frame that has cleared its scheduled navigation.
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class FrameDetachedParams
        {
            /// <summary>
            /// Id of the frame that has been detached.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            /// <value>
            /// remove,swap
            /// </value>
            [Experimental]
            public string Reason
            {
                get; set;
            }

        }
        public class FrameNavigatedParams
        {
            /// <summary>
            /// Frame object.
            /// </summary>
            public PageDomain.Frame Frame
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            [Experimental]
            public PageDomain.NavigationType Type
            {
                get; set;
            }

        }
        public class DocumentOpenedParams
        {
            /// <summary>
            /// Frame object.
            /// </summary>
            public PageDomain.Frame Frame
            {
                get; set;
            }

        }
        public class FrameResizedParams
        {

        }
        public class FrameRequestedNavigationParams
        {
            /// <summary>
            /// Id of the frame that is being navigated.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// The reason for the navigation.
            /// </summary>
            public PageDomain.ClientNavigationReason Reason
            {
                get; set;
            }
            /// <summary>
            /// The destination URL for the requested navigation.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// The disposition for the navigation.
            /// </summary>
            public PageDomain.ClientNavigationDisposition Disposition
            {
                get; set;
            }

        }
        public class FrameScheduledNavigationParams
        {
            /// <summary>
            /// Id of the frame that has scheduled a navigation.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
            /// guaranteed to start.
            /// </summary>
            public double Delay
            {
                get; set;
            }
            /// <summary>
            /// The reason for the navigation.
            /// </summary>
            public PageDomain.ClientNavigationReason Reason
            {
                get; set;
            }
            /// <summary>
            /// The destination URL for the scheduled navigation.
            /// </summary>
            public string Url
            {
                get; set;
            }

        }
        public class FrameStartedLoadingParams
        {
            /// <summary>
            /// Id of the frame that has started loading.
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class FrameStoppedLoadingParams
        {
            /// <summary>
            /// Id of the frame that has stopped loading.
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class DownloadWillBeginParams
        {
            /// <summary>
            /// Id of the frame that caused download to begin.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Global unique identifier of the download.
            /// </summary>
            public string Guid
            {
                get; set;
            }
            /// <summary>
            /// URL of the resource being downloaded.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Suggested file name of the resource (the actual name of the file saved on disk may differ).
            /// </summary>
            public string SuggestedFilename
            {
                get; set;
            }

        }
        public class DownloadProgressParams
        {
            /// <summary>
            /// Global unique identifier of the download.
            /// </summary>
            public string Guid
            {
                get; set;
            }
            /// <summary>
            /// Total expected bytes to download.
            /// </summary>
            public double TotalBytes
            {
                get; set;
            }
            /// <summary>
            /// Total bytes received.
            /// </summary>
            public double ReceivedBytes
            {
                get; set;
            }
            /// <summary>
            /// Download status.
            /// </summary>
            /// <value>
            /// inProgress,completed,canceled
            /// </value>
            public string State
            {
                get; set;
            }

        }
        public class InterstitialHiddenParams
        {

        }
        public class InterstitialShownParams
        {

        }
        public class JavascriptDialogClosedParams
        {
            /// <summary>
            /// Whether dialog was confirmed.
            /// </summary>
            public bool Result
            {
                get; set;
            }
            /// <summary>
            /// User input in case of prompt.
            /// </summary>
            public string UserInput
            {
                get; set;
            }

        }
        public class JavascriptDialogOpeningParams
        {
            /// <summary>
            /// Frame url.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Message that will be displayed by the dialog.
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// Dialog type.
            /// </summary>
            public PageDomain.DialogType Type
            {
                get; set;
            }
            /// <summary>
            /// True iff browser is capable showing or acting on the given dialog. When browser has no
            /// dialog handler for given target, calling alert while Page domain is engaged will stall
            /// the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
            /// </summary>
            public bool HasBrowserHandler
            {
                get; set;
            }
            /// <summary>
            /// Default dialog prompt.
            /// </summary>
            public string? DefaultPrompt
            {
                get; set;
            }

        }
        public class LifecycleEventParams
        {
            /// <summary>
            /// Id of the frame.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Loader identifier. Empty string if the request is fetched from worker.
            /// </summary>
            public string LoaderId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class BackForwardCacheNotUsedParams
        {
            /// <summary>
            /// The loader id for the associated navgation.
            /// </summary>
            public string LoaderId
            {
                get; set;
            }
            /// <summary>
            /// The frame id of the associated frame.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Array of reasons why the page could not be cached. This must not be empty.
            /// </summary>
            public PageDomain.BackForwardCacheNotRestoredExplanation[] NotRestoredExplanations
            {
                get; set;
            }
            /// <summary>
            /// Tree structure of reasons why the page could not be cached for each frame.
            /// </summary>
            public PageDomain.BackForwardCacheNotRestoredExplanationTree? NotRestoredExplanationsTree
            {
                get; set;
            }

        }
        public class PrerenderAttemptCompletedParams
        {
            /// <summary>
            /// The frame id of the frame initiating prerendering.
            /// </summary>
            public string InitiatingFrameId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string PrerenderingUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.PrerenderFinalStatus FinalStatus
            {
                get; set;
            }

        }
        public class LoadEventFiredParams
        {
            /// <summary>
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class NavigatedWithinDocumentParams
        {
            /// <summary>
            /// Id of the frame.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Frame's new url.
            /// </summary>
            public string Url
            {
                get; set;
            }

        }
        public class ScreencastFrameParams
        {
            /// <summary>
            /// Base64-encoded compressed image. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Data
            {
                get; set;
            }
            /// <summary>
            /// Screencast frame metadata.
            /// </summary>
            public PageDomain.ScreencastFrameMetadata Metadata
            {
                get; set;
            }
            /// <summary>
            /// Frame number.
            /// </summary>
            public int SessionId
            {
                get; set;
            }

        }
        public class ScreencastVisibilityChangedParams
        {
            /// <summary>
            /// True if the page is visible.
            /// </summary>
            public bool Visible
            {
                get; set;
            }

        }
        public class WindowOpenParams
        {
            /// <summary>
            /// The URL for the new window.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Window name.
            /// </summary>
            public string WindowName
            {
                get; set;
            }
            /// <summary>
            /// An array of enabled window features.
            /// </summary>
            public string[] WindowFeatures
            {
                get; set;
            }
            /// <summary>
            /// Whether or not it was triggered by user gesture.
            /// </summary>
            public bool UserGesture
            {
                get; set;
            }

        }
        public class CompilationCacheProducedParams
        {
            /// <summary>
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Base64-encoded data (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Data
            {
                get; set;
            }

        }
        public class AddScriptToEvaluateOnLoadParams : IMethodParams<AddScriptToEvaluateOnLoadParams, AddScriptToEvaluateOnLoadResult>
        {
            public string GetMethod()
            {
                return "Page.addScriptToEvaluateOnLoad";

            }
            /// <summary>
            /// </summary>
            public string ScriptSource
            {
                get; set;
            }

        }
        public class AddScriptToEvaluateOnLoadResult
        {
            /// <summary>
            /// Identifier of the added script.
            /// </summary>
            public string Identifier
            {
                get; set;
            }

        }
        public class AddScriptToEvaluateOnNewDocumentParams : IMethodParams<AddScriptToEvaluateOnNewDocumentParams, AddScriptToEvaluateOnNewDocumentResult>
        {
            public string GetMethod()
            {
                return "Page.addScriptToEvaluateOnNewDocument";

            }
            /// <summary>
            /// </summary>
            public string Source
            {
                get; set;
            }
            /// <summary>
            /// If specified, creates an isolated world with the given name and evaluates given script in it.
            /// This world name will be used as the ExecutionContextDescription::name when the corresponding
            /// event is emitted.
            /// </summary>
            [Experimental]
            public string? WorldName
            {
                get; set;
            }
            /// <summary>
            /// Specifies whether command line API should be available to the script, defaults
            /// to false.
            /// </summary>
            [Experimental]
            public bool? IncludeCommandLineAPI
            {
                get; set;
            }

        }
        public class AddScriptToEvaluateOnNewDocumentResult
        {
            /// <summary>
            /// Identifier of the added script.
            /// </summary>
            public string Identifier
            {
                get; set;
            }

        }
        public class BringToFrontParams : IMethodParams<BringToFrontParams, BringToFrontResult>
        {
            public string GetMethod()
            {
                return "Page.bringToFront";

            }

        }
        public class BringToFrontResult
        {

        }
        public class CaptureScreenshotParams : IMethodParams<CaptureScreenshotParams, CaptureScreenshotResult>
        {
            public string GetMethod()
            {
                return "Page.captureScreenshot";

            }
            /// <summary>
            /// Image compression format (defaults to png).
            /// </summary>
            /// <value>
            /// jpeg,png,webp
            /// </value>
            public string? Format
            {
                get; set;
            }
            /// <summary>
            /// Compression quality from range [0..100] (jpeg only).
            /// </summary>
            public int? Quality
            {
                get; set;
            }
            /// <summary>
            /// Capture the screenshot of a given region only.
            /// </summary>
            public PageDomain.Viewport? Clip
            {
                get; set;
            }
            /// <summary>
            /// Capture the screenshot from the surface, rather than the view. Defaults to true.
            /// </summary>
            [Experimental]
            public bool? FromSurface
            {
                get; set;
            }
            /// <summary>
            /// Capture the screenshot beyond the viewport. Defaults to false.
            /// </summary>
            [Experimental]
            public bool? CaptureBeyondViewport
            {
                get; set;
            }

        }
        public class CaptureScreenshotResult
        {
            /// <summary>
            /// Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Data
            {
                get; set;
            }

        }
        public class CaptureSnapshotParams : IMethodParams<CaptureSnapshotParams, CaptureSnapshotResult>
        {
            public string GetMethod()
            {
                return "Page.captureSnapshot";

            }
            /// <summary>
            /// Format (defaults to mhtml).
            /// </summary>
            /// <value>
            /// mhtml
            /// </value>
            public string? Format
            {
                get; set;
            }

        }
        public class CaptureSnapshotResult
        {
            /// <summary>
            /// Serialized page data.
            /// </summary>
            public string Data
            {
                get; set;
            }

        }
        public class ClearDeviceMetricsOverrideParams : IMethodParams<ClearDeviceMetricsOverrideParams, ClearDeviceMetricsOverrideResult>
        {
            public string GetMethod()
            {
                return "Page.clearDeviceMetricsOverride";

            }

        }
        public class ClearDeviceMetricsOverrideResult
        {

        }
        public class ClearDeviceOrientationOverrideParams : IMethodParams<ClearDeviceOrientationOverrideParams, ClearDeviceOrientationOverrideResult>
        {
            public string GetMethod()
            {
                return "Page.clearDeviceOrientationOverride";

            }

        }
        public class ClearDeviceOrientationOverrideResult
        {

        }
        public class ClearGeolocationOverrideParams : IMethodParams<ClearGeolocationOverrideParams, ClearGeolocationOverrideResult>
        {
            public string GetMethod()
            {
                return "Page.clearGeolocationOverride";

            }

        }
        public class ClearGeolocationOverrideResult
        {

        }
        public class CreateIsolatedWorldParams : IMethodParams<CreateIsolatedWorldParams, CreateIsolatedWorldResult>
        {
            public string GetMethod()
            {
                return "Page.createIsolatedWorld";

            }
            /// <summary>
            /// Id of the frame in which the isolated world should be created.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// An optional name which is reported in the Execution Context.
            /// </summary>
            public string? WorldName
            {
                get; set;
            }
            /// <summary>
            /// Whether or not universal access should be granted to the isolated world. This is a powerful
            /// option, use with caution.
            /// </summary>
            public bool? GrantUniveralAccess
            {
                get; set;
            }

        }
        public class CreateIsolatedWorldResult
        {
            /// <summary>
            /// Execution context of the isolated world.
            /// </summary>
            public int ExecutionContextId
            {
                get; set;
            }

        }
        public class DeleteCookieParams : IMethodParams<DeleteCookieParams, DeleteCookieResult>
        {
            public string GetMethod()
            {
                return "Page.deleteCookie";

            }
            /// <summary>
            /// Name of the cookie to remove.
            /// </summary>
            public string CookieName
            {
                get; set;
            }
            /// <summary>
            /// URL to match cooke domain and path.
            /// </summary>
            public string Url
            {
                get; set;
            }

        }
        public class DeleteCookieResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Page.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Page.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetAppManifestParams : IMethodParams<GetAppManifestParams, GetAppManifestResult>
        {
            public string GetMethod()
            {
                return "Page.getAppManifest";

            }

        }
        public class GetAppManifestResult
        {
            /// <summary>
            /// Manifest location.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.AppManifestError[] Errors
            {
                get; set;
            }
            /// <summary>
            /// Manifest content.
            /// </summary>
            public string? Data
            {
                get; set;
            }
            /// <summary>
            /// Parsed manifest properties
            /// </summary>
            [Experimental]
            public PageDomain.AppManifestParsedProperties? Parsed
            {
                get; set;
            }

        }
        public class GetInstallabilityErrorsParams : IMethodParams<GetInstallabilityErrorsParams, GetInstallabilityErrorsResult>
        {
            public string GetMethod()
            {
                return "Page.getInstallabilityErrors";

            }

        }
        public class GetInstallabilityErrorsResult
        {
            /// <summary>
            /// </summary>
            public PageDomain.InstallabilityError[] InstallabilityErrors
            {
                get; set;
            }

        }
        public class GetManifestIconsParams : IMethodParams<GetManifestIconsParams, GetManifestIconsResult>
        {
            public string GetMethod()
            {
                return "Page.getManifestIcons";

            }

        }
        public class GetManifestIconsResult
        {
            /// <summary>
            /// </summary>
            public string? PrimaryIcon
            {
                get; set;
            }

        }
        public class GetAppIdParams : IMethodParams<GetAppIdParams, GetAppIdResult>
        {
            public string GetMethod()
            {
                return "Page.getAppId";

            }

        }
        public class GetAppIdResult
        {
            /// <summary>
            /// App id, either from manifest's id attribute or computed from start_url
            /// </summary>
            public string? AppId
            {
                get; set;
            }
            /// <summary>
            /// Recommendation for manifest's id attribute to match current id computed from start_url
            /// </summary>
            public string? RecommendedId
            {
                get; set;
            }

        }
        public class GetCookiesParams : IMethodParams<GetCookiesParams, GetCookiesResult>
        {
            public string GetMethod()
            {
                return "Page.getCookies";

            }

        }
        public class GetCookiesResult
        {
            /// <summary>
            /// Array of cookie objects.
            /// </summary>
            public NetworkDomain.Cookie[] Cookies
            {
                get; set;
            }

        }
        public class GetFrameTreeParams : IMethodParams<GetFrameTreeParams, GetFrameTreeResult>
        {
            public string GetMethod()
            {
                return "Page.getFrameTree";

            }

        }
        public class GetFrameTreeResult
        {
            /// <summary>
            /// Present frame tree structure.
            /// </summary>
            public PageDomain.FrameTree FrameTree
            {
                get; set;
            }

        }
        public class GetLayoutMetricsParams : IMethodParams<GetLayoutMetricsParams, GetLayoutMetricsResult>
        {
            public string GetMethod()
            {
                return "Page.getLayoutMetrics";

            }

        }
        public class GetLayoutMetricsResult
        {
            /// <summary>
            /// Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.
            /// </summary>
            [Obsolete]
            public PageDomain.LayoutViewport LayoutViewport
            {
                get; set;
            }
            /// <summary>
            /// Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.
            /// </summary>
            [Obsolete]
            public PageDomain.VisualViewport VisualViewport
            {
                get; set;
            }
            /// <summary>
            /// Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.
            /// </summary>
            [Obsolete]
            public DOMDomain.Rect ContentSize
            {
                get; set;
            }
            /// <summary>
            /// Metrics relating to the layout viewport in CSS pixels.
            /// </summary>
            public PageDomain.LayoutViewport CssLayoutViewport
            {
                get; set;
            }
            /// <summary>
            /// Metrics relating to the visual viewport in CSS pixels.
            /// </summary>
            public PageDomain.VisualViewport CssVisualViewport
            {
                get; set;
            }
            /// <summary>
            /// Size of scrollable area in CSS pixels.
            /// </summary>
            public DOMDomain.Rect CssContentSize
            {
                get; set;
            }

        }
        public class GetNavigationHistoryParams : IMethodParams<GetNavigationHistoryParams, GetNavigationHistoryResult>
        {
            public string GetMethod()
            {
                return "Page.getNavigationHistory";

            }

        }
        public class GetNavigationHistoryResult
        {
            /// <summary>
            /// Index of the current navigation history entry.
            /// </summary>
            public int CurrentIndex
            {
                get; set;
            }
            /// <summary>
            /// Array of navigation history entries.
            /// </summary>
            public PageDomain.NavigationEntry[] Entries
            {
                get; set;
            }

        }
        public class ResetNavigationHistoryParams : IMethodParams<ResetNavigationHistoryParams, ResetNavigationHistoryResult>
        {
            public string GetMethod()
            {
                return "Page.resetNavigationHistory";

            }

        }
        public class ResetNavigationHistoryResult
        {

        }
        public class GetResourceContentParams : IMethodParams<GetResourceContentParams, GetResourceContentResult>
        {
            public string GetMethod()
            {
                return "Page.getResourceContent";

            }
            /// <summary>
            /// Frame id to get resource for.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// URL of the resource to get content for.
            /// </summary>
            public string Url
            {
                get; set;
            }

        }
        public class GetResourceContentResult
        {
            /// <summary>
            /// Resource content.
            /// </summary>
            public string Content
            {
                get; set;
            }
            /// <summary>
            /// True, if content was served as base64.
            /// </summary>
            public bool Base64Encoded
            {
                get; set;
            }

        }
        public class GetResourceTreeParams : IMethodParams<GetResourceTreeParams, GetResourceTreeResult>
        {
            public string GetMethod()
            {
                return "Page.getResourceTree";

            }

        }
        public class GetResourceTreeResult
        {
            /// <summary>
            /// Present frame / resource tree structure.
            /// </summary>
            public PageDomain.FrameResourceTree FrameTree
            {
                get; set;
            }

        }
        public class HandleJavaScriptDialogParams : IMethodParams<HandleJavaScriptDialogParams, HandleJavaScriptDialogResult>
        {
            public string GetMethod()
            {
                return "Page.handleJavaScriptDialog";

            }
            /// <summary>
            /// Whether to accept or dismiss the dialog.
            /// </summary>
            public bool Accept
            {
                get; set;
            }
            /// <summary>
            /// The text to enter into the dialog prompt before accepting. Used only if this is a prompt
            /// dialog.
            /// </summary>
            public string? PromptText
            {
                get; set;
            }

        }
        public class HandleJavaScriptDialogResult
        {

        }
        public class NavigateParams : IMethodParams<NavigateParams, NavigateResult>
        {
            public string GetMethod()
            {
                return "Page.navigate";

            }
            /// <summary>
            /// URL to navigate the page to.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Referrer URL.
            /// </summary>
            public string? Referrer
            {
                get; set;
            }
            /// <summary>
            /// Intended transition type.
            /// </summary>
            public PageDomain.TransitionType? TransitionType
            {
                get; set;
            }
            /// <summary>
            /// Frame id to navigate, if not specified navigates the top frame.
            /// </summary>
            public string? FrameId
            {
                get; set;
            }
            /// <summary>
            /// Referrer-policy used for the navigation.
            /// </summary>
            [Experimental]
            public PageDomain.ReferrerPolicy? ReferrerPolicy
            {
                get; set;
            }

        }
        public class NavigateResult
        {
            /// <summary>
            /// Frame id that has navigated (or failed to navigate)
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// Loader identifier. This is omitted in case of same-document navigation,
            /// as the previously committed loaderId would not change.
            /// </summary>
            public string? LoaderId
            {
                get; set;
            }
            /// <summary>
            /// User friendly error message, present if and only if navigation has failed.
            /// </summary>
            public string? ErrorText
            {
                get; set;
            }

        }
        public class NavigateToHistoryEntryParams : IMethodParams<NavigateToHistoryEntryParams, NavigateToHistoryEntryResult>
        {
            public string GetMethod()
            {
                return "Page.navigateToHistoryEntry";

            }
            /// <summary>
            /// Unique id of the entry to navigate to.
            /// </summary>
            public int EntryId
            {
                get; set;
            }

        }
        public class NavigateToHistoryEntryResult
        {

        }
        public class PrintToPDFParams : IMethodParams<PrintToPDFParams, PrintToPDFResult>
        {
            public string GetMethod()
            {
                return "Page.printToPDF";

            }
            /// <summary>
            /// Paper orientation. Defaults to false.
            /// </summary>
            public bool? Landscape
            {
                get; set;
            }
            /// <summary>
            /// Display header and footer. Defaults to false.
            /// </summary>
            public bool? DisplayHeaderFooter
            {
                get; set;
            }
            /// <summary>
            /// Print background graphics. Defaults to false.
            /// </summary>
            public bool? PrintBackground
            {
                get; set;
            }
            /// <summary>
            /// Scale of the webpage rendering. Defaults to 1.
            /// </summary>
            public double? Scale
            {
                get; set;
            }
            /// <summary>
            /// Paper width in inches. Defaults to 8.5 inches.
            /// </summary>
            public double? PaperWidth
            {
                get; set;
            }
            /// <summary>
            /// Paper height in inches. Defaults to 11 inches.
            /// </summary>
            public double? PaperHeight
            {
                get; set;
            }
            /// <summary>
            /// Top margin in inches. Defaults to 1cm (~0.4 inches).
            /// </summary>
            public double? MarginTop
            {
                get; set;
            }
            /// <summary>
            /// Bottom margin in inches. Defaults to 1cm (~0.4 inches).
            /// </summary>
            public double? MarginBottom
            {
                get; set;
            }
            /// <summary>
            /// Left margin in inches. Defaults to 1cm (~0.4 inches).
            /// </summary>
            public double? MarginLeft
            {
                get; set;
            }
            /// <summary>
            /// Right margin in inches. Defaults to 1cm (~0.4 inches).
            /// </summary>
            public double? MarginRight
            {
                get; set;
            }
            /// <summary>
            /// Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
            /// printed in the document order, not in the order specified, and no
            /// more than once.
            /// Defaults to empty string, which implies the entire document is printed.
            /// The page numbers are quietly capped to actual page count of the
            /// document, and ranges beyond the end of the document are ignored.
            /// If this results in no pages to print, an error is reported.
            /// It is an error to specify a range with start greater than end.
            /// </summary>
            public string? PageRanges
            {
                get; set;
            }
            /// <summary>
            /// HTML template for the print header. Should be valid HTML markup with following
            /// classes used to inject printing values into them:
            /// - `date`: formatted print date
            /// - `title`: document title
            /// - `url`: document location
            /// - `pageNumber`: current page number
            /// - `totalPages`: total pages in the document
            /// 
            /// For example, `<span class=title></span>` would generate span containing the title.
            /// </summary>
            public string? HeaderTemplate
            {
                get; set;
            }
            /// <summary>
            /// HTML template for the print footer. Should use the same format as the `headerTemplate`.
            /// </summary>
            public string? FooterTemplate
            {
                get; set;
            }
            /// <summary>
            /// Whether or not to prefer page size as defined by css. Defaults to false,
            /// in which case the content will be scaled to fit the paper size.
            /// </summary>
            public bool? PreferCSSPageSize
            {
                get; set;
            }
            /// <summary>
            /// return as stream
            /// </summary>
            /// <value>
            /// ReturnAsBase64,ReturnAsStream
            /// </value>
            [Experimental]
            public string? TransferMode
            {
                get; set;
            }

        }
        public class PrintToPDFResult
        {
            /// <summary>
            /// Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Data
            {
                get; set;
            }
            /// <summary>
            /// A handle of the stream that holds resulting PDF data.
            /// </summary>
            [Experimental]
            public string? Stream
            {
                get; set;
            }

        }
        public class ReloadParams : IMethodParams<ReloadParams, ReloadResult>
        {
            public string GetMethod()
            {
                return "Page.reload";

            }
            /// <summary>
            /// If true, browser cache is ignored (as if the user pressed Shift+refresh).
            /// </summary>
            public bool? IgnoreCache
            {
                get; set;
            }
            /// <summary>
            /// If set, the script will be injected into all frames of the inspected page after reload.
            /// Argument will be ignored if reloading dataURL origin.
            /// </summary>
            public string? ScriptToEvaluateOnLoad
            {
                get; set;
            }

        }
        public class ReloadResult
        {

        }
        public class RemoveScriptToEvaluateOnLoadParams : IMethodParams<RemoveScriptToEvaluateOnLoadParams, RemoveScriptToEvaluateOnLoadResult>
        {
            public string GetMethod()
            {
                return "Page.removeScriptToEvaluateOnLoad";

            }
            /// <summary>
            /// </summary>
            public string Identifier
            {
                get; set;
            }

        }
        public class RemoveScriptToEvaluateOnLoadResult
        {

        }
        public class RemoveScriptToEvaluateOnNewDocumentParams : IMethodParams<RemoveScriptToEvaluateOnNewDocumentParams, RemoveScriptToEvaluateOnNewDocumentResult>
        {
            public string GetMethod()
            {
                return "Page.removeScriptToEvaluateOnNewDocument";

            }
            /// <summary>
            /// </summary>
            public string Identifier
            {
                get; set;
            }

        }
        public class RemoveScriptToEvaluateOnNewDocumentResult
        {

        }
        public class ScreencastFrameAckParams : IMethodParams<ScreencastFrameAckParams, ScreencastFrameAckResult>
        {
            public string GetMethod()
            {
                return "Page.screencastFrameAck";

            }
            /// <summary>
            /// Frame number.
            /// </summary>
            public int SessionId
            {
                get; set;
            }

        }
        public class ScreencastFrameAckResult
        {

        }
        public class SearchInResourceParams : IMethodParams<SearchInResourceParams, SearchInResourceResult>
        {
            public string GetMethod()
            {
                return "Page.searchInResource";

            }
            /// <summary>
            /// Frame id for resource to search in.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// URL of the resource to search in.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// String to search for.
            /// </summary>
            public string Query
            {
                get; set;
            }
            /// <summary>
            /// If true, search is case sensitive.
            /// </summary>
            public bool? CaseSensitive
            {
                get; set;
            }
            /// <summary>
            /// If true, treats string parameter as regex.
            /// </summary>
            public bool? IsRegex
            {
                get; set;
            }

        }
        public class SearchInResourceResult
        {
            /// <summary>
            /// List of search matches.
            /// </summary>
            public DebuggerDomain.SearchMatch[] Result
            {
                get; set;
            }

        }
        public class SetAdBlockingEnabledParams : IMethodParams<SetAdBlockingEnabledParams, SetAdBlockingEnabledResult>
        {
            public string GetMethod()
            {
                return "Page.setAdBlockingEnabled";

            }
            /// <summary>
            /// Whether to block ads.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetAdBlockingEnabledResult
        {

        }
        public class SetBypassCSPParams : IMethodParams<SetBypassCSPParams, SetBypassCSPResult>
        {
            public string GetMethod()
            {
                return "Page.setBypassCSP";

            }
            /// <summary>
            /// Whether to bypass page CSP.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetBypassCSPResult
        {

        }
        public class GetPermissionsPolicyStateParams : IMethodParams<GetPermissionsPolicyStateParams, GetPermissionsPolicyStateResult>
        {
            public string GetMethod()
            {
                return "Page.getPermissionsPolicyState";

            }
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class GetPermissionsPolicyStateResult
        {
            /// <summary>
            /// </summary>
            public PageDomain.PermissionsPolicyFeatureState[] States
            {
                get; set;
            }

        }
        public class GetOriginTrialsParams : IMethodParams<GetOriginTrialsParams, GetOriginTrialsResult>
        {
            public string GetMethod()
            {
                return "Page.getOriginTrials";

            }
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class GetOriginTrialsResult
        {
            /// <summary>
            /// </summary>
            public PageDomain.OriginTrial[] OriginTrials
            {
                get; set;
            }

        }
        public class SetDeviceMetricsOverrideParams : IMethodParams<SetDeviceMetricsOverrideParams, SetDeviceMetricsOverrideResult>
        {
            public string GetMethod()
            {
                return "Page.setDeviceMetricsOverride";

            }
            /// <summary>
            /// Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
            /// </summary>
            public int Width
            {
                get; set;
            }
            /// <summary>
            /// Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
            /// </summary>
            public int Height
            {
                get; set;
            }
            /// <summary>
            /// Overriding device scale factor value. 0 disables the override.
            /// </summary>
            public double DeviceScaleFactor
            {
                get; set;
            }
            /// <summary>
            /// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
            /// autosizing and more.
            /// </summary>
            public bool Mobile
            {
                get; set;
            }
            /// <summary>
            /// Scale to apply to resulting view image.
            /// </summary>
            public double? Scale
            {
                get; set;
            }
            /// <summary>
            /// Overriding screen width value in pixels (minimum 0, maximum 10000000).
            /// </summary>
            public int? ScreenWidth
            {
                get; set;
            }
            /// <summary>
            /// Overriding screen height value in pixels (minimum 0, maximum 10000000).
            /// </summary>
            public int? ScreenHeight
            {
                get; set;
            }
            /// <summary>
            /// Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
            /// </summary>
            public int? PositionX
            {
                get; set;
            }
            /// <summary>
            /// Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
            /// </summary>
            public int? PositionY
            {
                get; set;
            }
            /// <summary>
            /// Do not set visible view size, rely upon explicit setVisibleSize call.
            /// </summary>
            public bool? DontSetVisibleSize
            {
                get; set;
            }
            /// <summary>
            /// Screen orientation override.
            /// </summary>
            public EmulationDomain.ScreenOrientation? ScreenOrientation
            {
                get; set;
            }
            /// <summary>
            /// The viewport dimensions and scale. If not set, the override is cleared.
            /// </summary>
            public PageDomain.Viewport? Viewport
            {
                get; set;
            }

        }
        public class SetDeviceMetricsOverrideResult
        {

        }
        public class SetDeviceOrientationOverrideParams : IMethodParams<SetDeviceOrientationOverrideParams, SetDeviceOrientationOverrideResult>
        {
            public string GetMethod()
            {
                return "Page.setDeviceOrientationOverride";

            }
            /// <summary>
            /// Mock alpha
            /// </summary>
            public double Alpha
            {
                get; set;
            }
            /// <summary>
            /// Mock beta
            /// </summary>
            public double Beta
            {
                get; set;
            }
            /// <summary>
            /// Mock gamma
            /// </summary>
            public double Gamma
            {
                get; set;
            }

        }
        public class SetDeviceOrientationOverrideResult
        {

        }
        public class SetFontFamiliesParams : IMethodParams<SetFontFamiliesParams, SetFontFamiliesResult>
        {
            public string GetMethod()
            {
                return "Page.setFontFamilies";

            }
            /// <summary>
            /// Specifies font families to set. If a font family is not specified, it won't be changed.
            /// </summary>
            public PageDomain.FontFamilies FontFamilies
            {
                get; set;
            }
            /// <summary>
            /// Specifies font families to set for individual scripts.
            /// </summary>
            public PageDomain.ScriptFontFamilies[]? ForScripts
            {
                get; set;
            }

        }
        public class SetFontFamiliesResult
        {

        }
        public class SetFontSizesParams : IMethodParams<SetFontSizesParams, SetFontSizesResult>
        {
            public string GetMethod()
            {
                return "Page.setFontSizes";

            }
            /// <summary>
            /// Specifies font sizes to set. If a font size is not specified, it won't be changed.
            /// </summary>
            public PageDomain.FontSizes FontSizes
            {
                get; set;
            }

        }
        public class SetFontSizesResult
        {

        }
        public class SetDocumentContentParams : IMethodParams<SetDocumentContentParams, SetDocumentContentResult>
        {
            public string GetMethod()
            {
                return "Page.setDocumentContent";

            }
            /// <summary>
            /// Frame id to set HTML for.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// HTML content to set.
            /// </summary>
            public string Html
            {
                get; set;
            }

        }
        public class SetDocumentContentResult
        {

        }
        public class SetDownloadBehaviorParams : IMethodParams<SetDownloadBehaviorParams, SetDownloadBehaviorResult>
        {
            public string GetMethod()
            {
                return "Page.setDownloadBehavior";

            }
            /// <summary>
            /// Whether to allow all or deny all download requests, or use default Chrome behavior if
            /// available (otherwise deny).
            /// </summary>
            /// <value>
            /// deny,allow,default
            /// </value>
            public string Behavior
            {
                get; set;
            }
            /// <summary>
            /// The default path to save downloaded files to. This is required if behavior is set to 'allow'
            /// </summary>
            public string? DownloadPath
            {
                get; set;
            }

        }
        public class SetDownloadBehaviorResult
        {

        }
        public class SetGeolocationOverrideParams : IMethodParams<SetGeolocationOverrideParams, SetGeolocationOverrideResult>
        {
            public string GetMethod()
            {
                return "Page.setGeolocationOverride";

            }
            /// <summary>
            /// Mock latitude
            /// </summary>
            public double? Latitude
            {
                get; set;
            }
            /// <summary>
            /// Mock longitude
            /// </summary>
            public double? Longitude
            {
                get; set;
            }
            /// <summary>
            /// Mock accuracy
            /// </summary>
            public double? Accuracy
            {
                get; set;
            }

        }
        public class SetGeolocationOverrideResult
        {

        }
        public class SetLifecycleEventsEnabledParams : IMethodParams<SetLifecycleEventsEnabledParams, SetLifecycleEventsEnabledResult>
        {
            public string GetMethod()
            {
                return "Page.setLifecycleEventsEnabled";

            }
            /// <summary>
            /// If true, starts emitting lifecycle events.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetLifecycleEventsEnabledResult
        {

        }
        public class SetTouchEmulationEnabledParams : IMethodParams<SetTouchEmulationEnabledParams, SetTouchEmulationEnabledResult>
        {
            public string GetMethod()
            {
                return "Page.setTouchEmulationEnabled";

            }
            /// <summary>
            /// Whether the touch event emulation should be enabled.
            /// </summary>
            public bool Enabled
            {
                get; set;
            }
            /// <summary>
            /// Touch/gesture events configuration. Default: current platform.
            /// </summary>
            /// <value>
            /// mobile,desktop
            /// </value>
            public string? Configuration
            {
                get; set;
            }

        }
        public class SetTouchEmulationEnabledResult
        {

        }
        public class StartScreencastParams : IMethodParams<StartScreencastParams, StartScreencastResult>
        {
            public string GetMethod()
            {
                return "Page.startScreencast";

            }
            /// <summary>
            /// Image compression format.
            /// </summary>
            /// <value>
            /// jpeg,png
            /// </value>
            public string? Format
            {
                get; set;
            }
            /// <summary>
            /// Compression quality from range [0..100].
            /// </summary>
            public int? Quality
            {
                get; set;
            }
            /// <summary>
            /// Maximum screenshot width.
            /// </summary>
            public int? MaxWidth
            {
                get; set;
            }
            /// <summary>
            /// Maximum screenshot height.
            /// </summary>
            public int? MaxHeight
            {
                get; set;
            }
            /// <summary>
            /// Send every n-th frame.
            /// </summary>
            public int? EveryNthFrame
            {
                get; set;
            }

        }
        public class StartScreencastResult
        {

        }
        public class StopLoadingParams : IMethodParams<StopLoadingParams, StopLoadingResult>
        {
            public string GetMethod()
            {
                return "Page.stopLoading";

            }

        }
        public class StopLoadingResult
        {

        }
        public class CrashParams : IMethodParams<CrashParams, CrashResult>
        {
            public string GetMethod()
            {
                return "Page.crash";

            }

        }
        public class CrashResult
        {

        }
        public class CloseParams : IMethodParams<CloseParams, CloseResult>
        {
            public string GetMethod()
            {
                return "Page.close";

            }

        }
        public class CloseResult
        {

        }
        public class SetWebLifecycleStateParams : IMethodParams<SetWebLifecycleStateParams, SetWebLifecycleStateResult>
        {
            public string GetMethod()
            {
                return "Page.setWebLifecycleState";

            }
            /// <summary>
            /// Target lifecycle state
            /// </summary>
            /// <value>
            /// frozen,active
            /// </value>
            public string State
            {
                get; set;
            }

        }
        public class SetWebLifecycleStateResult
        {

        }
        public class StopScreencastParams : IMethodParams<StopScreencastParams, StopScreencastResult>
        {
            public string GetMethod()
            {
                return "Page.stopScreencast";

            }

        }
        public class StopScreencastResult
        {

        }
        public class ProduceCompilationCacheParams : IMethodParams<ProduceCompilationCacheParams, ProduceCompilationCacheResult>
        {
            public string GetMethod()
            {
                return "Page.produceCompilationCache";

            }
            /// <summary>
            /// </summary>
            public PageDomain.CompilationCacheParams[] Scripts
            {
                get; set;
            }

        }
        public class ProduceCompilationCacheResult
        {

        }
        public class AddCompilationCacheParams : IMethodParams<AddCompilationCacheParams, AddCompilationCacheResult>
        {
            public string GetMethod()
            {
                return "Page.addCompilationCache";

            }
            /// <summary>
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Base64-encoded data (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Data
            {
                get; set;
            }

        }
        public class AddCompilationCacheResult
        {

        }
        public class ClearCompilationCacheParams : IMethodParams<ClearCompilationCacheParams, ClearCompilationCacheResult>
        {
            public string GetMethod()
            {
                return "Page.clearCompilationCache";

            }

        }
        public class ClearCompilationCacheResult
        {

        }
        public class SetSPCTransactionModeParams : IMethodParams<SetSPCTransactionModeParams, SetSPCTransactionModeResult>
        {
            public string GetMethod()
            {
                return "Page.setSPCTransactionMode";

            }
            /// <summary>
            /// </summary>
            /// <value>
            /// none,autoaccept,autoreject
            /// </value>
            public string Mode
            {
                get; set;
            }

        }
        public class SetSPCTransactionModeResult
        {

        }
        public class GenerateTestReportParams : IMethodParams<GenerateTestReportParams, GenerateTestReportResult>
        {
            public string GetMethod()
            {
                return "Page.generateTestReport";

            }
            /// <summary>
            /// Message to be displayed in the report.
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// Specifies the endpoint group to deliver the report to.
            /// </summary>
            public string? Group
            {
                get; set;
            }

        }
        public class GenerateTestReportResult
        {

        }
        public class WaitForDebuggerParams : IMethodParams<WaitForDebuggerParams, WaitForDebuggerResult>
        {
            public string GetMethod()
            {
                return "Page.waitForDebugger";

            }

        }
        public class WaitForDebuggerResult
        {

        }
        public class SetInterceptFileChooserDialogParams : IMethodParams<SetInterceptFileChooserDialogParams, SetInterceptFileChooserDialogResult>
        {
            public string GetMethod()
            {
                return "Page.setInterceptFileChooserDialog";

            }
            /// <summary>
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetInterceptFileChooserDialogResult
        {

        }
        /// <summary>
        /// Indicates whether a frame has been identified as an ad.
        /// </summary>
        [Experimental]
        public enum AdFrameType
        {
            [EnumValue("none")]
            None = 1,
            [EnumValue("child")]
            Child = 2,
            [EnumValue("root")]
            Root = 3,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum AdFrameExplanation
        {
            [EnumValue("ParentIsAd")]
            ParentIsAd = 1,
            [EnumValue("CreatedByAdScript")]
            CreatedByAdScript = 2,
            [EnumValue("MatchedBlockingRule")]
            MatchedBlockingRule = 3,

        }
        /// <summary>
        /// Indicates whether a frame has been identified as an ad and why.
        /// </summary>
        [Experimental]
        public class AdFrameStatus
        {
            /// <summary>
            /// </summary>
            public PageDomain.AdFrameType AdFrameType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.AdFrameExplanation[]? Explanations
            {
                get; set;
            }

        }
        /// <summary>
        /// Identifies the bottom-most script which caused the frame to be labelled
        /// as an ad.
        /// </summary>
        [Experimental]
        public class AdScriptId
        {
            /// <summary>
            /// Script Id of the bottom-most script which caused the frame to be labelled
            /// as an ad.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// Id of adScriptId's debugger.
            /// </summary>
            public string DebuggerId
            {
                get; set;
            }

        }
        /// <summary>
        /// Indicates whether the frame is a secure context and why it is the case.
        /// </summary>
        [Experimental]
        public enum SecureContextType
        {
            [EnumValue("Secure")]
            Secure = 1,
            [EnumValue("SecureLocalhost")]
            SecureLocalhost = 2,
            [EnumValue("InsecureScheme")]
            InsecureScheme = 3,
            [EnumValue("InsecureAncestor")]
            InsecureAncestor = 4,

        }
        /// <summary>
        /// Indicates whether the frame is cross-origin isolated and why it is the case.
        /// </summary>
        [Experimental]
        public enum CrossOriginIsolatedContextType
        {
            [EnumValue("Isolated")]
            Isolated = 1,
            [EnumValue("NotIsolated")]
            NotIsolated = 2,
            [EnumValue("NotIsolatedFeatureDisabled")]
            NotIsolatedFeatureDisabled = 3,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum GatedAPIFeatures
        {
            [EnumValue("SharedArrayBuffers")]
            SharedArrayBuffers = 1,
            [EnumValue("SharedArrayBuffersTransferAllowed")]
            SharedArrayBuffersTransferAllowed = 2,
            [EnumValue("PerformanceMeasureMemory")]
            PerformanceMeasureMemory = 3,
            [EnumValue("PerformanceProfile")]
            PerformanceProfile = 4,

        }
        /// <summary>
        /// All Permissions Policy features. This enum should match the one defined
        /// in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
        /// </summary>
        [Experimental]
        public enum PermissionsPolicyFeature
        {
            [EnumValue("accelerometer")]
            Accelerometer = 1,
            [EnumValue("ambient-light-sensor")]
            AmbientLightSensor = 2,
            [EnumValue("attribution-reporting")]
            AttributionReporting = 3,
            [EnumValue("autoplay")]
            Autoplay = 4,
            [EnumValue("bluetooth")]
            Bluetooth = 5,
            [EnumValue("browsing-topics")]
            BrowsingTopics = 6,
            [EnumValue("camera")]
            Camera = 7,
            [EnumValue("ch-dpr")]
            ChDpr = 8,
            [EnumValue("ch-device-memory")]
            ChDeviceMemory = 9,
            [EnumValue("ch-downlink")]
            ChDownlink = 10,
            [EnumValue("ch-ect")]
            ChEct = 11,
            [EnumValue("ch-prefers-color-scheme")]
            ChPrefersColorScheme = 12,
            [EnumValue("ch-rtt")]
            ChRtt = 13,
            [EnumValue("ch-save-data")]
            ChSaveData = 14,
            [EnumValue("ch-ua")]
            ChUa = 15,
            [EnumValue("ch-ua-arch")]
            ChUaArch = 16,
            [EnumValue("ch-ua-bitness")]
            ChUaBitness = 17,
            [EnumValue("ch-ua-platform")]
            ChUaPlatform = 18,
            [EnumValue("ch-ua-model")]
            ChUaModel = 19,
            [EnumValue("ch-ua-mobile")]
            ChUaMobile = 20,
            [EnumValue("ch-ua-full")]
            ChUaFull = 21,
            [EnumValue("ch-ua-full-version")]
            ChUaFullVersion = 22,
            [EnumValue("ch-ua-full-version-list")]
            ChUaFullVersionList = 23,
            [EnumValue("ch-ua-platform-version")]
            ChUaPlatformVersion = 24,
            [EnumValue("ch-ua-reduced")]
            ChUaReduced = 25,
            [EnumValue("ch-ua-wow64")]
            ChUaWow64 = 26,
            [EnumValue("ch-viewport-height")]
            ChViewportHeight = 27,
            [EnumValue("ch-viewport-width")]
            ChViewportWidth = 28,
            [EnumValue("ch-width")]
            ChWidth = 29,
            [EnumValue("clipboard-read")]
            ClipboardRead = 30,
            [EnumValue("clipboard-write")]
            ClipboardWrite = 31,
            [EnumValue("cross-origin-isolated")]
            CrossOriginIsolated = 32,
            [EnumValue("direct-sockets")]
            DirectSockets = 33,
            [EnumValue("display-capture")]
            DisplayCapture = 34,
            [EnumValue("document-domain")]
            DocumentDomain = 35,
            [EnumValue("encrypted-media")]
            EncryptedMedia = 36,
            [EnumValue("execution-while-out-of-viewport")]
            ExecutionWhileOutOfViewport = 37,
            [EnumValue("execution-while-not-rendered")]
            ExecutionWhileNotRendered = 38,
            [EnumValue("federated-credentials")]
            FederatedCredentials = 39,
            [EnumValue("focus-without-user-activation")]
            FocusWithoutUserActivation = 40,
            [EnumValue("fullscreen")]
            Fullscreen = 41,
            [EnumValue("frobulate")]
            Frobulate = 42,
            [EnumValue("gamepad")]
            Gamepad = 43,
            [EnumValue("geolocation")]
            Geolocation = 44,
            [EnumValue("gyroscope")]
            Gyroscope = 45,
            [EnumValue("hid")]
            Hid = 46,
            [EnumValue("idle-detection")]
            IdleDetection = 47,
            [EnumValue("interest-cohort")]
            InterestCohort = 48,
            [EnumValue("join-ad-interest-group")]
            JoinAdInterestGroup = 49,
            [EnumValue("keyboard-map")]
            KeyboardMap = 50,
            [EnumValue("local-fonts")]
            LocalFonts = 51,
            [EnumValue("magnetometer")]
            Magnetometer = 52,
            [EnumValue("microphone")]
            Microphone = 53,
            [EnumValue("midi")]
            Midi = 54,
            [EnumValue("otp-credentials")]
            OtpCredentials = 55,
            [EnumValue("payment")]
            Payment = 56,
            [EnumValue("picture-in-picture")]
            PictureInPicture = 57,
            [EnumValue("publickey-credentials-get")]
            PublickeyCredentialsGet = 58,
            [EnumValue("run-ad-auction")]
            RunAdAuction = 59,
            [EnumValue("screen-wake-lock")]
            ScreenWakeLock = 60,
            [EnumValue("serial")]
            Serial = 61,
            [EnumValue("shared-autofill")]
            SharedAutofill = 62,
            [EnumValue("shared-storage")]
            SharedStorage = 63,
            [EnumValue("storage-access-api")]
            StorageAccessApi = 64,
            [EnumValue("sync-xhr")]
            SyncXhr = 65,
            [EnumValue("trust-token-redemption")]
            TrustTokenRedemption = 66,
            [EnumValue("usb")]
            Usb = 67,
            [EnumValue("vertical-scroll")]
            VerticalScroll = 68,
            [EnumValue("web-share")]
            WebShare = 69,
            [EnumValue("window-placement")]
            WindowPlacement = 70,
            [EnumValue("xr-spatial-tracking")]
            XrSpatialTracking = 71,

        }
        /// <summary>
        /// Reason for a permissions policy feature to be disabled.
        /// </summary>
        [Experimental]
        public enum PermissionsPolicyBlockReason
        {
            [EnumValue("Header")]
            Header = 1,
            [EnumValue("IframeAttribute")]
            IframeAttribute = 2,
            [EnumValue("InFencedFrameTree")]
            InFencedFrameTree = 3,
            [EnumValue("InIsolatedApp")]
            InIsolatedApp = 4,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class PermissionsPolicyBlockLocator
        {
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.PermissionsPolicyBlockReason BlockReason
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class PermissionsPolicyFeatureState
        {
            /// <summary>
            /// </summary>
            public PageDomain.PermissionsPolicyFeature Feature
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool Allowed
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.PermissionsPolicyBlockLocator? Locator
            {
                get; set;
            }

        }
        /// <summary>
        /// Origin Trial(https://www.chromium.org/blink/origin-trials) support.
        /// Status for an Origin Trial token.
        /// </summary>
        [Experimental]
        public enum OriginTrialTokenStatus
        {
            [EnumValue("Success")]
            Success = 1,
            [EnumValue("NotSupported")]
            NotSupported = 2,
            [EnumValue("Insecure")]
            Insecure = 3,
            [EnumValue("Expired")]
            Expired = 4,
            [EnumValue("WrongOrigin")]
            WrongOrigin = 5,
            [EnumValue("InvalidSignature")]
            InvalidSignature = 6,
            [EnumValue("Malformed")]
            Malformed = 7,
            [EnumValue("WrongVersion")]
            WrongVersion = 8,
            [EnumValue("FeatureDisabled")]
            FeatureDisabled = 9,
            [EnumValue("TokenDisabled")]
            TokenDisabled = 10,
            [EnumValue("FeatureDisabledForUser")]
            FeatureDisabledForUser = 11,
            [EnumValue("UnknownTrial")]
            UnknownTrial = 12,

        }
        /// <summary>
        /// Status for an Origin Trial.
        /// </summary>
        [Experimental]
        public enum OriginTrialStatus
        {
            [EnumValue("Enabled")]
            Enabled = 1,
            [EnumValue("ValidTokenNotProvided")]
            ValidTokenNotProvided = 2,
            [EnumValue("OSNotSupported")]
            OSNotSupported = 3,
            [EnumValue("TrialNotAllowed")]
            TrialNotAllowed = 4,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum OriginTrialUsageRestriction
        {
            [EnumValue("None")]
            None = 1,
            [EnumValue("Subset")]
            Subset = 2,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class OriginTrialToken
        {
            /// <summary>
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool MatchSubDomains
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string TrialName
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double ExpiryTime
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsThirdParty
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.OriginTrialUsageRestriction UsageRestriction
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class OriginTrialTokenWithStatus
        {
            /// <summary>
            /// </summary>
            public string RawTokenText
            {
                get; set;
            }
            /// <summary>
            /// `parsedToken` is present only when the token is extractable and
            /// parsable.
            /// </summary>
            public PageDomain.OriginTrialToken? ParsedToken
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.OriginTrialTokenStatus Status
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class OriginTrial
        {
            /// <summary>
            /// </summary>
            public string TrialName
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.OriginTrialStatus Status
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PageDomain.OriginTrialTokenWithStatus[] TokensWithStatus
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the Frame on the page.
        /// </summary>
        public class Frame
        {
            /// <summary>
            /// Frame unique identifier.
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// Parent frame identifier.
            /// </summary>
            public string? ParentId
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the loader associated with this frame.
            /// </summary>
            public string LoaderId
            {
                get; set;
            }
            /// <summary>
            /// Frame's name as specified in the tag.
            /// </summary>
            public string? Name
            {
                get; set;
            }
            /// <summary>
            /// Frame document's URL without fragment.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Frame document's URL fragment including the '#'.
            /// </summary>
            [Experimental]
            public string? UrlFragment
            {
                get; set;
            }
            /// <summary>
            /// Frame document's registered domain, taking the public suffixes list into account.
            /// Extracted from the Frame's url.
            /// Example URLs: http://www.google.com/file.html -> "google.com"
            ///               http://a.b.co.uk/file.html      -> "b.co.uk"
            /// </summary>
            [Experimental]
            public string DomainAndRegistry
            {
                get; set;
            }
            /// <summary>
            /// Frame document's security origin.
            /// </summary>
            public string SecurityOrigin
            {
                get; set;
            }
            /// <summary>
            /// Frame document's mimeType as determined by the browser.
            /// </summary>
            public string MimeType
            {
                get; set;
            }
            /// <summary>
            /// If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
            /// </summary>
            [Experimental]
            public string? UnreachableUrl
            {
                get; set;
            }
            /// <summary>
            /// Indicates whether this frame was tagged as an ad and why.
            /// </summary>
            [Experimental]
            public PageDomain.AdFrameStatus? AdFrameStatus
            {
                get; set;
            }
            /// <summary>
            /// Indicates whether the main document is a secure context and explains why that is the case.
            /// </summary>
            [Experimental]
            public PageDomain.SecureContextType SecureContextType
            {
                get; set;
            }
            /// <summary>
            /// Indicates whether this is a cross origin isolated context.
            /// </summary>
            [Experimental]
            public PageDomain.CrossOriginIsolatedContextType CrossOriginIsolatedContextType
            {
                get; set;
            }
            /// <summary>
            /// Indicated which gated APIs / features are available.
            /// </summary>
            [Experimental]
            public PageDomain.GatedAPIFeatures[] GatedAPIFeatures
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the Resource on the page.
        /// </summary>
        [Experimental]
        public class FrameResource
        {
            /// <summary>
            /// Resource URL.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Type of this resource.
            /// </summary>
            public NetworkDomain.ResourceType Type
            {
                get; set;
            }
            /// <summary>
            /// Resource mimeType as determined by the browser.
            /// </summary>
            public string MimeType
            {
                get; set;
            }
            /// <summary>
            /// last-modified timestamp as reported by server.
            /// </summary>
            public double? LastModified
            {
                get; set;
            }
            /// <summary>
            /// Resource content size.
            /// </summary>
            public double? ContentSize
            {
                get; set;
            }
            /// <summary>
            /// True if the resource failed to load.
            /// </summary>
            public bool? Failed
            {
                get; set;
            }
            /// <summary>
            /// True if the resource was canceled during loading.
            /// </summary>
            public bool? Canceled
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the Frame hierarchy along with their cached resources.
        /// </summary>
        [Experimental]
        public class FrameResourceTree
        {
            /// <summary>
            /// Frame information for this tree item.
            /// </summary>
            public PageDomain.Frame Frame
            {
                get; set;
            }
            /// <summary>
            /// Child frames.
            /// </summary>
            public PageDomain.FrameResourceTree[]? ChildFrames
            {
                get; set;
            }
            /// <summary>
            /// Information about frame resources.
            /// </summary>
            public PageDomain.FrameResource[] Resources
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about the Frame hierarchy.
        /// </summary>
        public class FrameTree
        {
            /// <summary>
            /// Frame information for this tree item.
            /// </summary>
            public PageDomain.Frame Frame
            {
                get; set;
            }
            /// <summary>
            /// Child frames.
            /// </summary>
            public PageDomain.FrameTree[]? ChildFrames
            {
                get; set;
            }

        }
        /// <summary>
        /// Transition type.
        /// </summary>
        public enum TransitionType
        {
            [EnumValue("link")]
            Link = 1,
            [EnumValue("typed")]
            Typed = 2,
            [EnumValue("address_bar")]
            Address_bar = 3,
            [EnumValue("auto_bookmark")]
            Auto_bookmark = 4,
            [EnumValue("auto_subframe")]
            Auto_subframe = 5,
            [EnumValue("manual_subframe")]
            Manual_subframe = 6,
            [EnumValue("generated")]
            Generated = 7,
            [EnumValue("auto_toplevel")]
            Auto_toplevel = 8,
            [EnumValue("form_submit")]
            Form_submit = 9,
            [EnumValue("reload")]
            Reload = 10,
            [EnumValue("keyword")]
            Keyword = 11,
            [EnumValue("keyword_generated")]
            Keyword_generated = 12,
            [EnumValue("other")]
            Other = 13,

        }
        /// <summary>
        /// Navigation history entry.
        /// </summary>
        public class NavigationEntry
        {
            /// <summary>
            /// Unique id of the navigation history entry.
            /// </summary>
            public int Id
            {
                get; set;
            }
            /// <summary>
            /// URL of the navigation history entry.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// URL that the user typed in the url bar.
            /// </summary>
            public string UserTypedURL
            {
                get; set;
            }
            /// <summary>
            /// Title of the navigation history entry.
            /// </summary>
            public string Title
            {
                get; set;
            }
            /// <summary>
            /// Transition type.
            /// </summary>
            public PageDomain.TransitionType TransitionType
            {
                get; set;
            }

        }
        /// <summary>
        /// Screencast frame metadata.
        /// </summary>
        [Experimental]
        public class ScreencastFrameMetadata
        {
            /// <summary>
            /// Top offset in DIP.
            /// </summary>
            public double OffsetTop
            {
                get; set;
            }
            /// <summary>
            /// Page scale factor.
            /// </summary>
            public double PageScaleFactor
            {
                get; set;
            }
            /// <summary>
            /// Device screen width in DIP.
            /// </summary>
            public double DeviceWidth
            {
                get; set;
            }
            /// <summary>
            /// Device screen height in DIP.
            /// </summary>
            public double DeviceHeight
            {
                get; set;
            }
            /// <summary>
            /// Position of horizontal scroll in CSS pixels.
            /// </summary>
            public double ScrollOffsetX
            {
                get; set;
            }
            /// <summary>
            /// Position of vertical scroll in CSS pixels.
            /// </summary>
            public double ScrollOffsetY
            {
                get; set;
            }
            /// <summary>
            /// Frame swap timestamp.
            /// </summary>
            public double? Timestamp
            {
                get; set;
            }

        }
        /// <summary>
        /// Javascript dialog type.
        /// </summary>
        public enum DialogType
        {
            [EnumValue("alert")]
            Alert = 1,
            [EnumValue("confirm")]
            Confirm = 2,
            [EnumValue("prompt")]
            Prompt = 3,
            [EnumValue("beforeunload")]
            Beforeunload = 4,

        }
        /// <summary>
        /// Error while paring app manifest.
        /// </summary>
        public class AppManifestError
        {
            /// <summary>
            /// Error message.
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// If criticial, this is a non-recoverable parse error.
            /// </summary>
            public int Critical
            {
                get; set;
            }
            /// <summary>
            /// Error line.
            /// </summary>
            public int Line
            {
                get; set;
            }
            /// <summary>
            /// Error column.
            /// </summary>
            public int Column
            {
                get; set;
            }

        }
        /// <summary>
        /// Parsed app manifest properties.
        /// </summary>
        [Experimental]
        public class AppManifestParsedProperties
        {
            /// <summary>
            /// Computed scope value
            /// </summary>
            public string Scope
            {
                get; set;
            }

        }
        /// <summary>
        /// Layout viewport position and dimensions.
        /// </summary>
        public class LayoutViewport
        {
            /// <summary>
            /// Horizontal offset relative to the document (CSS pixels).
            /// </summary>
            public int PageX
            {
                get; set;
            }
            /// <summary>
            /// Vertical offset relative to the document (CSS pixels).
            /// </summary>
            public int PageY
            {
                get; set;
            }
            /// <summary>
            /// Width (CSS pixels), excludes scrollbar if present.
            /// </summary>
            public int ClientWidth
            {
                get; set;
            }
            /// <summary>
            /// Height (CSS pixels), excludes scrollbar if present.
            /// </summary>
            public int ClientHeight
            {
                get; set;
            }

        }
        /// <summary>
        /// Visual viewport position, dimensions, and scale.
        /// </summary>
        public class VisualViewport
        {
            /// <summary>
            /// Horizontal offset relative to the layout viewport (CSS pixels).
            /// </summary>
            public double OffsetX
            {
                get; set;
            }
            /// <summary>
            /// Vertical offset relative to the layout viewport (CSS pixels).
            /// </summary>
            public double OffsetY
            {
                get; set;
            }
            /// <summary>
            /// Horizontal offset relative to the document (CSS pixels).
            /// </summary>
            public double PageX
            {
                get; set;
            }
            /// <summary>
            /// Vertical offset relative to the document (CSS pixels).
            /// </summary>
            public double PageY
            {
                get; set;
            }
            /// <summary>
            /// Width (CSS pixels), excludes scrollbar if present.
            /// </summary>
            public double ClientWidth
            {
                get; set;
            }
            /// <summary>
            /// Height (CSS pixels), excludes scrollbar if present.
            /// </summary>
            public double ClientHeight
            {
                get; set;
            }
            /// <summary>
            /// Scale relative to the ideal viewport (size at width=device-width).
            /// </summary>
            public double Scale
            {
                get; set;
            }
            /// <summary>
            /// Page zoom factor (CSS to device independent pixels ratio).
            /// </summary>
            public double? Zoom
            {
                get; set;
            }

        }
        /// <summary>
        /// Viewport for capturing screenshot.
        /// </summary>
        public class Viewport
        {
            /// <summary>
            /// X offset in device independent pixels (dip).
            /// </summary>
            public double X
            {
                get; set;
            }
            /// <summary>
            /// Y offset in device independent pixels (dip).
            /// </summary>
            public double Y
            {
                get; set;
            }
            /// <summary>
            /// Rectangle width in device independent pixels (dip).
            /// </summary>
            public double Width
            {
                get; set;
            }
            /// <summary>
            /// Rectangle height in device independent pixels (dip).
            /// </summary>
            public double Height
            {
                get; set;
            }
            /// <summary>
            /// Page scale factor.
            /// </summary>
            public double Scale
            {
                get; set;
            }

        }
        /// <summary>
        /// Generic font families collection.
        /// </summary>
        [Experimental]
        public class FontFamilies
        {
            /// <summary>
            /// The standard font-family.
            /// </summary>
            public string? Standard
            {
                get; set;
            }
            /// <summary>
            /// The fixed font-family.
            /// </summary>
            public string? Fixed
            {
                get; set;
            }
            /// <summary>
            /// The serif font-family.
            /// </summary>
            public string? Serif
            {
                get; set;
            }
            /// <summary>
            /// The sansSerif font-family.
            /// </summary>
            public string? SansSerif
            {
                get; set;
            }
            /// <summary>
            /// The cursive font-family.
            /// </summary>
            public string? Cursive
            {
                get; set;
            }
            /// <summary>
            /// The fantasy font-family.
            /// </summary>
            public string? Fantasy
            {
                get; set;
            }
            /// <summary>
            /// The math font-family.
            /// </summary>
            public string? Math
            {
                get; set;
            }

        }
        /// <summary>
        /// Font families collection for a script.
        /// </summary>
        [Experimental]
        public class ScriptFontFamilies
        {
            /// <summary>
            /// Name of the script which these font families are defined for.
            /// </summary>
            public string Script
            {
                get; set;
            }
            /// <summary>
            /// Generic font families collection for the script.
            /// </summary>
            public PageDomain.FontFamilies FontFamilies
            {
                get; set;
            }

        }
        /// <summary>
        /// Default font sizes.
        /// </summary>
        [Experimental]
        public class FontSizes
        {
            /// <summary>
            /// Default standard font size.
            /// </summary>
            public int? Standard
            {
                get; set;
            }
            /// <summary>
            /// Default fixed font size.
            /// </summary>
            public int? Fixed
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum ClientNavigationReason
        {
            [EnumValue("formSubmissionGet")]
            FormSubmissionGet = 1,
            [EnumValue("formSubmissionPost")]
            FormSubmissionPost = 2,
            [EnumValue("httpHeaderRefresh")]
            HttpHeaderRefresh = 3,
            [EnumValue("scriptInitiated")]
            ScriptInitiated = 4,
            [EnumValue("metaTagRefresh")]
            MetaTagRefresh = 5,
            [EnumValue("pageBlockInterstitial")]
            PageBlockInterstitial = 6,
            [EnumValue("reload")]
            Reload = 7,
            [EnumValue("anchorClick")]
            AnchorClick = 8,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum ClientNavigationDisposition
        {
            [EnumValue("currentTab")]
            CurrentTab = 1,
            [EnumValue("newTab")]
            NewTab = 2,
            [EnumValue("newWindow")]
            NewWindow = 3,
            [EnumValue("download")]
            Download = 4,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class InstallabilityErrorArgument
        {
            /// <summary>
            /// Argument name (e.g. name:'minimum-icon-size-in-pixels').
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Argument value (e.g. value:'64').
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// The installability error
        /// </summary>
        [Experimental]
        public class InstallabilityError
        {
            /// <summary>
            /// The error id (e.g. 'manifest-missing-suitable-icon').
            /// </summary>
            public string ErrorId
            {
                get; set;
            }
            /// <summary>
            /// The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
            /// </summary>
            public PageDomain.InstallabilityErrorArgument[] ErrorArguments
            {
                get; set;
            }

        }
        /// <summary>
        /// The referring-policy used for the navigation.
        /// </summary>
        [Experimental]
        public enum ReferrerPolicy
        {
            [EnumValue("noReferrer")]
            NoReferrer = 1,
            [EnumValue("noReferrerWhenDowngrade")]
            NoReferrerWhenDowngrade = 2,
            [EnumValue("origin")]
            Origin = 3,
            [EnumValue("originWhenCrossOrigin")]
            OriginWhenCrossOrigin = 4,
            [EnumValue("sameOrigin")]
            SameOrigin = 5,
            [EnumValue("strictOrigin")]
            StrictOrigin = 6,
            [EnumValue("strictOriginWhenCrossOrigin")]
            StrictOriginWhenCrossOrigin = 7,
            [EnumValue("unsafeUrl")]
            UnsafeUrl = 8,

        }
        /// <summary>
        /// Per-script compilation cache parameters for `Page.produceCompilationCache`
        /// </summary>
        [Experimental]
        public class CompilationCacheParams
        {
            /// <summary>
            /// The URL of the script to produce a compilation cache entry for.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// A hint to the backend whether eager compilation is recommended.
            /// (the actual compilation mode used is upon backend discretion).
            /// </summary>
            public bool? Eager
            {
                get; set;
            }

        }
        /// <summary>
        /// The type of a frameNavigated event.
        /// </summary>
        [Experimental]
        public enum NavigationType
        {
            [EnumValue("Navigation")]
            Navigation = 1,
            [EnumValue("BackForwardCacheRestore")]
            BackForwardCacheRestore = 2,

        }
        /// <summary>
        /// List of not restored reasons for back-forward cache.
        /// </summary>
        [Experimental]
        public enum BackForwardCacheNotRestoredReason
        {
            [EnumValue("NotPrimaryMainFrame")]
            NotPrimaryMainFrame = 1,
            [EnumValue("BackForwardCacheDisabled")]
            BackForwardCacheDisabled = 2,
            [EnumValue("RelatedActiveContentsExist")]
            RelatedActiveContentsExist = 3,
            [EnumValue("HTTPStatusNotOK")]
            HTTPStatusNotOK = 4,
            [EnumValue("SchemeNotHTTPOrHTTPS")]
            SchemeNotHTTPOrHTTPS = 5,
            [EnumValue("Loading")]
            Loading = 6,
            [EnumValue("WasGrantedMediaAccess")]
            WasGrantedMediaAccess = 7,
            [EnumValue("DisableForRenderFrameHostCalled")]
            DisableForRenderFrameHostCalled = 8,
            [EnumValue("DomainNotAllowed")]
            DomainNotAllowed = 9,
            [EnumValue("HTTPMethodNotGET")]
            HTTPMethodNotGET = 10,
            [EnumValue("SubframeIsNavigating")]
            SubframeIsNavigating = 11,
            [EnumValue("Timeout")]
            Timeout = 12,
            [EnumValue("CacheLimit")]
            CacheLimit = 13,
            [EnumValue("JavaScriptExecution")]
            JavaScriptExecution = 14,
            [EnumValue("RendererProcessKilled")]
            RendererProcessKilled = 15,
            [EnumValue("RendererProcessCrashed")]
            RendererProcessCrashed = 16,
            [EnumValue("SchedulerTrackedFeatureUsed")]
            SchedulerTrackedFeatureUsed = 17,
            [EnumValue("ConflictingBrowsingInstance")]
            ConflictingBrowsingInstance = 18,
            [EnumValue("CacheFlushed")]
            CacheFlushed = 19,
            [EnumValue("ServiceWorkerVersionActivation")]
            ServiceWorkerVersionActivation = 20,
            [EnumValue("SessionRestored")]
            SessionRestored = 21,
            [EnumValue("ServiceWorkerPostMessage")]
            ServiceWorkerPostMessage = 22,
            [EnumValue("EnteredBackForwardCacheBeforeServiceWorkerHostAdded")]
            EnteredBackForwardCacheBeforeServiceWorkerHostAdded = 23,
            [EnumValue("RenderFrameHostReused_SameSite")]
            RenderFrameHostReused_SameSite = 24,
            [EnumValue("RenderFrameHostReused_CrossSite")]
            RenderFrameHostReused_CrossSite = 25,
            [EnumValue("ServiceWorkerClaim")]
            ServiceWorkerClaim = 26,
            [EnumValue("IgnoreEventAndEvict")]
            IgnoreEventAndEvict = 27,
            [EnumValue("HaveInnerContents")]
            HaveInnerContents = 28,
            [EnumValue("TimeoutPuttingInCache")]
            TimeoutPuttingInCache = 29,
            [EnumValue("BackForwardCacheDisabledByLowMemory")]
            BackForwardCacheDisabledByLowMemory = 30,
            [EnumValue("BackForwardCacheDisabledByCommandLine")]
            BackForwardCacheDisabledByCommandLine = 31,
            [EnumValue("NetworkRequestDatapipeDrainedAsBytesConsumer")]
            NetworkRequestDatapipeDrainedAsBytesConsumer = 32,
            [EnumValue("NetworkRequestRedirected")]
            NetworkRequestRedirected = 33,
            [EnumValue("NetworkRequestTimeout")]
            NetworkRequestTimeout = 34,
            [EnumValue("NetworkExceedsBufferLimit")]
            NetworkExceedsBufferLimit = 35,
            [EnumValue("NavigationCancelledWhileRestoring")]
            NavigationCancelledWhileRestoring = 36,
            [EnumValue("NotMostRecentNavigationEntry")]
            NotMostRecentNavigationEntry = 37,
            [EnumValue("BackForwardCacheDisabledForPrerender")]
            BackForwardCacheDisabledForPrerender = 38,
            [EnumValue("UserAgentOverrideDiffers")]
            UserAgentOverrideDiffers = 39,
            [EnumValue("ForegroundCacheLimit")]
            ForegroundCacheLimit = 40,
            [EnumValue("BrowsingInstanceNotSwapped")]
            BrowsingInstanceNotSwapped = 41,
            [EnumValue("BackForwardCacheDisabledForDelegate")]
            BackForwardCacheDisabledForDelegate = 42,
            [EnumValue("UnloadHandlerExistsInMainFrame")]
            UnloadHandlerExistsInMainFrame = 43,
            [EnumValue("UnloadHandlerExistsInSubFrame")]
            UnloadHandlerExistsInSubFrame = 44,
            [EnumValue("ServiceWorkerUnregistration")]
            ServiceWorkerUnregistration = 45,
            [EnumValue("CacheControlNoStore")]
            CacheControlNoStore = 46,
            [EnumValue("CacheControlNoStoreCookieModified")]
            CacheControlNoStoreCookieModified = 47,
            [EnumValue("CacheControlNoStoreHTTPOnlyCookieModified")]
            CacheControlNoStoreHTTPOnlyCookieModified = 48,
            [EnumValue("NoResponseHead")]
            NoResponseHead = 49,
            [EnumValue("Unknown")]
            Unknown = 50,
            [EnumValue("ActivationNavigationsDisallowedForBug1234857")]
            ActivationNavigationsDisallowedForBug1234857 = 51,
            [EnumValue("ErrorDocument")]
            ErrorDocument = 52,
            [EnumValue("FencedFramesEmbedder")]
            FencedFramesEmbedder = 53,
            [EnumValue("WebSocket")]
            WebSocket = 54,
            [EnumValue("WebTransport")]
            WebTransport = 55,
            [EnumValue("WebRTC")]
            WebRTC = 56,
            [EnumValue("MainResourceHasCacheControlNoStore")]
            MainResourceHasCacheControlNoStore = 57,
            [EnumValue("MainResourceHasCacheControlNoCache")]
            MainResourceHasCacheControlNoCache = 58,
            [EnumValue("SubresourceHasCacheControlNoStore")]
            SubresourceHasCacheControlNoStore = 59,
            [EnumValue("SubresourceHasCacheControlNoCache")]
            SubresourceHasCacheControlNoCache = 60,
            [EnumValue("ContainsPlugins")]
            ContainsPlugins = 61,
            [EnumValue("DocumentLoaded")]
            DocumentLoaded = 62,
            [EnumValue("DedicatedWorkerOrWorklet")]
            DedicatedWorkerOrWorklet = 63,
            [EnumValue("OutstandingNetworkRequestOthers")]
            OutstandingNetworkRequestOthers = 64,
            [EnumValue("OutstandingIndexedDBTransaction")]
            OutstandingIndexedDBTransaction = 65,
            [EnumValue("RequestedNotificationsPermission")]
            RequestedNotificationsPermission = 66,
            [EnumValue("RequestedMIDIPermission")]
            RequestedMIDIPermission = 67,
            [EnumValue("RequestedAudioCapturePermission")]
            RequestedAudioCapturePermission = 68,
            [EnumValue("RequestedVideoCapturePermission")]
            RequestedVideoCapturePermission = 69,
            [EnumValue("RequestedBackForwardCacheBlockedSensors")]
            RequestedBackForwardCacheBlockedSensors = 70,
            [EnumValue("RequestedBackgroundWorkPermission")]
            RequestedBackgroundWorkPermission = 71,
            [EnumValue("BroadcastChannel")]
            BroadcastChannel = 72,
            [EnumValue("IndexedDBConnection")]
            IndexedDBConnection = 73,
            [EnumValue("WebXR")]
            WebXR = 74,
            [EnumValue("SharedWorker")]
            SharedWorker = 75,
            [EnumValue("WebLocks")]
            WebLocks = 76,
            [EnumValue("WebHID")]
            WebHID = 77,
            [EnumValue("WebShare")]
            WebShare = 78,
            [EnumValue("RequestedStorageAccessGrant")]
            RequestedStorageAccessGrant = 79,
            [EnumValue("WebNfc")]
            WebNfc = 80,
            [EnumValue("OutstandingNetworkRequestFetch")]
            OutstandingNetworkRequestFetch = 81,
            [EnumValue("OutstandingNetworkRequestXHR")]
            OutstandingNetworkRequestXHR = 82,
            [EnumValue("AppBanner")]
            AppBanner = 83,
            [EnumValue("Printing")]
            Printing = 84,
            [EnumValue("WebDatabase")]
            WebDatabase = 85,
            [EnumValue("PictureInPicture")]
            PictureInPicture = 86,
            [EnumValue("Portal")]
            Portal = 87,
            [EnumValue("SpeechRecognizer")]
            SpeechRecognizer = 88,
            [EnumValue("IdleManager")]
            IdleManager = 89,
            [EnumValue("PaymentManager")]
            PaymentManager = 90,
            [EnumValue("SpeechSynthesis")]
            SpeechSynthesis = 91,
            [EnumValue("KeyboardLock")]
            KeyboardLock = 92,
            [EnumValue("WebOTPService")]
            WebOTPService = 93,
            [EnumValue("OutstandingNetworkRequestDirectSocket")]
            OutstandingNetworkRequestDirectSocket = 94,
            [EnumValue("InjectedJavascript")]
            InjectedJavascript = 95,
            [EnumValue("InjectedStyleSheet")]
            InjectedStyleSheet = 96,
            [EnumValue("Dummy")]
            Dummy = 97,
            [EnumValue("ContentSecurityHandler")]
            ContentSecurityHandler = 98,
            [EnumValue("ContentWebAuthenticationAPI")]
            ContentWebAuthenticationAPI = 99,
            [EnumValue("ContentFileChooser")]
            ContentFileChooser = 100,
            [EnumValue("ContentSerial")]
            ContentSerial = 101,
            [EnumValue("ContentFileSystemAccess")]
            ContentFileSystemAccess = 102,
            [EnumValue("ContentMediaDevicesDispatcherHost")]
            ContentMediaDevicesDispatcherHost = 103,
            [EnumValue("ContentWebBluetooth")]
            ContentWebBluetooth = 104,
            [EnumValue("ContentWebUSB")]
            ContentWebUSB = 105,
            [EnumValue("ContentMediaSessionService")]
            ContentMediaSessionService = 106,
            [EnumValue("ContentScreenReader")]
            ContentScreenReader = 107,
            [EnumValue("EmbedderPopupBlockerTabHelper")]
            EmbedderPopupBlockerTabHelper = 108,
            [EnumValue("EmbedderSafeBrowsingTriggeredPopupBlocker")]
            EmbedderSafeBrowsingTriggeredPopupBlocker = 109,
            [EnumValue("EmbedderSafeBrowsingThreatDetails")]
            EmbedderSafeBrowsingThreatDetails = 110,
            [EnumValue("EmbedderAppBannerManager")]
            EmbedderAppBannerManager = 111,
            [EnumValue("EmbedderDomDistillerViewerSource")]
            EmbedderDomDistillerViewerSource = 112,
            [EnumValue("EmbedderDomDistillerSelfDeletingRequestDelegate")]
            EmbedderDomDistillerSelfDeletingRequestDelegate = 113,
            [EnumValue("EmbedderOomInterventionTabHelper")]
            EmbedderOomInterventionTabHelper = 114,
            [EnumValue("EmbedderOfflinePage")]
            EmbedderOfflinePage = 115,
            [EnumValue("EmbedderChromePasswordManagerClientBindCredentialManager")]
            EmbedderChromePasswordManagerClientBindCredentialManager = 116,
            [EnumValue("EmbedderPermissionRequestManager")]
            EmbedderPermissionRequestManager = 117,
            [EnumValue("EmbedderModalDialog")]
            EmbedderModalDialog = 118,
            [EnumValue("EmbedderExtensions")]
            EmbedderExtensions = 119,
            [EnumValue("EmbedderExtensionMessaging")]
            EmbedderExtensionMessaging = 120,
            [EnumValue("EmbedderExtensionMessagingForOpenPort")]
            EmbedderExtensionMessagingForOpenPort = 121,
            [EnumValue("EmbedderExtensionSentMessageToCachedFrame")]
            EmbedderExtensionSentMessageToCachedFrame = 122,

        }
        /// <summary>
        /// Types of not restored reasons for back-forward cache.
        /// </summary>
        [Experimental]
        public enum BackForwardCacheNotRestoredReasonType
        {
            [EnumValue("SupportPending")]
            SupportPending = 1,
            [EnumValue("PageSupportNeeded")]
            PageSupportNeeded = 2,
            [EnumValue("Circumstantial")]
            Circumstantial = 3,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class BackForwardCacheNotRestoredExplanation
        {
            /// <summary>
            /// Type of the reason
            /// </summary>
            public PageDomain.BackForwardCacheNotRestoredReasonType Type
            {
                get; set;
            }
            /// <summary>
            /// Not restored reason
            /// </summary>
            public PageDomain.BackForwardCacheNotRestoredReason Reason
            {
                get; set;
            }
            /// <summary>
            /// Context associated with the reason. The meaning of this context is
            /// dependent on the reason:
            /// - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
            /// </summary>
            public string? Context
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class BackForwardCacheNotRestoredExplanationTree
        {
            /// <summary>
            /// URL of each frame
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Not restored reasons of each frame
            /// </summary>
            public PageDomain.BackForwardCacheNotRestoredExplanation[] Explanations
            {
                get; set;
            }
            /// <summary>
            /// Array of children frame
            /// </summary>
            public PageDomain.BackForwardCacheNotRestoredExplanationTree[] Children
            {
                get; set;
            }

        }
        /// <summary>
        /// List of FinalStatus reasons for Prerender2.
        /// </summary>
        public enum PrerenderFinalStatus
        {
            [EnumValue("Activated")]
            Activated = 1,
            [EnumValue("Destroyed")]
            Destroyed = 2,
            [EnumValue("LowEndDevice")]
            LowEndDevice = 3,
            [EnumValue("CrossOriginRedirect")]
            CrossOriginRedirect = 4,
            [EnumValue("CrossOriginNavigation")]
            CrossOriginNavigation = 5,
            [EnumValue("InvalidSchemeRedirect")]
            InvalidSchemeRedirect = 6,
            [EnumValue("InvalidSchemeNavigation")]
            InvalidSchemeNavigation = 7,
            [EnumValue("InProgressNavigation")]
            InProgressNavigation = 8,
            [EnumValue("NavigationRequestBlockedByCsp")]
            NavigationRequestBlockedByCsp = 9,
            [EnumValue("MainFrameNavigation")]
            MainFrameNavigation = 10,
            [EnumValue("MojoBinderPolicy")]
            MojoBinderPolicy = 11,
            [EnumValue("RendererProcessCrashed")]
            RendererProcessCrashed = 12,
            [EnumValue("RendererProcessKilled")]
            RendererProcessKilled = 13,
            [EnumValue("Download")]
            Download = 14,
            [EnumValue("TriggerDestroyed")]
            TriggerDestroyed = 15,
            [EnumValue("NavigationNotCommitted")]
            NavigationNotCommitted = 16,
            [EnumValue("NavigationBadHttpStatus")]
            NavigationBadHttpStatus = 17,
            [EnumValue("ClientCertRequested")]
            ClientCertRequested = 18,
            [EnumValue("NavigationRequestNetworkError")]
            NavigationRequestNetworkError = 19,
            [EnumValue("MaxNumOfRunningPrerendersExceeded")]
            MaxNumOfRunningPrerendersExceeded = 20,
            [EnumValue("CancelAllHostsForTesting")]
            CancelAllHostsForTesting = 21,
            [EnumValue("DidFailLoad")]
            DidFailLoad = 22,
            [EnumValue("Stop")]
            Stop = 23,
            [EnumValue("SslCertificateError")]
            SslCertificateError = 24,
            [EnumValue("LoginAuthRequested")]
            LoginAuthRequested = 25,
            [EnumValue("UaChangeRequiresReload")]
            UaChangeRequiresReload = 26,
            [EnumValue("BlockedByClient")]
            BlockedByClient = 27,
            [EnumValue("AudioOutputDeviceRequested")]
            AudioOutputDeviceRequested = 28,
            [EnumValue("MixedContent")]
            MixedContent = 29,
            [EnumValue("TriggerBackgrounded")]
            TriggerBackgrounded = 30,
            [EnumValue("EmbedderTriggeredAndSameOriginRedirected")]
            EmbedderTriggeredAndSameOriginRedirected = 31,
            [EnumValue("EmbedderTriggeredAndCrossOriginRedirected")]
            EmbedderTriggeredAndCrossOriginRedirected = 32,
            [EnumValue("EmbedderTriggeredAndDestroyed")]
            EmbedderTriggeredAndDestroyed = 33,

        }

    }
    public class PerformanceDomain : BaseDomain
    {
        public PerformanceDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Performance";

            }

        }
        /// <summary>
        /// Current values of the metrics.
        /// </summary>
        public event EventHandler<MetricsParams>? Metrics;
        /// <summary>
        /// Disable collecting and reporting metrics.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enable collecting and reporting metrics.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Sets time domain to use for collecting and reporting duration metrics.
        /// Note that this must be called before enabling metrics collection. Calling
        /// this method while metrics collection is enabled returns an error.
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<SetTimeDomainResult> SetTimeDomainAsync(SetTimeDomainParams setTimeDomainParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setTimeDomainParams, cancellationToken);

        }
        /// <summary>
        /// Retrieve current values of run-time metrics.
        /// </summary>
        public async ValueTask<GetMetricsResult> GetMetricsAsync(GetMetricsParams getMetricsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getMetricsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "metrics": RaiseEvent(Metrics, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class MetricsParams
        {
            /// <summary>
            /// Current values of the metrics.
            /// </summary>
            public PerformanceDomain.Metric[] Metrics
            {
                get; set;
            }
            /// <summary>
            /// Timestamp title.
            /// </summary>
            public string Title
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Performance.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Performance.enable";

            }
            /// <summary>
            /// Time domain to use for collecting and reporting duration metrics.
            /// </summary>
            /// <value>
            /// timeTicks,threadTicks
            /// </value>
            public string? TimeDomain
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        public class SetTimeDomainParams : IMethodParams<SetTimeDomainParams, SetTimeDomainResult>
        {
            public string GetMethod()
            {
                return "Performance.setTimeDomain";

            }
            /// <summary>
            /// Time domain
            /// </summary>
            /// <value>
            /// timeTicks,threadTicks
            /// </value>
            public string TimeDomain
            {
                get; set;
            }

        }
        public class SetTimeDomainResult
        {

        }
        public class GetMetricsParams : IMethodParams<GetMetricsParams, GetMetricsResult>
        {
            public string GetMethod()
            {
                return "Performance.getMetrics";

            }

        }
        public class GetMetricsResult
        {
            /// <summary>
            /// Current values for run-time metrics.
            /// </summary>
            public PerformanceDomain.Metric[] Metrics
            {
                get; set;
            }

        }
        /// <summary>
        /// Run-time execution metric.
        /// </summary>
        public class Metric
        {
            /// <summary>
            /// Metric name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Metric value.
            /// </summary>
            public double Value
            {
                get; set;
            }

        }

    }
    public class PerformanceTimelineDomain : BaseDomain
    {
        public PerformanceTimelineDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "PerformanceTimeline";

            }

        }
        /// <summary>
        /// Sent when a performance timeline event is added. See reportPerformanceTimeline method.
        /// </summary>
        public event EventHandler<TimelineEventAddedParams>? TimelineEventAdded;
        /// <summary>
        /// Previously buffered events would be reported before method returns.
        /// See also: timelineEventAdded
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "timelineEventAdded": RaiseEvent(TimelineEventAdded, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class TimelineEventAddedParams
        {
            /// <summary>
            /// </summary>
            public PerformanceTimelineDomain.TimelineEvent Event
            {
                get; set;
            }

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "PerformanceTimeline.enable";

            }
            /// <summary>
            /// The types of event to report, as specified in
            /// https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
            /// The specified filter overrides any previous filters, passing empty
            /// filter disables recording.
            /// Note that not all types exposed to the web platform are currently supported.
            /// </summary>
            public string[] EventTypes
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        /// <summary>
        /// See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
        /// </summary>
        public class LargestContentfulPaint
        {
            /// <summary>
            /// </summary>
            public double RenderTime
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double LoadTime
            {
                get; set;
            }
            /// <summary>
            /// The number of pixels being painted.
            /// </summary>
            public double Size
            {
                get; set;
            }
            /// <summary>
            /// The id attribute of the element, if available.
            /// </summary>
            public string? ElementId
            {
                get; set;
            }
            /// <summary>
            /// The URL of the image (may be trimmed).
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int? NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class LayoutShiftAttribution
        {
            /// <summary>
            /// </summary>
            public DOMDomain.Rect PreviousRect
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DOMDomain.Rect CurrentRect
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int? NodeId
            {
                get; set;
            }

        }
        /// <summary>
        /// See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
        /// </summary>
        public class LayoutShift
        {
            /// <summary>
            /// Score increment produced by this event.
            /// </summary>
            public double Value
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool HadRecentInput
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double LastInputTime
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PerformanceTimelineDomain.LayoutShiftAttribution[] Sources
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class TimelineEvent
        {
            /// <summary>
            /// Identifies the frame that this event is related to. Empty for non-frame targets.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
            /// This determines which of the optional "details" fiedls is present.
            /// </summary>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Name may be empty depending on the type.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Time in seconds since Epoch, monotonically increasing within document lifetime.
            /// </summary>
            public double Time
            {
                get; set;
            }
            /// <summary>
            /// Event duration, if applicable.
            /// </summary>
            public double? Duration
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PerformanceTimelineDomain.LargestContentfulPaint? LcpDetails
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public PerformanceTimelineDomain.LayoutShift? LayoutShiftDetails
            {
                get; set;
            }

        }

    }
    public class SecurityDomain : BaseDomain
    {
        public SecurityDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Security";

            }

        }
        /// <summary>
        /// There is a certificate error. If overriding certificate errors is enabled, then it should be
        /// handled with the `handleCertificateError` command. Note: this event does not fire if the
        /// certificate error has been allowed internally. Only one client per target should override
        /// certificate errors at the same time.
        /// </summary>
        [Obsolete]
        public event EventHandler<CertificateErrorParams>? CertificateError;
        /// <summary>
        /// The security state of the page changed.
        /// </summary>
        [Experimental]
        public event EventHandler<VisibleSecurityStateChangedParams>? VisibleSecurityStateChanged;
        /// <summary>
        /// The security state of the page changed. No longer being sent.
        /// </summary>
        [Obsolete]
        public event EventHandler<SecurityStateChangedParams>? SecurityStateChanged;
        /// <summary>
        /// Disables tracking security state changes.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables tracking security state changes.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Enable/disable whether all certificate errors should be ignored.
        /// </summary>
        [Experimental]
        public async ValueTask<SetIgnoreCertificateErrorsResult> SetIgnoreCertificateErrorsAsync(SetIgnoreCertificateErrorsParams setIgnoreCertificateErrorsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setIgnoreCertificateErrorsParams, cancellationToken);

        }
        /// <summary>
        /// Handles a certificate error that fired a certificateError event.
        /// </summary>
        [Obsolete]
        public async ValueTask<HandleCertificateErrorResult> HandleCertificateErrorAsync(HandleCertificateErrorParams handleCertificateErrorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(handleCertificateErrorParams, cancellationToken);

        }
        /// <summary>
        /// Enable/disable overriding certificate errors. If enabled, all certificate error events need to
        /// be handled by the DevTools client and should be answered with `handleCertificateError` commands.
        /// </summary>
        [Obsolete]
        public async ValueTask<SetOverrideCertificateErrorsResult> SetOverrideCertificateErrorsAsync(SetOverrideCertificateErrorsParams setOverrideCertificateErrorsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setOverrideCertificateErrorsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "certificateError": RaiseEvent(CertificateError, messageBytes);
                    break;
                case "visibleSecurityStateChanged": RaiseEvent(VisibleSecurityStateChanged, messageBytes);
                    break;
                case "securityStateChanged": RaiseEvent(SecurityStateChanged, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class CertificateErrorParams
        {
            /// <summary>
            /// The ID of the event.
            /// </summary>
            public int EventId
            {
                get; set;
            }
            /// <summary>
            /// The type of the error.
            /// </summary>
            public string ErrorType
            {
                get; set;
            }
            /// <summary>
            /// The url that was requested.
            /// </summary>
            public string RequestURL
            {
                get; set;
            }

        }
        public class VisibleSecurityStateChangedParams
        {
            /// <summary>
            /// Security state information about the page.
            /// </summary>
            public SecurityDomain.VisibleSecurityState VisibleSecurityState
            {
                get; set;
            }

        }
        public class SecurityStateChangedParams
        {
            /// <summary>
            /// Security state.
            /// </summary>
            public SecurityDomain.SecurityState SecurityState
            {
                get; set;
            }
            /// <summary>
            /// True if the page was loaded over cryptographic transport such as HTTPS.
            /// </summary>
            [Obsolete]
            public bool SchemeIsCryptographic
            {
                get; set;
            }
            /// <summary>
            /// Previously a list of explanations for the security state. Now always
            /// empty.
            /// </summary>
            [Obsolete]
            public SecurityDomain.SecurityStateExplanation[] Explanations
            {
                get; set;
            }
            /// <summary>
            /// Information about insecure content on the page.
            /// </summary>
            [Obsolete]
            public SecurityDomain.InsecureContentStatus InsecureContentStatus
            {
                get; set;
            }
            /// <summary>
            /// Overrides user-visible description of the state. Always omitted.
            /// </summary>
            [Obsolete]
            public string? Summary
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Security.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Security.enable";

            }

        }
        public class EnableResult
        {

        }
        public class SetIgnoreCertificateErrorsParams : IMethodParams<SetIgnoreCertificateErrorsParams, SetIgnoreCertificateErrorsResult>
        {
            public string GetMethod()
            {
                return "Security.setIgnoreCertificateErrors";

            }
            /// <summary>
            /// If true, all certificate errors will be ignored.
            /// </summary>
            public bool Ignore
            {
                get; set;
            }

        }
        public class SetIgnoreCertificateErrorsResult
        {

        }
        public class HandleCertificateErrorParams : IMethodParams<HandleCertificateErrorParams, HandleCertificateErrorResult>
        {
            public string GetMethod()
            {
                return "Security.handleCertificateError";

            }
            /// <summary>
            /// The ID of the event.
            /// </summary>
            public int EventId
            {
                get; set;
            }
            /// <summary>
            /// The action to take on the certificate error.
            /// </summary>
            public SecurityDomain.CertificateErrorAction Action
            {
                get; set;
            }

        }
        public class HandleCertificateErrorResult
        {

        }
        public class SetOverrideCertificateErrorsParams : IMethodParams<SetOverrideCertificateErrorsParams, SetOverrideCertificateErrorsResult>
        {
            public string GetMethod()
            {
                return "Security.setOverrideCertificateErrors";

            }
            /// <summary>
            /// If true, certificate errors will be overridden.
            /// </summary>
            public bool Override
            {
                get; set;
            }

        }
        public class SetOverrideCertificateErrorsResult
        {

        }
        /// <summary>
        /// A description of mixed content (HTTP resources on HTTPS pages), as defined by
        /// https://www.w3.org/TR/mixed-content/#categories
        /// </summary>
        public enum MixedContentType
        {
            [EnumValue("blockable")]
            Blockable = 1,
            [EnumValue("optionally-blockable")]
            OptionallyBlockable = 2,
            [EnumValue("none")]
            None = 3,

        }
        /// <summary>
        /// The security level of a page or resource.
        /// </summary>
        public enum SecurityState
        {
            [EnumValue("unknown")]
            Unknown = 1,
            [EnumValue("neutral")]
            Neutral = 2,
            [EnumValue("insecure")]
            Insecure = 3,
            [EnumValue("secure")]
            Secure = 4,
            [EnumValue("info")]
            Info = 5,
            [EnumValue("insecure-broken")]
            InsecureBroken = 6,

        }
        /// <summary>
        /// Details about the security state of the page certificate.
        /// </summary>
        [Experimental]
        public class CertificateSecurityState
        {
            /// <summary>
            /// Protocol name (e.g. "TLS 1.2" or "QUIC").
            /// </summary>
            public string Protocol
            {
                get; set;
            }
            /// <summary>
            /// Key Exchange used by the connection, or the empty string if not applicable.
            /// </summary>
            public string KeyExchange
            {
                get; set;
            }
            /// <summary>
            /// (EC)DH group used by the connection, if applicable.
            /// </summary>
            public string? KeyExchangeGroup
            {
                get; set;
            }
            /// <summary>
            /// Cipher name.
            /// </summary>
            public string Cipher
            {
                get; set;
            }
            /// <summary>
            /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
            /// </summary>
            public string? Mac
            {
                get; set;
            }
            /// <summary>
            /// Page certificate.
            /// </summary>
            public string[] Certificate
            {
                get; set;
            }
            /// <summary>
            /// Certificate subject name.
            /// </summary>
            public string SubjectName
            {
                get; set;
            }
            /// <summary>
            /// Name of the issuing CA.
            /// </summary>
            public string Issuer
            {
                get; set;
            }
            /// <summary>
            /// Certificate valid from date.
            /// </summary>
            public double ValidFrom
            {
                get; set;
            }
            /// <summary>
            /// Certificate valid to (expiration) date
            /// </summary>
            public double ValidTo
            {
                get; set;
            }
            /// <summary>
            /// The highest priority network error code, if the certificate has an error.
            /// </summary>
            public string? CertificateNetworkError
            {
                get; set;
            }
            /// <summary>
            /// True if the certificate uses a weak signature aglorithm.
            /// </summary>
            public bool CertificateHasWeakSignature
            {
                get; set;
            }
            /// <summary>
            /// True if the certificate has a SHA1 signature in the chain.
            /// </summary>
            public bool CertificateHasSha1Signature
            {
                get; set;
            }
            /// <summary>
            /// True if modern SSL
            /// </summary>
            public bool ModernSSL
            {
                get; set;
            }
            /// <summary>
            /// True if the connection is using an obsolete SSL protocol.
            /// </summary>
            public bool ObsoleteSslProtocol
            {
                get; set;
            }
            /// <summary>
            /// True if the connection is using an obsolete SSL key exchange.
            /// </summary>
            public bool ObsoleteSslKeyExchange
            {
                get; set;
            }
            /// <summary>
            /// True if the connection is using an obsolete SSL cipher.
            /// </summary>
            public bool ObsoleteSslCipher
            {
                get; set;
            }
            /// <summary>
            /// True if the connection is using an obsolete SSL signature.
            /// </summary>
            public bool ObsoleteSslSignature
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public enum SafetyTipStatus
        {
            [EnumValue("badReputation")]
            BadReputation = 1,
            [EnumValue("lookalike")]
            Lookalike = 2,

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class SafetyTipInfo
        {
            /// <summary>
            /// Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
            /// </summary>
            public SecurityDomain.SafetyTipStatus SafetyTipStatus
            {
                get; set;
            }
            /// <summary>
            /// The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
            /// </summary>
            public string? SafeUrl
            {
                get; set;
            }

        }
        /// <summary>
        /// Security state information about the page.
        /// </summary>
        [Experimental]
        public class VisibleSecurityState
        {
            /// <summary>
            /// The security level of the page.
            /// </summary>
            public SecurityDomain.SecurityState SecurityState
            {
                get; set;
            }
            /// <summary>
            /// Security state details about the page certificate.
            /// </summary>
            public SecurityDomain.CertificateSecurityState? CertificateSecurityState
            {
                get; set;
            }
            /// <summary>
            /// The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
            /// </summary>
            public SecurityDomain.SafetyTipInfo? SafetyTipInfo
            {
                get; set;
            }
            /// <summary>
            /// Array of security state issues ids.
            /// </summary>
            public string[] SecurityStateIssueIds
            {
                get; set;
            }

        }
        /// <summary>
        /// An explanation of an factor contributing to the security state.
        /// </summary>
        public class SecurityStateExplanation
        {
            /// <summary>
            /// Security state representing the severity of the factor being explained.
            /// </summary>
            public SecurityDomain.SecurityState SecurityState
            {
                get; set;
            }
            /// <summary>
            /// Title describing the type of factor.
            /// </summary>
            public string Title
            {
                get; set;
            }
            /// <summary>
            /// Short phrase describing the type of factor.
            /// </summary>
            public string Summary
            {
                get; set;
            }
            /// <summary>
            /// Full text explanation of the factor.
            /// </summary>
            public string Description
            {
                get; set;
            }
            /// <summary>
            /// The type of mixed content described by the explanation.
            /// </summary>
            public SecurityDomain.MixedContentType MixedContentType
            {
                get; set;
            }
            /// <summary>
            /// Page certificate.
            /// </summary>
            public string[] Certificate
            {
                get; set;
            }
            /// <summary>
            /// Recommendations to fix any issues.
            /// </summary>
            public string[]? Recommendations
            {
                get; set;
            }

        }
        /// <summary>
        /// Information about insecure content on the page.
        /// </summary>
        [Obsolete]
        public class InsecureContentStatus
        {
            /// <summary>
            /// Always false.
            /// </summary>
            public bool RanMixedContent
            {
                get; set;
            }
            /// <summary>
            /// Always false.
            /// </summary>
            public bool DisplayedMixedContent
            {
                get; set;
            }
            /// <summary>
            /// Always false.
            /// </summary>
            public bool ContainedMixedForm
            {
                get; set;
            }
            /// <summary>
            /// Always false.
            /// </summary>
            public bool RanContentWithCertErrors
            {
                get; set;
            }
            /// <summary>
            /// Always false.
            /// </summary>
            public bool DisplayedContentWithCertErrors
            {
                get; set;
            }
            /// <summary>
            /// Always set to unknown.
            /// </summary>
            public SecurityDomain.SecurityState RanInsecureContentStyle
            {
                get; set;
            }
            /// <summary>
            /// Always set to unknown.
            /// </summary>
            public SecurityDomain.SecurityState DisplayedInsecureContentStyle
            {
                get; set;
            }

        }
        /// <summary>
        /// The action to take when a certificate error occurs. continue will continue processing the
        /// request and cancel will cancel the request.
        /// </summary>
        public enum CertificateErrorAction
        {
            [EnumValue("continue")]
            Continue = 1,
            [EnumValue("cancel")]
            Cancel = 2,

        }

    }
    public class ServiceWorkerDomain : BaseDomain
    {
        public ServiceWorkerDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "ServiceWorker";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<WorkerErrorReportedParams>? WorkerErrorReported;
        /// <summary>
        /// </summary>
        public event EventHandler<WorkerRegistrationUpdatedParams>? WorkerRegistrationUpdated;
        /// <summary>
        /// </summary>
        public event EventHandler<WorkerVersionUpdatedParams>? WorkerVersionUpdated;
        /// <summary>
        /// </summary>
        public async ValueTask<DeliverPushMessageResult> DeliverPushMessageAsync(DeliverPushMessageParams deliverPushMessageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(deliverPushMessageParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<DispatchSyncEventResult> DispatchSyncEventAsync(DispatchSyncEventParams dispatchSyncEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(dispatchSyncEventParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<DispatchPeriodicSyncEventResult> DispatchPeriodicSyncEventAsync(DispatchPeriodicSyncEventParams dispatchPeriodicSyncEventParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(dispatchPeriodicSyncEventParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<InspectWorkerResult> InspectWorkerAsync(InspectWorkerParams inspectWorkerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(inspectWorkerParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SetForceUpdateOnPageLoadResult> SetForceUpdateOnPageLoadAsync(SetForceUpdateOnPageLoadParams setForceUpdateOnPageLoadParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setForceUpdateOnPageLoadParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<SkipWaitingResult> SkipWaitingAsync(SkipWaitingParams skipWaitingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(skipWaitingParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StartWorkerResult> StartWorkerAsync(StartWorkerParams startWorkerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startWorkerParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StopAllWorkersResult> StopAllWorkersAsync(StopAllWorkersParams stopAllWorkersParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopAllWorkersParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StopWorkerResult> StopWorkerAsync(StopWorkerParams stopWorkerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopWorkerParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<UnregisterResult> UnregisterAsync(UnregisterParams unregisterParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(unregisterParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<UpdateRegistrationResult> UpdateRegistrationAsync(UpdateRegistrationParams updateRegistrationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(updateRegistrationParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "workerErrorReported": RaiseEvent(WorkerErrorReported, messageBytes);
                    break;
                case "workerRegistrationUpdated": RaiseEvent(WorkerRegistrationUpdated, messageBytes);
                    break;
                case "workerVersionUpdated": RaiseEvent(WorkerVersionUpdated, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class WorkerErrorReportedParams
        {
            /// <summary>
            /// </summary>
            public ServiceWorkerDomain.ServiceWorkerErrorMessage ErrorMessage
            {
                get; set;
            }

        }
        public class WorkerRegistrationUpdatedParams
        {
            /// <summary>
            /// </summary>
            public ServiceWorkerDomain.ServiceWorkerRegistration[] Registrations
            {
                get; set;
            }

        }
        public class WorkerVersionUpdatedParams
        {
            /// <summary>
            /// </summary>
            public ServiceWorkerDomain.ServiceWorkerVersion[] Versions
            {
                get; set;
            }

        }
        public class DeliverPushMessageParams : IMethodParams<DeliverPushMessageParams, DeliverPushMessageResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.deliverPushMessage";

            }
            /// <summary>
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string RegistrationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Data
            {
                get; set;
            }

        }
        public class DeliverPushMessageResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.disable";

            }

        }
        public class DisableResult
        {

        }
        public class DispatchSyncEventParams : IMethodParams<DispatchSyncEventParams, DispatchSyncEventResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.dispatchSyncEvent";

            }
            /// <summary>
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string RegistrationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Tag
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool LastChance
            {
                get; set;
            }

        }
        public class DispatchSyncEventResult
        {

        }
        public class DispatchPeriodicSyncEventParams : IMethodParams<DispatchPeriodicSyncEventParams, DispatchPeriodicSyncEventResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.dispatchPeriodicSyncEvent";

            }
            /// <summary>
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string RegistrationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Tag
            {
                get; set;
            }

        }
        public class DispatchPeriodicSyncEventResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.enable";

            }

        }
        public class EnableResult
        {

        }
        public class InspectWorkerParams : IMethodParams<InspectWorkerParams, InspectWorkerResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.inspectWorker";

            }
            /// <summary>
            /// </summary>
            public string VersionId
            {
                get; set;
            }

        }
        public class InspectWorkerResult
        {

        }
        public class SetForceUpdateOnPageLoadParams : IMethodParams<SetForceUpdateOnPageLoadParams, SetForceUpdateOnPageLoadResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.setForceUpdateOnPageLoad";

            }
            /// <summary>
            /// </summary>
            public bool ForceUpdateOnPageLoad
            {
                get; set;
            }

        }
        public class SetForceUpdateOnPageLoadResult
        {

        }
        public class SkipWaitingParams : IMethodParams<SkipWaitingParams, SkipWaitingResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.skipWaiting";

            }
            /// <summary>
            /// </summary>
            public string ScopeURL
            {
                get; set;
            }

        }
        public class SkipWaitingResult
        {

        }
        public class StartWorkerParams : IMethodParams<StartWorkerParams, StartWorkerResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.startWorker";

            }
            /// <summary>
            /// </summary>
            public string ScopeURL
            {
                get; set;
            }

        }
        public class StartWorkerResult
        {

        }
        public class StopAllWorkersParams : IMethodParams<StopAllWorkersParams, StopAllWorkersResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.stopAllWorkers";

            }

        }
        public class StopAllWorkersResult
        {

        }
        public class StopWorkerParams : IMethodParams<StopWorkerParams, StopWorkerResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.stopWorker";

            }
            /// <summary>
            /// </summary>
            public string VersionId
            {
                get; set;
            }

        }
        public class StopWorkerResult
        {

        }
        public class UnregisterParams : IMethodParams<UnregisterParams, UnregisterResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.unregister";

            }
            /// <summary>
            /// </summary>
            public string ScopeURL
            {
                get; set;
            }

        }
        public class UnregisterResult
        {

        }
        public class UpdateRegistrationParams : IMethodParams<UpdateRegistrationParams, UpdateRegistrationResult>
        {
            public string GetMethod()
            {
                return "ServiceWorker.updateRegistration";

            }
            /// <summary>
            /// </summary>
            public string ScopeURL
            {
                get; set;
            }

        }
        public class UpdateRegistrationResult
        {

        }
        /// <summary>
        /// ServiceWorker registration.
        /// </summary>
        public class ServiceWorkerRegistration
        {
            /// <summary>
            /// </summary>
            public string RegistrationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ScopeURL
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsDeleted
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public enum ServiceWorkerVersionRunningStatus
        {
            [EnumValue("stopped")]
            Stopped = 1,
            [EnumValue("starting")]
            Starting = 2,
            [EnumValue("running")]
            Running = 3,
            [EnumValue("stopping")]
            Stopping = 4,

        }
        /// <summary>
        /// </summary>
        public enum ServiceWorkerVersionStatus
        {
            [EnumValue("new")]
            New = 1,
            [EnumValue("installing")]
            Installing = 2,
            [EnumValue("installed")]
            Installed = 3,
            [EnumValue("activating")]
            Activating = 4,
            [EnumValue("activated")]
            Activated = 5,
            [EnumValue("redundant")]
            Redundant = 6,

        }
        /// <summary>
        /// ServiceWorker version.
        /// </summary>
        public class ServiceWorkerVersion
        {
            /// <summary>
            /// </summary>
            public string VersionId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string RegistrationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ScriptURL
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public ServiceWorkerDomain.ServiceWorkerVersionRunningStatus RunningStatus
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public ServiceWorkerDomain.ServiceWorkerVersionStatus Status
            {
                get; set;
            }
            /// <summary>
            /// The Last-Modified header value of the main script.
            /// </summary>
            public double? ScriptLastModified
            {
                get; set;
            }
            /// <summary>
            /// The time at which the response headers of the main script were received from the server.
            /// For cached script it is the last time the cache entry was validated.
            /// </summary>
            public double? ScriptResponseTime
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string[]? ControlledClients
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? TargetId
            {
                get; set;
            }

        }
        /// <summary>
        /// ServiceWorker error message.
        /// </summary>
        public class ServiceWorkerErrorMessage
        {
            /// <summary>
            /// </summary>
            public string ErrorMessage
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string RegistrationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string VersionId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string SourceURL
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int ColumnNumber
            {
                get; set;
            }

        }

    }
    public class StorageDomain : BaseDomain
    {
        public StorageDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Storage";

            }

        }
        /// <summary>
        /// A cache's contents have been modified.
        /// </summary>
        public event EventHandler<CacheStorageContentUpdatedParams>? CacheStorageContentUpdated;
        /// <summary>
        /// A cache has been added/deleted.
        /// </summary>
        public event EventHandler<CacheStorageListUpdatedParams>? CacheStorageListUpdated;
        /// <summary>
        /// The origin's IndexedDB object store has been modified.
        /// </summary>
        public event EventHandler<IndexedDBContentUpdatedParams>? IndexedDBContentUpdated;
        /// <summary>
        /// The origin's IndexedDB database list has been modified.
        /// </summary>
        public event EventHandler<IndexedDBListUpdatedParams>? IndexedDBListUpdated;
        /// <summary>
        /// One of the interest groups was accessed by the associated page.
        /// </summary>
        public event EventHandler<InterestGroupAccessedParams>? InterestGroupAccessed;
        /// <summary>
        /// Returns a storage key given a frame id.
        /// </summary>
        public async ValueTask<GetStorageKeyForFrameResult> GetStorageKeyForFrameAsync(GetStorageKeyForFrameParams getStorageKeyForFrameParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getStorageKeyForFrameParams, cancellationToken);

        }
        /// <summary>
        /// Clears storage for origin.
        /// </summary>
        public async ValueTask<ClearDataForOriginResult> ClearDataForOriginAsync(ClearDataForOriginParams clearDataForOriginParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearDataForOriginParams, cancellationToken);

        }
        /// <summary>
        /// Clears storage for storage key.
        /// </summary>
        public async ValueTask<ClearDataForStorageKeyResult> ClearDataForStorageKeyAsync(ClearDataForStorageKeyParams clearDataForStorageKeyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearDataForStorageKeyParams, cancellationToken);

        }
        /// <summary>
        /// Returns all browser cookies.
        /// </summary>
        public async ValueTask<GetCookiesResult> GetCookiesAsync(GetCookiesParams getCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Sets given cookies.
        /// </summary>
        public async ValueTask<SetCookiesResult> SetCookiesAsync(SetCookiesParams setCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Clears cookies.
        /// </summary>
        public async ValueTask<ClearCookiesResult> ClearCookiesAsync(ClearCookiesParams clearCookiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearCookiesParams, cancellationToken);

        }
        /// <summary>
        /// Returns usage and quota in bytes.
        /// </summary>
        public async ValueTask<GetUsageAndQuotaResult> GetUsageAndQuotaAsync(GetUsageAndQuotaParams getUsageAndQuotaParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getUsageAndQuotaParams, cancellationToken);

        }
        /// <summary>
        /// Override quota for the specified origin
        /// </summary>
        [Experimental]
        public async ValueTask<OverrideQuotaForOriginResult> OverrideQuotaForOriginAsync(OverrideQuotaForOriginParams overrideQuotaForOriginParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(overrideQuotaForOriginParams, cancellationToken);

        }
        /// <summary>
        /// Registers origin to be notified when an update occurs to its cache storage list.
        /// </summary>
        public async ValueTask<TrackCacheStorageForOriginResult> TrackCacheStorageForOriginAsync(TrackCacheStorageForOriginParams trackCacheStorageForOriginParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(trackCacheStorageForOriginParams, cancellationToken);

        }
        /// <summary>
        /// Registers origin to be notified when an update occurs to its IndexedDB.
        /// </summary>
        public async ValueTask<TrackIndexedDBForOriginResult> TrackIndexedDBForOriginAsync(TrackIndexedDBForOriginParams trackIndexedDBForOriginParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(trackIndexedDBForOriginParams, cancellationToken);

        }
        /// <summary>
        /// Unregisters origin from receiving notifications for cache storage.
        /// </summary>
        public async ValueTask<UntrackCacheStorageForOriginResult> UntrackCacheStorageForOriginAsync(UntrackCacheStorageForOriginParams untrackCacheStorageForOriginParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(untrackCacheStorageForOriginParams, cancellationToken);

        }
        /// <summary>
        /// Unregisters origin from receiving notifications for IndexedDB.
        /// </summary>
        public async ValueTask<UntrackIndexedDBForOriginResult> UntrackIndexedDBForOriginAsync(UntrackIndexedDBForOriginParams untrackIndexedDBForOriginParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(untrackIndexedDBForOriginParams, cancellationToken);

        }
        /// <summary>
        /// Returns the number of stored Trust Tokens per issuer for the
        /// current browsing context.
        /// </summary>
        [Experimental]
        public async ValueTask<GetTrustTokensResult> GetTrustTokensAsync(GetTrustTokensParams getTrustTokensParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getTrustTokensParams, cancellationToken);

        }
        /// <summary>
        /// Removes all Trust Tokens issued by the provided issuerOrigin.
        /// Leaves other stored data, including the issuer's Redemption Records, intact.
        /// </summary>
        [Experimental]
        public async ValueTask<ClearTrustTokensResult> ClearTrustTokensAsync(ClearTrustTokensParams clearTrustTokensParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearTrustTokensParams, cancellationToken);

        }
        /// <summary>
        /// Gets details for a named interest group.
        /// </summary>
        [Experimental]
        public async ValueTask<GetInterestGroupDetailsResult> GetInterestGroupDetailsAsync(GetInterestGroupDetailsParams getInterestGroupDetailsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getInterestGroupDetailsParams, cancellationToken);

        }
        /// <summary>
        /// Enables/Disables issuing of interestGroupAccessed events.
        /// </summary>
        [Experimental]
        public async ValueTask<SetInterestGroupTrackingResult> SetInterestGroupTrackingAsync(SetInterestGroupTrackingParams setInterestGroupTrackingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInterestGroupTrackingParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "cacheStorageContentUpdated": RaiseEvent(CacheStorageContentUpdated, messageBytes);
                    break;
                case "cacheStorageListUpdated": RaiseEvent(CacheStorageListUpdated, messageBytes);
                    break;
                case "indexedDBContentUpdated": RaiseEvent(IndexedDBContentUpdated, messageBytes);
                    break;
                case "indexedDBListUpdated": RaiseEvent(IndexedDBListUpdated, messageBytes);
                    break;
                case "interestGroupAccessed": RaiseEvent(InterestGroupAccessed, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class CacheStorageContentUpdatedParams
        {
            /// <summary>
            /// Origin to update.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// Name of cache in origin.
            /// </summary>
            public string CacheName
            {
                get; set;
            }

        }
        public class CacheStorageListUpdatedParams
        {
            /// <summary>
            /// Origin to update.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class IndexedDBContentUpdatedParams
        {
            /// <summary>
            /// Origin to update.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// Database to update.
            /// </summary>
            public string DatabaseName
            {
                get; set;
            }
            /// <summary>
            /// ObjectStore to update.
            /// </summary>
            public string ObjectStoreName
            {
                get; set;
            }

        }
        public class IndexedDBListUpdatedParams
        {
            /// <summary>
            /// Origin to update.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class InterestGroupAccessedParams
        {
            /// <summary>
            /// </summary>
            public double AccessTime
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public StorageDomain.InterestGroupAccessType Type
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string OwnerOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        public class GetStorageKeyForFrameParams : IMethodParams<GetStorageKeyForFrameParams, GetStorageKeyForFrameResult>
        {
            public string GetMethod()
            {
                return "Storage.getStorageKeyForFrame";

            }
            /// <summary>
            /// </summary>
            public string FrameId
            {
                get; set;
            }

        }
        public class GetStorageKeyForFrameResult
        {
            /// <summary>
            /// </summary>
            public string StorageKey
            {
                get; set;
            }

        }
        public class ClearDataForOriginParams : IMethodParams<ClearDataForOriginParams, ClearDataForOriginResult>
        {
            public string GetMethod()
            {
                return "Storage.clearDataForOrigin";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// Comma separated list of StorageType to clear.
            /// </summary>
            public string StorageTypes
            {
                get; set;
            }

        }
        public class ClearDataForOriginResult
        {

        }
        public class ClearDataForStorageKeyParams : IMethodParams<ClearDataForStorageKeyParams, ClearDataForStorageKeyResult>
        {
            public string GetMethod()
            {
                return "Storage.clearDataForStorageKey";

            }
            /// <summary>
            /// Storage key.
            /// </summary>
            public string StorageKey
            {
                get; set;
            }
            /// <summary>
            /// Comma separated list of StorageType to clear.
            /// </summary>
            public string StorageTypes
            {
                get; set;
            }

        }
        public class ClearDataForStorageKeyResult
        {

        }
        public class GetCookiesParams : IMethodParams<GetCookiesParams, GetCookiesResult>
        {
            public string GetMethod()
            {
                return "Storage.getCookies";

            }
            /// <summary>
            /// Browser context to use when called on the browser endpoint.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class GetCookiesResult
        {
            /// <summary>
            /// Array of cookie objects.
            /// </summary>
            public NetworkDomain.Cookie[] Cookies
            {
                get; set;
            }

        }
        public class SetCookiesParams : IMethodParams<SetCookiesParams, SetCookiesResult>
        {
            public string GetMethod()
            {
                return "Storage.setCookies";

            }
            /// <summary>
            /// Cookies to be set.
            /// </summary>
            public NetworkDomain.CookieParam[] Cookies
            {
                get; set;
            }
            /// <summary>
            /// Browser context to use when called on the browser endpoint.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class SetCookiesResult
        {

        }
        public class ClearCookiesParams : IMethodParams<ClearCookiesParams, ClearCookiesResult>
        {
            public string GetMethod()
            {
                return "Storage.clearCookies";

            }
            /// <summary>
            /// Browser context to use when called on the browser endpoint.
            /// </summary>
            public string? BrowserContextId
            {
                get; set;
            }

        }
        public class ClearCookiesResult
        {

        }
        public class GetUsageAndQuotaParams : IMethodParams<GetUsageAndQuotaParams, GetUsageAndQuotaResult>
        {
            public string GetMethod()
            {
                return "Storage.getUsageAndQuota";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class GetUsageAndQuotaResult
        {
            /// <summary>
            /// Storage usage (bytes).
            /// </summary>
            public double Usage
            {
                get; set;
            }
            /// <summary>
            /// Storage quota (bytes).
            /// </summary>
            public double Quota
            {
                get; set;
            }
            /// <summary>
            /// Whether or not the origin has an active storage quota override
            /// </summary>
            public bool OverrideActive
            {
                get; set;
            }
            /// <summary>
            /// Storage usage per type (bytes).
            /// </summary>
            public StorageDomain.UsageForType[] UsageBreakdown
            {
                get; set;
            }

        }
        public class OverrideQuotaForOriginParams : IMethodParams<OverrideQuotaForOriginParams, OverrideQuotaForOriginResult>
        {
            public string GetMethod()
            {
                return "Storage.overrideQuotaForOrigin";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// The quota size (in bytes) to override the original quota with.
            /// If this is called multiple times, the overridden quota will be equal to
            /// the quotaSize provided in the final call. If this is called without
            /// specifying a quotaSize, the quota will be reset to the default value for
            /// the specified origin. If this is called multiple times with different
            /// origins, the override will be maintained for each origin until it is
            /// disabled (called without a quotaSize).
            /// </summary>
            public double? QuotaSize
            {
                get; set;
            }

        }
        public class OverrideQuotaForOriginResult
        {

        }
        public class TrackCacheStorageForOriginParams : IMethodParams<TrackCacheStorageForOriginParams, TrackCacheStorageForOriginResult>
        {
            public string GetMethod()
            {
                return "Storage.trackCacheStorageForOrigin";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class TrackCacheStorageForOriginResult
        {

        }
        public class TrackIndexedDBForOriginParams : IMethodParams<TrackIndexedDBForOriginParams, TrackIndexedDBForOriginResult>
        {
            public string GetMethod()
            {
                return "Storage.trackIndexedDBForOrigin";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class TrackIndexedDBForOriginResult
        {

        }
        public class UntrackCacheStorageForOriginParams : IMethodParams<UntrackCacheStorageForOriginParams, UntrackCacheStorageForOriginResult>
        {
            public string GetMethod()
            {
                return "Storage.untrackCacheStorageForOrigin";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class UntrackCacheStorageForOriginResult
        {

        }
        public class UntrackIndexedDBForOriginParams : IMethodParams<UntrackIndexedDBForOriginParams, UntrackIndexedDBForOriginResult>
        {
            public string GetMethod()
            {
                return "Storage.untrackIndexedDBForOrigin";

            }
            /// <summary>
            /// Security origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }

        }
        public class UntrackIndexedDBForOriginResult
        {

        }
        public class GetTrustTokensParams : IMethodParams<GetTrustTokensParams, GetTrustTokensResult>
        {
            public string GetMethod()
            {
                return "Storage.getTrustTokens";

            }

        }
        public class GetTrustTokensResult
        {
            /// <summary>
            /// </summary>
            public StorageDomain.TrustTokens[] Tokens
            {
                get; set;
            }

        }
        public class ClearTrustTokensParams : IMethodParams<ClearTrustTokensParams, ClearTrustTokensResult>
        {
            public string GetMethod()
            {
                return "Storage.clearTrustTokens";

            }
            /// <summary>
            /// </summary>
            public string IssuerOrigin
            {
                get; set;
            }

        }
        public class ClearTrustTokensResult
        {
            /// <summary>
            /// True if any tokens were deleted, false otherwise.
            /// </summary>
            public bool DidDeleteTokens
            {
                get; set;
            }

        }
        public class GetInterestGroupDetailsParams : IMethodParams<GetInterestGroupDetailsParams, GetInterestGroupDetailsResult>
        {
            public string GetMethod()
            {
                return "Storage.getInterestGroupDetails";

            }
            /// <summary>
            /// </summary>
            public string OwnerOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        public class GetInterestGroupDetailsResult
        {
            /// <summary>
            /// </summary>
            public StorageDomain.InterestGroupDetails Details
            {
                get; set;
            }

        }
        public class SetInterestGroupTrackingParams : IMethodParams<SetInterestGroupTrackingParams, SetInterestGroupTrackingResult>
        {
            public string GetMethod()
            {
                return "Storage.setInterestGroupTracking";

            }
            /// <summary>
            /// </summary>
            public bool Enable
            {
                get; set;
            }

        }
        public class SetInterestGroupTrackingResult
        {

        }
        /// <summary>
        /// Enum of possible storage types.
        /// </summary>
        public enum StorageType
        {
            [EnumValue("appcache")]
            Appcache = 1,
            [EnumValue("cookies")]
            Cookies = 2,
            [EnumValue("file_systems")]
            File_systems = 3,
            [EnumValue("indexeddb")]
            Indexeddb = 4,
            [EnumValue("local_storage")]
            Local_storage = 5,
            [EnumValue("shader_cache")]
            Shader_cache = 6,
            [EnumValue("websql")]
            Websql = 7,
            [EnumValue("service_workers")]
            Service_workers = 8,
            [EnumValue("cache_storage")]
            Cache_storage = 9,
            [EnumValue("interest_groups")]
            Interest_groups = 10,
            [EnumValue("all")]
            All = 11,
            [EnumValue("other")]
            Other = 12,

        }
        /// <summary>
        /// Usage for a storage type.
        /// </summary>
        public class UsageForType
        {
            /// <summary>
            /// Name of storage type.
            /// </summary>
            public StorageDomain.StorageType StorageType
            {
                get; set;
            }
            /// <summary>
            /// Storage usage (bytes).
            /// </summary>
            public double Usage
            {
                get; set;
            }

        }
        /// <summary>
        /// Pair of issuer origin and number of available (signed, but not used) Trust
        /// Tokens from that issuer.
        /// </summary>
        [Experimental]
        public class TrustTokens
        {
            /// <summary>
            /// </summary>
            public string IssuerOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double Count
            {
                get; set;
            }

        }
        /// <summary>
        /// Enum of interest group access types.
        /// </summary>
        public enum InterestGroupAccessType
        {
            [EnumValue("join")]
            Join = 1,
            [EnumValue("leave")]
            Leave = 2,
            [EnumValue("update")]
            Update = 3,
            [EnumValue("bid")]
            Bid = 4,
            [EnumValue("win")]
            Win = 5,

        }
        /// <summary>
        /// Ad advertising element inside an interest group.
        /// </summary>
        public class InterestGroupAd
        {
            /// <summary>
            /// </summary>
            public string RenderUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? Metadata
            {
                get; set;
            }

        }
        /// <summary>
        /// The full details of an interest group.
        /// </summary>
        public class InterestGroupDetails
        {
            /// <summary>
            /// </summary>
            public string OwnerOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double ExpirationTime
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string JoiningOrigin
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? BiddingUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? BiddingWasmHelperUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? UpdateUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? TrustedBiddingSignalsUrl
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string[] TrustedBiddingSignalsKeys
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? UserBiddingSignals
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public StorageDomain.InterestGroupAd[] Ads
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public StorageDomain.InterestGroupAd[] AdComponents
            {
                get; set;
            }

        }

    }
    public class SystemInfoDomain : BaseDomain
    {
        public SystemInfoDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "SystemInfo";

            }

        }
        /// <summary>
        /// Returns information about the system.
        /// </summary>
        public async ValueTask<GetInfoResult> GetInfoAsync(GetInfoParams getInfoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getInfoParams, cancellationToken);

        }
        /// <summary>
        /// Returns information about all running processes.
        /// </summary>
        public async ValueTask<GetProcessInfoResult> GetProcessInfoAsync(GetProcessInfoParams getProcessInfoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getProcessInfoParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class GetInfoParams : IMethodParams<GetInfoParams, GetInfoResult>
        {
            public string GetMethod()
            {
                return "SystemInfo.getInfo";

            }

        }
        public class GetInfoResult
        {
            /// <summary>
            /// Information about the GPUs on the system.
            /// </summary>
            public SystemInfoDomain.GPUInfo Gpu
            {
                get; set;
            }
            /// <summary>
            /// A platform-dependent description of the model of the machine. On Mac OS, this is, for
            /// example, 'MacBookPro'. Will be the empty string if not supported.
            /// </summary>
            public string ModelName
            {
                get; set;
            }
            /// <summary>
            /// A platform-dependent description of the version of the machine. On Mac OS, this is, for
            /// example, '10.1'. Will be the empty string if not supported.
            /// </summary>
            public string ModelVersion
            {
                get; set;
            }
            /// <summary>
            /// The command line string used to launch the browser. Will be the empty string if not
            /// supported.
            /// </summary>
            public string CommandLine
            {
                get; set;
            }

        }
        public class GetProcessInfoParams : IMethodParams<GetProcessInfoParams, GetProcessInfoResult>
        {
            public string GetMethod()
            {
                return "SystemInfo.getProcessInfo";

            }

        }
        public class GetProcessInfoResult
        {
            /// <summary>
            /// An array of process info blocks.
            /// </summary>
            public SystemInfoDomain.ProcessInfo[] ProcessInfo
            {
                get; set;
            }

        }
        /// <summary>
        /// Describes a single graphics processor (GPU).
        /// </summary>
        public class GPUDevice
        {
            /// <summary>
            /// PCI ID of the GPU vendor, if available; 0 otherwise.
            /// </summary>
            public double VendorId
            {
                get; set;
            }
            /// <summary>
            /// PCI ID of the GPU device, if available; 0 otherwise.
            /// </summary>
            public double DeviceId
            {
                get; set;
            }
            /// <summary>
            /// Sub sys ID of the GPU, only available on Windows.
            /// </summary>
            public double? SubSysId
            {
                get; set;
            }
            /// <summary>
            /// Revision of the GPU, only available on Windows.
            /// </summary>
            public double? Revision
            {
                get; set;
            }
            /// <summary>
            /// String description of the GPU vendor, if the PCI ID is not available.
            /// </summary>
            public string VendorString
            {
                get; set;
            }
            /// <summary>
            /// String description of the GPU device, if the PCI ID is not available.
            /// </summary>
            public string DeviceString
            {
                get; set;
            }
            /// <summary>
            /// String description of the GPU driver vendor.
            /// </summary>
            public string DriverVendor
            {
                get; set;
            }
            /// <summary>
            /// String description of the GPU driver version.
            /// </summary>
            public string DriverVersion
            {
                get; set;
            }

        }
        /// <summary>
        /// Describes the width and height dimensions of an entity.
        /// </summary>
        public class Size
        {
            /// <summary>
            /// Width in pixels.
            /// </summary>
            public int Width
            {
                get; set;
            }
            /// <summary>
            /// Height in pixels.
            /// </summary>
            public int Height
            {
                get; set;
            }

        }
        /// <summary>
        /// Describes a supported video decoding profile with its associated minimum and
        /// maximum resolutions.
        /// </summary>
        public class VideoDecodeAcceleratorCapability
        {
            /// <summary>
            /// Video codec profile that is supported, e.g. VP9 Profile 2.
            /// </summary>
            public string Profile
            {
                get; set;
            }
            /// <summary>
            /// Maximum video dimensions in pixels supported for this |profile|.
            /// </summary>
            public SystemInfoDomain.Size MaxResolution
            {
                get; set;
            }
            /// <summary>
            /// Minimum video dimensions in pixels supported for this |profile|.
            /// </summary>
            public SystemInfoDomain.Size MinResolution
            {
                get; set;
            }

        }
        /// <summary>
        /// Describes a supported video encoding profile with its associated maximum
        /// resolution and maximum framerate.
        /// </summary>
        public class VideoEncodeAcceleratorCapability
        {
            /// <summary>
            /// Video codec profile that is supported, e.g H264 Main.
            /// </summary>
            public string Profile
            {
                get; set;
            }
            /// <summary>
            /// Maximum video dimensions in pixels supported for this |profile|.
            /// </summary>
            public SystemInfoDomain.Size MaxResolution
            {
                get; set;
            }
            /// <summary>
            /// Maximum encoding framerate in frames per second supported for this
            /// |profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
            /// 24000/1001 fps, etc.
            /// </summary>
            public int MaxFramerateNumerator
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int MaxFramerateDenominator
            {
                get; set;
            }

        }
        /// <summary>
        /// YUV subsampling type of the pixels of a given image.
        /// </summary>
        public enum SubsamplingFormat
        {
            [EnumValue("yuv420")]
            Yuv420 = 1,
            [EnumValue("yuv422")]
            Yuv422 = 2,
            [EnumValue("yuv444")]
            Yuv444 = 3,

        }
        /// <summary>
        /// Image format of a given image.
        /// </summary>
        public enum ImageType
        {
            [EnumValue("jpeg")]
            Jpeg = 1,
            [EnumValue("webp")]
            Webp = 2,
            [EnumValue("unknown")]
            Unknown = 3,

        }
        /// <summary>
        /// Describes a supported image decoding profile with its associated minimum and
        /// maximum resolutions and subsampling.
        /// </summary>
        public class ImageDecodeAcceleratorCapability
        {
            /// <summary>
            /// Image coded, e.g. Jpeg.
            /// </summary>
            public SystemInfoDomain.ImageType ImageType
            {
                get; set;
            }
            /// <summary>
            /// Maximum supported dimensions of the image in pixels.
            /// </summary>
            public SystemInfoDomain.Size MaxDimensions
            {
                get; set;
            }
            /// <summary>
            /// Minimum supported dimensions of the image in pixels.
            /// </summary>
            public SystemInfoDomain.Size MinDimensions
            {
                get; set;
            }
            /// <summary>
            /// Optional array of supported subsampling formats, e.g. 4:2:0, if known.
            /// </summary>
            public SystemInfoDomain.SubsamplingFormat[] Subsamplings
            {
                get; set;
            }

        }
        /// <summary>
        /// Provides information about the GPU(s) on the system.
        /// </summary>
        public class GPUInfo
        {
            /// <summary>
            /// The graphics devices on the system. Element 0 is the primary GPU.
            /// </summary>
            public SystemInfoDomain.GPUDevice[] Devices
            {
                get; set;
            }
            /// <summary>
            /// An optional dictionary of additional GPU related attributes.
            /// </summary>
            public object? AuxAttributes
            {
                get; set;
            }
            /// <summary>
            /// An optional dictionary of graphics features and their status.
            /// </summary>
            public object? FeatureStatus
            {
                get; set;
            }
            /// <summary>
            /// An optional array of GPU driver bug workarounds.
            /// </summary>
            public string[] DriverBugWorkarounds
            {
                get; set;
            }
            /// <summary>
            /// Supported accelerated video decoding capabilities.
            /// </summary>
            public SystemInfoDomain.VideoDecodeAcceleratorCapability[] VideoDecoding
            {
                get; set;
            }
            /// <summary>
            /// Supported accelerated video encoding capabilities.
            /// </summary>
            public SystemInfoDomain.VideoEncodeAcceleratorCapability[] VideoEncoding
            {
                get; set;
            }
            /// <summary>
            /// Supported accelerated image decoding capabilities.
            /// </summary>
            public SystemInfoDomain.ImageDecodeAcceleratorCapability[] ImageDecoding
            {
                get; set;
            }

        }
        /// <summary>
        /// Represents process info.
        /// </summary>
        public class ProcessInfo
        {
            /// <summary>
            /// Specifies process type.
            /// </summary>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Specifies process id.
            /// </summary>
            public int Id
            {
                get; set;
            }
            /// <summary>
            /// Specifies cumulative CPU usage in seconds across all threads of the
            /// process since the process start.
            /// </summary>
            public double CpuTime
            {
                get; set;
            }

        }

    }
    public class TargetDomain : BaseDomain
    {
        public TargetDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Target";

            }

        }
        /// <summary>
        /// Issued when attached to target because of auto-attach or `attachToTarget` command.
        /// </summary>
        [Experimental]
        public event EventHandler<AttachedToTargetParams>? AttachedToTarget;
        /// <summary>
        /// Issued when detached from target for any reason (including `detachFromTarget` command). Can be
        /// issued multiple times per target if multiple sessions have been attached to it.
        /// </summary>
        [Experimental]
        public event EventHandler<DetachedFromTargetParams>? DetachedFromTarget;
        /// <summary>
        /// Notifies about a new protocol message received from the session (as reported in
        /// `attachedToTarget` event).
        /// </summary>
        public event EventHandler<ReceivedMessageFromTargetParams>? ReceivedMessageFromTarget;
        /// <summary>
        /// Issued when a possible inspection target is created.
        /// </summary>
        public event EventHandler<TargetCreatedParams>? TargetCreated;
        /// <summary>
        /// Issued when a target is destroyed.
        /// </summary>
        public event EventHandler<TargetDestroyedParams>? TargetDestroyed;
        /// <summary>
        /// Issued when a target has crashed.
        /// </summary>
        public event EventHandler<TargetCrashedParams>? TargetCrashed;
        /// <summary>
        /// Issued when some information about a target has changed. This only happens between
        /// `targetCreated` and `targetDestroyed`.
        /// </summary>
        public event EventHandler<TargetInfoChangedParams>? TargetInfoChanged;
        /// <summary>
        /// Activates (focuses) the target.
        /// </summary>
        public async ValueTask<ActivateTargetResult> ActivateTargetAsync(ActivateTargetParams activateTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(activateTargetParams, cancellationToken);

        }
        /// <summary>
        /// Attaches to the target with given id.
        /// </summary>
        public async ValueTask<AttachToTargetResult> AttachToTargetAsync(AttachToTargetParams attachToTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(attachToTargetParams, cancellationToken);

        }
        /// <summary>
        /// Attaches to the browser target, only uses flat sessionId mode.
        /// </summary>
        [Experimental]
        public async ValueTask<AttachToBrowserTargetResult> AttachToBrowserTargetAsync(AttachToBrowserTargetParams attachToBrowserTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(attachToBrowserTargetParams, cancellationToken);

        }
        /// <summary>
        /// Closes the target. If the target is a page that gets closed too.
        /// </summary>
        public async ValueTask<CloseTargetResult> CloseTargetAsync(CloseTargetParams closeTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(closeTargetParams, cancellationToken);

        }
        /// <summary>
        /// Inject object to the target's main frame that provides a communication
        /// channel with browser target.
        /// 
        /// Injected object will be available as `window[bindingName]`.
        /// 
        /// The object has the follwing API:
        /// - `binding.send(json)` - a method to send messages over the remote debugging protocol
        /// - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
        /// </summary>
        [Experimental]
        public async ValueTask<ExposeDevToolsProtocolResult> ExposeDevToolsProtocolAsync(ExposeDevToolsProtocolParams exposeDevToolsProtocolParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(exposeDevToolsProtocolParams, cancellationToken);

        }
        /// <summary>
        /// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
        /// one.
        /// </summary>
        [Experimental]
        public async ValueTask<CreateBrowserContextResult> CreateBrowserContextAsync(CreateBrowserContextParams createBrowserContextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(createBrowserContextParams, cancellationToken);

        }
        /// <summary>
        /// Returns all browser contexts created with `Target.createBrowserContext` method.
        /// </summary>
        [Experimental]
        public async ValueTask<GetBrowserContextsResult> GetBrowserContextsAsync(GetBrowserContextsParams getBrowserContextsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getBrowserContextsParams, cancellationToken);

        }
        /// <summary>
        /// Creates a new page.
        /// </summary>
        public async ValueTask<CreateTargetResult> CreateTargetAsync(CreateTargetParams createTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(createTargetParams, cancellationToken);

        }
        /// <summary>
        /// Detaches session with given id.
        /// </summary>
        public async ValueTask<DetachFromTargetResult> DetachFromTargetAsync(DetachFromTargetParams detachFromTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(detachFromTargetParams, cancellationToken);

        }
        /// <summary>
        /// Deletes a BrowserContext. All the belonging pages will be closed without calling their
        /// beforeunload hooks.
        /// </summary>
        [Experimental]
        public async ValueTask<DisposeBrowserContextResult> DisposeBrowserContextAsync(DisposeBrowserContextParams disposeBrowserContextParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disposeBrowserContextParams, cancellationToken);

        }
        /// <summary>
        /// Returns information about a target.
        /// </summary>
        [Experimental]
        public async ValueTask<GetTargetInfoResult> GetTargetInfoAsync(GetTargetInfoParams getTargetInfoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getTargetInfoParams, cancellationToken);

        }
        /// <summary>
        /// Retrieves a list of available targets.
        /// </summary>
        public async ValueTask<GetTargetsResult> GetTargetsAsync(GetTargetsParams getTargetsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getTargetsParams, cancellationToken);

        }
        /// <summary>
        /// Sends protocol message over session with given id.
        /// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
        /// and crbug.com/991325.
        /// </summary>
        [Obsolete]
        public async ValueTask<SendMessageToTargetResult> SendMessageToTargetAsync(SendMessageToTargetParams sendMessageToTargetParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(sendMessageToTargetParams, cancellationToken);

        }
        /// <summary>
        /// Controls whether to automatically attach to new targets which are considered to be related to
        /// this one. When turned on, attaches to all existing related targets as well. When turned off,
        /// automatically detaches from all currently attached targets.
        /// This also clears all targets added by `autoAttachRelated` from the list of targets to watch
        /// for creation of related targets.
        /// </summary>
        [Experimental]
        public async ValueTask<SetAutoAttachResult> SetAutoAttachAsync(SetAutoAttachParams setAutoAttachParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAutoAttachParams, cancellationToken);

        }
        /// <summary>
        /// Adds the specified target to the list of targets that will be monitored for any related target
        /// creation (such as child frames, child workers and new versions of service worker) and reported
        /// through `attachedToTarget`. The specified target is also auto-attached.
        /// This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
        /// `setAutoAttach`. Only available at the Browser target.
        /// </summary>
        [Experimental]
        public async ValueTask<AutoAttachRelatedResult> AutoAttachRelatedAsync(AutoAttachRelatedParams autoAttachRelatedParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(autoAttachRelatedParams, cancellationToken);

        }
        /// <summary>
        /// Controls whether to discover available targets and notify via
        /// `targetCreated/targetInfoChanged/targetDestroyed` events.
        /// </summary>
        public async ValueTask<SetDiscoverTargetsResult> SetDiscoverTargetsAsync(SetDiscoverTargetsParams setDiscoverTargetsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setDiscoverTargetsParams, cancellationToken);

        }
        /// <summary>
        /// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
        /// `true`.
        /// </summary>
        [Experimental]
        public async ValueTask<SetRemoteLocationsResult> SetRemoteLocationsAsync(SetRemoteLocationsParams setRemoteLocationsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setRemoteLocationsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "attachedToTarget": RaiseEvent(AttachedToTarget, messageBytes);
                    break;
                case "detachedFromTarget": RaiseEvent(DetachedFromTarget, messageBytes);
                    break;
                case "receivedMessageFromTarget": RaiseEvent(ReceivedMessageFromTarget, messageBytes);
                    break;
                case "targetCreated": RaiseEvent(TargetCreated, messageBytes);
                    break;
                case "targetDestroyed": RaiseEvent(TargetDestroyed, messageBytes);
                    break;
                case "targetCrashed": RaiseEvent(TargetCrashed, messageBytes);
                    break;
                case "targetInfoChanged": RaiseEvent(TargetInfoChanged, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class AttachedToTargetParams
        {
            /// <summary>
            /// Identifier assigned to the session used to send/receive messages.
            /// </summary>
            public string SessionId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public TargetDomain.TargetInfo TargetInfo
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool WaitingForDebugger
            {
                get; set;
            }

        }
        public class DetachedFromTargetParams
        {
            /// <summary>
            /// Detached session identifier.
            /// </summary>
            public string SessionId
            {
                get; set;
            }
            /// <summary>
            /// Deprecated.
            /// </summary>
            [Obsolete]
            public string? TargetId
            {
                get; set;
            }

        }
        public class ReceivedMessageFromTargetParams
        {
            /// <summary>
            /// Identifier of a session which sends a message.
            /// </summary>
            public string SessionId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// Deprecated.
            /// </summary>
            [Obsolete]
            public string? TargetId
            {
                get; set;
            }

        }
        public class TargetCreatedParams
        {
            /// <summary>
            /// </summary>
            public TargetDomain.TargetInfo TargetInfo
            {
                get; set;
            }

        }
        public class TargetDestroyedParams
        {
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }

        }
        public class TargetCrashedParams
        {
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }
            /// <summary>
            /// Termination status type.
            /// </summary>
            public string Status
            {
                get; set;
            }
            /// <summary>
            /// Termination error code.
            /// </summary>
            public int ErrorCode
            {
                get; set;
            }

        }
        public class TargetInfoChangedParams
        {
            /// <summary>
            /// </summary>
            public TargetDomain.TargetInfo TargetInfo
            {
                get; set;
            }

        }
        public class ActivateTargetParams : IMethodParams<ActivateTargetParams, ActivateTargetResult>
        {
            public string GetMethod()
            {
                return "Target.activateTarget";

            }
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }

        }
        public class ActivateTargetResult
        {

        }
        public class AttachToTargetParams : IMethodParams<AttachToTargetParams, AttachToTargetResult>
        {
            public string GetMethod()
            {
                return "Target.attachToTarget";

            }
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }
            /// <summary>
            /// Enables "flat" access to the session via specifying sessionId attribute in the commands.
            /// We plan to make this the default, deprecate non-flattened mode,
            /// and eventually retire it. See crbug.com/991325.
            /// </summary>
            public bool? Flatten
            {
                get; set;
            }

        }
        public class AttachToTargetResult
        {
            /// <summary>
            /// Id assigned to the session.
            /// </summary>
            public string SessionId
            {
                get; set;
            }

        }
        public class AttachToBrowserTargetParams : IMethodParams<AttachToBrowserTargetParams, AttachToBrowserTargetResult>
        {
            public string GetMethod()
            {
                return "Target.attachToBrowserTarget";

            }

        }
        public class AttachToBrowserTargetResult
        {
            /// <summary>
            /// Id assigned to the session.
            /// </summary>
            public string SessionId
            {
                get; set;
            }

        }
        public class CloseTargetParams : IMethodParams<CloseTargetParams, CloseTargetResult>
        {
            public string GetMethod()
            {
                return "Target.closeTarget";

            }
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }

        }
        public class CloseTargetResult
        {
            /// <summary>
            /// Always set to true. If an error occurs, the response indicates protocol error.
            /// </summary>
            [Obsolete]
            public bool Success
            {
                get; set;
            }

        }
        public class ExposeDevToolsProtocolParams : IMethodParams<ExposeDevToolsProtocolParams, ExposeDevToolsProtocolResult>
        {
            public string GetMethod()
            {
                return "Target.exposeDevToolsProtocol";

            }
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }
            /// <summary>
            /// Binding name, 'cdp' if not specified.
            /// </summary>
            public string? BindingName
            {
                get; set;
            }

        }
        public class ExposeDevToolsProtocolResult
        {

        }
        public class CreateBrowserContextParams : IMethodParams<CreateBrowserContextParams, CreateBrowserContextResult>
        {
            public string GetMethod()
            {
                return "Target.createBrowserContext";

            }
            /// <summary>
            /// If specified, disposes this context when debugging session disconnects.
            /// </summary>
            public bool? DisposeOnDetach
            {
                get; set;
            }
            /// <summary>
            /// Proxy server, similar to the one passed to --proxy-server
            /// </summary>
            public string? ProxyServer
            {
                get; set;
            }
            /// <summary>
            /// Proxy bypass list, similar to the one passed to --proxy-bypass-list
            /// </summary>
            public string? ProxyBypassList
            {
                get; set;
            }
            /// <summary>
            /// An optional list of origins to grant unlimited cross-origin access to.
            /// Parts of the URL other than those constituting origin are ignored.
            /// </summary>
            public string[]? OriginsWithUniversalNetworkAccess
            {
                get; set;
            }

        }
        public class CreateBrowserContextResult
        {
            /// <summary>
            /// The id of the context created.
            /// </summary>
            public string BrowserContextId
            {
                get; set;
            }

        }
        public class GetBrowserContextsParams : IMethodParams<GetBrowserContextsParams, GetBrowserContextsResult>
        {
            public string GetMethod()
            {
                return "Target.getBrowserContexts";

            }

        }
        public class GetBrowserContextsResult
        {
            /// <summary>
            /// An array of browser context ids.
            /// </summary>
            public string[] BrowserContextIds
            {
                get; set;
            }

        }
        public class CreateTargetParams : IMethodParams<CreateTargetParams, CreateTargetResult>
        {
            public string GetMethod()
            {
                return "Target.createTarget";

            }
            /// <summary>
            /// The initial URL the page will be navigated to. An empty string indicates about:blank.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Frame width in DIP (headless chrome only).
            /// </summary>
            public int? Width
            {
                get; set;
            }
            /// <summary>
            /// Frame height in DIP (headless chrome only).
            /// </summary>
            public int? Height
            {
                get; set;
            }
            /// <summary>
            /// The browser context to create the page in.
            /// </summary>
            [Experimental]
            public string? BrowserContextId
            {
                get; set;
            }
            /// <summary>
            /// Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
            /// not supported on MacOS yet, false by default).
            /// </summary>
            [Experimental]
            public bool? EnableBeginFrameControl
            {
                get; set;
            }
            /// <summary>
            /// Whether to create a new Window or Tab (chrome-only, false by default).
            /// </summary>
            public bool? NewWindow
            {
                get; set;
            }
            /// <summary>
            /// Whether to create the target in background or foreground (chrome-only,
            /// false by default).
            /// </summary>
            public bool? Background
            {
                get; set;
            }

        }
        public class CreateTargetResult
        {
            /// <summary>
            /// The id of the page opened.
            /// </summary>
            public string TargetId
            {
                get; set;
            }

        }
        public class DetachFromTargetParams : IMethodParams<DetachFromTargetParams, DetachFromTargetResult>
        {
            public string GetMethod()
            {
                return "Target.detachFromTarget";

            }
            /// <summary>
            /// Session to detach.
            /// </summary>
            public string? SessionId
            {
                get; set;
            }
            /// <summary>
            /// Deprecated.
            /// </summary>
            [Obsolete]
            public string? TargetId
            {
                get; set;
            }

        }
        public class DetachFromTargetResult
        {

        }
        public class DisposeBrowserContextParams : IMethodParams<DisposeBrowserContextParams, DisposeBrowserContextResult>
        {
            public string GetMethod()
            {
                return "Target.disposeBrowserContext";

            }
            /// <summary>
            /// </summary>
            public string BrowserContextId
            {
                get; set;
            }

        }
        public class DisposeBrowserContextResult
        {

        }
        public class GetTargetInfoParams : IMethodParams<GetTargetInfoParams, GetTargetInfoResult>
        {
            public string GetMethod()
            {
                return "Target.getTargetInfo";

            }
            /// <summary>
            /// </summary>
            public string? TargetId
            {
                get; set;
            }

        }
        public class GetTargetInfoResult
        {
            /// <summary>
            /// </summary>
            public TargetDomain.TargetInfo TargetInfo
            {
                get; set;
            }

        }
        public class GetTargetsParams : IMethodParams<GetTargetsParams, GetTargetsResult>
        {
            public string GetMethod()
            {
                return "Target.getTargets";

            }

        }
        public class GetTargetsResult
        {
            /// <summary>
            /// The list of targets.
            /// </summary>
            public TargetDomain.TargetInfo[] TargetInfos
            {
                get; set;
            }

        }
        public class SendMessageToTargetParams : IMethodParams<SendMessageToTargetParams, SendMessageToTargetResult>
        {
            public string GetMethod()
            {
                return "Target.sendMessageToTarget";

            }
            /// <summary>
            /// </summary>
            public string Message
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the session.
            /// </summary>
            public string? SessionId
            {
                get; set;
            }
            /// <summary>
            /// Deprecated.
            /// </summary>
            [Obsolete]
            public string? TargetId
            {
                get; set;
            }

        }
        public class SendMessageToTargetResult
        {

        }
        public class SetAutoAttachParams : IMethodParams<SetAutoAttachParams, SetAutoAttachResult>
        {
            public string GetMethod()
            {
                return "Target.setAutoAttach";

            }
            /// <summary>
            /// Whether to auto-attach to related targets.
            /// </summary>
            public bool AutoAttach
            {
                get; set;
            }
            /// <summary>
            /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
            /// to run paused targets.
            /// </summary>
            public bool WaitForDebuggerOnStart
            {
                get; set;
            }
            /// <summary>
            /// Enables "flat" access to the session via specifying sessionId attribute in the commands.
            /// We plan to make this the default, deprecate non-flattened mode,
            /// and eventually retire it. See crbug.com/991325.
            /// </summary>
            public bool? Flatten
            {
                get; set;
            }

        }
        public class SetAutoAttachResult
        {

        }
        public class AutoAttachRelatedParams : IMethodParams<AutoAttachRelatedParams, AutoAttachRelatedResult>
        {
            public string GetMethod()
            {
                return "Target.autoAttachRelated";

            }
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }
            /// <summary>
            /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
            /// to run paused targets.
            /// </summary>
            public bool WaitForDebuggerOnStart
            {
                get; set;
            }

        }
        public class AutoAttachRelatedResult
        {

        }
        public class SetDiscoverTargetsParams : IMethodParams<SetDiscoverTargetsParams, SetDiscoverTargetsResult>
        {
            public string GetMethod()
            {
                return "Target.setDiscoverTargets";

            }
            /// <summary>
            /// Whether to discover available targets.
            /// </summary>
            public bool Discover
            {
                get; set;
            }

        }
        public class SetDiscoverTargetsResult
        {

        }
        public class SetRemoteLocationsParams : IMethodParams<SetRemoteLocationsParams, SetRemoteLocationsResult>
        {
            public string GetMethod()
            {
                return "Target.setRemoteLocations";

            }
            /// <summary>
            /// List of remote locations.
            /// </summary>
            public TargetDomain.RemoteLocation[] Locations
            {
                get; set;
            }

        }
        public class SetRemoteLocationsResult
        {

        }
        /// <summary>
        /// </summary>
        public class TargetInfo
        {
            /// <summary>
            /// </summary>
            public string TargetId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Title
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Whether the target has an attached client.
            /// </summary>
            public bool Attached
            {
                get; set;
            }
            /// <summary>
            /// Opener target Id
            /// </summary>
            public string? OpenerId
            {
                get; set;
            }
            /// <summary>
            /// Whether the target has access to the originating window.
            /// </summary>
            [Experimental]
            public bool CanAccessOpener
            {
                get; set;
            }
            /// <summary>
            /// Frame id of originating window (is only set if target has an opener).
            /// </summary>
            [Experimental]
            public string? OpenerFrameId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            [Experimental]
            public string? BrowserContextId
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class RemoteLocation
        {
            /// <summary>
            /// </summary>
            public string Host
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int Port
            {
                get; set;
            }

        }

    }
    public class TetheringDomain : BaseDomain
    {
        public TetheringDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Tethering";

            }

        }
        /// <summary>
        /// Informs that port was successfully bound and got a specified connection id.
        /// </summary>
        public event EventHandler<AcceptedParams>? Accepted;
        /// <summary>
        /// Request browser port binding.
        /// </summary>
        public async ValueTask<BindResult> BindAsync(BindParams bindParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(bindParams, cancellationToken);

        }
        /// <summary>
        /// Request browser port unbinding.
        /// </summary>
        public async ValueTask<UnbindResult> UnbindAsync(UnbindParams unbindParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(unbindParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "accepted": RaiseEvent(Accepted, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class AcceptedParams
        {
            /// <summary>
            /// Port number that was successfully bound.
            /// </summary>
            public int Port
            {
                get; set;
            }
            /// <summary>
            /// Connection id to be used.
            /// </summary>
            public string ConnectionId
            {
                get; set;
            }

        }
        public class BindParams : IMethodParams<BindParams, BindResult>
        {
            public string GetMethod()
            {
                return "Tethering.bind";

            }
            /// <summary>
            /// Port number to bind.
            /// </summary>
            public int Port
            {
                get; set;
            }

        }
        public class BindResult
        {

        }
        public class UnbindParams : IMethodParams<UnbindParams, UnbindResult>
        {
            public string GetMethod()
            {
                return "Tethering.unbind";

            }
            /// <summary>
            /// Port number to unbind.
            /// </summary>
            public int Port
            {
                get; set;
            }

        }
        public class UnbindResult
        {

        }

    }
    public class TracingDomain : BaseDomain
    {
        public TracingDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Tracing";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<BufferUsageParams>? BufferUsage;
        /// <summary>
        /// Contains an bucket of collected trace events. When tracing is stopped collected events will be
        /// send as a sequence of dataCollected events followed by tracingComplete event.
        /// </summary>
        public event EventHandler<DataCollectedParams>? DataCollected;
        /// <summary>
        /// Signals that tracing is stopped and there is no trace buffers pending flush, all data were
        /// delivered via dataCollected events.
        /// </summary>
        public event EventHandler<TracingCompleteParams>? TracingComplete;
        /// <summary>
        /// Stop trace events collection.
        /// </summary>
        public async ValueTask<EndResult> EndAsync(EndParams endParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(endParams, cancellationToken);

        }
        /// <summary>
        /// Gets supported tracing categories.
        /// </summary>
        public async ValueTask<GetCategoriesResult> GetCategoriesAsync(GetCategoriesParams getCategoriesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCategoriesParams, cancellationToken);

        }
        /// <summary>
        /// Record a clock sync marker in the trace.
        /// </summary>
        public async ValueTask<RecordClockSyncMarkerResult> RecordClockSyncMarkerAsync(RecordClockSyncMarkerParams recordClockSyncMarkerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(recordClockSyncMarkerParams, cancellationToken);

        }
        /// <summary>
        /// Request a global memory dump.
        /// </summary>
        public async ValueTask<RequestMemoryDumpResult> RequestMemoryDumpAsync(RequestMemoryDumpParams requestMemoryDumpParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(requestMemoryDumpParams, cancellationToken);

        }
        /// <summary>
        /// Start trace events collection.
        /// </summary>
        public async ValueTask<StartResult> StartAsync(StartParams startParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "bufferUsage": RaiseEvent(BufferUsage, messageBytes);
                    break;
                case "dataCollected": RaiseEvent(DataCollected, messageBytes);
                    break;
                case "tracingComplete": RaiseEvent(TracingComplete, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class BufferUsageParams
        {
            /// <summary>
            /// A number in range [0..1] that indicates the used size of event buffer as a fraction of its
            /// total size.
            /// </summary>
            public double? PercentFull
            {
                get; set;
            }
            /// <summary>
            /// An approximate number of events in the trace log.
            /// </summary>
            public double? EventCount
            {
                get; set;
            }
            /// <summary>
            /// A number in range [0..1] that indicates the used size of event buffer as a fraction of its
            /// total size.
            /// </summary>
            public double? Value
            {
                get; set;
            }

        }
        public class DataCollectedParams
        {
            /// <summary>
            /// </summary>
            public object[] Value
            {
                get; set;
            }

        }
        public class TracingCompleteParams
        {
            /// <summary>
            /// Indicates whether some trace data is known to have been lost, e.g. because the trace ring
            /// buffer wrapped around.
            /// </summary>
            public bool DataLossOccurred
            {
                get; set;
            }
            /// <summary>
            /// A handle of the stream that holds resulting trace data.
            /// </summary>
            public string? Stream
            {
                get; set;
            }
            /// <summary>
            /// Trace data format of returned stream.
            /// </summary>
            public TracingDomain.StreamFormat? TraceFormat
            {
                get; set;
            }
            /// <summary>
            /// Compression format of returned stream.
            /// </summary>
            public TracingDomain.StreamCompression? StreamCompression
            {
                get; set;
            }

        }
        public class EndParams : IMethodParams<EndParams, EndResult>
        {
            public string GetMethod()
            {
                return "Tracing.end";

            }

        }
        public class EndResult
        {

        }
        public class GetCategoriesParams : IMethodParams<GetCategoriesParams, GetCategoriesResult>
        {
            public string GetMethod()
            {
                return "Tracing.getCategories";

            }

        }
        public class GetCategoriesResult
        {
            /// <summary>
            /// A list of supported tracing categories.
            /// </summary>
            public string[] Categories
            {
                get; set;
            }

        }
        public class RecordClockSyncMarkerParams : IMethodParams<RecordClockSyncMarkerParams, RecordClockSyncMarkerResult>
        {
            public string GetMethod()
            {
                return "Tracing.recordClockSyncMarker";

            }
            /// <summary>
            /// The ID of this clock sync marker
            /// </summary>
            public string SyncId
            {
                get; set;
            }

        }
        public class RecordClockSyncMarkerResult
        {

        }
        public class RequestMemoryDumpParams : IMethodParams<RequestMemoryDumpParams, RequestMemoryDumpResult>
        {
            public string GetMethod()
            {
                return "Tracing.requestMemoryDump";

            }
            /// <summary>
            /// Enables more deterministic results by forcing garbage collection
            /// </summary>
            public bool? Deterministic
            {
                get; set;
            }
            /// <summary>
            /// Specifies level of details in memory dump. Defaults to "detailed".
            /// </summary>
            public TracingDomain.MemoryDumpLevelOfDetail? LevelOfDetail
            {
                get; set;
            }

        }
        public class RequestMemoryDumpResult
        {
            /// <summary>
            /// GUID of the resulting global memory dump.
            /// </summary>
            public string DumpGuid
            {
                get; set;
            }
            /// <summary>
            /// True iff the global memory dump succeeded.
            /// </summary>
            public bool Success
            {
                get; set;
            }

        }
        public class StartParams : IMethodParams<StartParams, StartResult>
        {
            public string GetMethod()
            {
                return "Tracing.start";

            }
            /// <summary>
            /// Category/tag filter
            /// </summary>
            [Obsolete]
            public string? Categories
            {
                get; set;
            }
            /// <summary>
            /// Tracing options
            /// </summary>
            [Obsolete]
            public string? Options
            {
                get; set;
            }
            /// <summary>
            /// If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
            /// </summary>
            public double? BufferUsageReportingInterval
            {
                get; set;
            }
            /// <summary>
            /// Whether to report trace events as series of dataCollected events or to save trace to a
            /// stream (defaults to `ReportEvents`).
            /// </summary>
            /// <value>
            /// ReportEvents,ReturnAsStream
            /// </value>
            public string? TransferMode
            {
                get; set;
            }
            /// <summary>
            /// Trace data format to use. This only applies when using `ReturnAsStream`
            /// transfer mode (defaults to `json`).
            /// </summary>
            public TracingDomain.StreamFormat? StreamFormat
            {
                get; set;
            }
            /// <summary>
            /// Compression format to use. This only applies when using `ReturnAsStream`
            /// transfer mode (defaults to `none`)
            /// </summary>
            public TracingDomain.StreamCompression? StreamCompression
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public TracingDomain.TraceConfig? TraceConfig
            {
                get; set;
            }
            /// <summary>
            /// Base64-encoded serialized perfetto.protos.TraceConfig protobuf message
            /// When specified, the parameters `categories`, `options`, `traceConfig`
            /// are ignored. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? PerfettoConfig
            {
                get; set;
            }
            /// <summary>
            /// Backend type (defaults to `auto`)
            /// </summary>
            public TracingDomain.TracingBackend? TracingBackend
            {
                get; set;
            }

        }
        public class StartResult
        {

        }
        /// <summary>
        /// Configuration for memory dump. Used only when "memory-infra" category is enabled.
        /// </summary>
        public class MemoryDumpConfig
        {

        }
        /// <summary>
        /// </summary>
        public class TraceConfig
        {
            /// <summary>
            /// Controls how the trace buffer stores data.
            /// </summary>
            /// <value>
            /// recordUntilFull,recordContinuously,recordAsMuchAsPossible,echoToConsole
            /// </value>
            public string? RecordMode
            {
                get; set;
            }
            /// <summary>
            /// Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
            /// of 200 MB would be used.
            /// </summary>
            public double? TraceBufferSizeInKb
            {
                get; set;
            }
            /// <summary>
            /// Turns on JavaScript stack sampling.
            /// </summary>
            public bool? EnableSampling
            {
                get; set;
            }
            /// <summary>
            /// Turns on system tracing.
            /// </summary>
            public bool? EnableSystrace
            {
                get; set;
            }
            /// <summary>
            /// Turns on argument filter.
            /// </summary>
            public bool? EnableArgumentFilter
            {
                get; set;
            }
            /// <summary>
            /// Included category filters.
            /// </summary>
            public string[]? IncludedCategories
            {
                get; set;
            }
            /// <summary>
            /// Excluded category filters.
            /// </summary>
            public string[]? ExcludedCategories
            {
                get; set;
            }
            /// <summary>
            /// Configuration to synthesize the delays in tracing.
            /// </summary>
            public string[]? SyntheticDelays
            {
                get; set;
            }
            /// <summary>
            /// Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
            /// </summary>
            public TracingDomain.MemoryDumpConfig? MemoryDumpConfig
            {
                get; set;
            }

        }
        /// <summary>
        /// Data format of a trace. Can be either the legacy JSON format or the
        /// protocol buffer format. Note that the JSON format will be deprecated soon.
        /// </summary>
        public enum StreamFormat
        {
            [EnumValue("json")]
            Json = 1,
            [EnumValue("proto")]
            Proto = 2,

        }
        /// <summary>
        /// Compression type to use for traces returned via streams.
        /// </summary>
        public enum StreamCompression
        {
            [EnumValue("none")]
            None = 1,
            [EnumValue("gzip")]
            Gzip = 2,

        }
        /// <summary>
        /// Details exposed when memory request explicitly declared.
        /// Keep consistent with memory_dump_request_args.h and
        /// memory_instrumentation.mojom
        /// </summary>
        public enum MemoryDumpLevelOfDetail
        {
            [EnumValue("background")]
            Background = 1,
            [EnumValue("light")]
            Light = 2,
            [EnumValue("detailed")]
            Detailed = 3,

        }
        /// <summary>
        /// Backend type to use for tracing. `chrome` uses the Chrome-integrated
        /// tracing service and is supported on all platforms. `system` is only
        /// supported on Chrome OS and uses the Perfetto system tracing service.
        /// `auto` chooses `system` when the perfettoConfig provided to Tracing.start
        /// specifies at least one non-Chrome data source; otherwise uses `chrome`.
        /// </summary>
        public enum TracingBackend
        {
            [EnumValue("auto")]
            Auto = 1,
            [EnumValue("chrome")]
            Chrome = 2,
            [EnumValue("system")]
            System = 3,

        }

    }
    public class FetchDomain : BaseDomain
    {
        public FetchDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Fetch";

            }

        }
        /// <summary>
        /// Issued when the domain is enabled and the request URL matches the
        /// specified filter. The request is paused until the client responds
        /// with one of continueRequest, failRequest or fulfillRequest.
        /// The stage of the request can be determined by presence of responseErrorReason
        /// and responseStatusCode -- the request is at the response stage if either
        /// of these fields is present and in the request stage otherwise.
        /// </summary>
        public event EventHandler<RequestPausedParams>? RequestPaused;
        /// <summary>
        /// Issued when the domain is enabled with handleAuthRequests set to true.
        /// The request is paused until client responds with continueWithAuth.
        /// </summary>
        public event EventHandler<AuthRequiredParams>? AuthRequired;
        /// <summary>
        /// Disables the fetch domain.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables issuing of requestPaused events. A request will be paused until client
        /// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Causes the request to fail with specified reason.
        /// </summary>
        public async ValueTask<FailRequestResult> FailRequestAsync(FailRequestParams failRequestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(failRequestParams, cancellationToken);

        }
        /// <summary>
        /// Provides response to the request.
        /// </summary>
        public async ValueTask<FulfillRequestResult> FulfillRequestAsync(FulfillRequestParams fulfillRequestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(fulfillRequestParams, cancellationToken);

        }
        /// <summary>
        /// Continues the request, optionally modifying some of its parameters.
        /// </summary>
        public async ValueTask<ContinueRequestResult> ContinueRequestAsync(ContinueRequestParams continueRequestParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(continueRequestParams, cancellationToken);

        }
        /// <summary>
        /// Continues a request supplying authChallengeResponse following authRequired event.
        /// </summary>
        public async ValueTask<ContinueWithAuthResult> ContinueWithAuthAsync(ContinueWithAuthParams continueWithAuthParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(continueWithAuthParams, cancellationToken);

        }
        /// <summary>
        /// Continues loading of the paused response, optionally modifying the
        /// response headers. If either responseCode or headers are modified, all of them
        /// must be present.
        /// </summary>
        [Experimental]
        public async ValueTask<ContinueResponseResult> ContinueResponseAsync(ContinueResponseParams continueResponseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(continueResponseParams, cancellationToken);

        }
        /// <summary>
        /// Causes the body of the response to be received from the server and
        /// returned as a single string. May only be issued for a request that
        /// is paused in the Response stage and is mutually exclusive with
        /// takeResponseBodyForInterceptionAsStream. Calling other methods that
        /// affect the request or disabling fetch domain before body is received
        /// results in an undefined behavior.
        /// </summary>
        public async ValueTask<GetResponseBodyResult> GetResponseBodyAsync(GetResponseBodyParams getResponseBodyParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getResponseBodyParams, cancellationToken);

        }
        /// <summary>
        /// Returns a handle to the stream representing the response body.
        /// The request must be paused in the HeadersReceived stage.
        /// Note that after this command the request can't be continued
        /// as is -- client either needs to cancel it or to provide the
        /// response body.
        /// The stream only supports sequential read, IO.read will fail if the position
        /// is specified.
        /// This method is mutually exclusive with getResponseBody.
        /// Calling other methods that affect the request or disabling fetch
        /// domain before body is received results in an undefined behavior.
        /// </summary>
        public async ValueTask<TakeResponseBodyAsStreamResult> TakeResponseBodyAsStreamAsync(TakeResponseBodyAsStreamParams takeResponseBodyAsStreamParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takeResponseBodyAsStreamParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "requestPaused": RaiseEvent(RequestPaused, messageBytes);
                    break;
                case "authRequired": RaiseEvent(AuthRequired, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class RequestPausedParams
        {
            /// <summary>
            /// Each request the page makes will have a unique id.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// The details of the request.
            /// </summary>
            public NetworkDomain.Request Request
            {
                get; set;
            }
            /// <summary>
            /// The id of the frame that initiated the request.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// How the requested resource will be used.
            /// </summary>
            public NetworkDomain.ResourceType ResourceType
            {
                get; set;
            }
            /// <summary>
            /// Response error if intercepted at response stage.
            /// </summary>
            public NetworkDomain.ErrorReason? ResponseErrorReason
            {
                get; set;
            }
            /// <summary>
            /// Response code if intercepted at response stage.
            /// </summary>
            public int? ResponseStatusCode
            {
                get; set;
            }
            /// <summary>
            /// Response status text if intercepted at response stage.
            /// </summary>
            public string? ResponseStatusText
            {
                get; set;
            }
            /// <summary>
            /// Response headers if intercepted at the response stage.
            /// </summary>
            public FetchDomain.HeaderEntry[]? ResponseHeaders
            {
                get; set;
            }
            /// <summary>
            /// If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
            /// then this networkId will be the same as the requestId present in the requestWillBeSent event.
            /// </summary>
            public string? NetworkId
            {
                get; set;
            }

        }
        public class AuthRequiredParams
        {
            /// <summary>
            /// Each request the page makes will have a unique id.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// The details of the request.
            /// </summary>
            public NetworkDomain.Request Request
            {
                get; set;
            }
            /// <summary>
            /// The id of the frame that initiated the request.
            /// </summary>
            public string FrameId
            {
                get; set;
            }
            /// <summary>
            /// How the requested resource will be used.
            /// </summary>
            public NetworkDomain.ResourceType ResourceType
            {
                get; set;
            }
            /// <summary>
            /// Details of the Authorization Challenge encountered.
            /// If this is set, client should respond with continueRequest that
            /// contains AuthChallengeResponse.
            /// </summary>
            public FetchDomain.AuthChallenge AuthChallenge
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Fetch.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Fetch.enable";

            }
            /// <summary>
            /// If specified, only requests matching any of these patterns will produce
            /// fetchRequested event and will be paused until clients response. If not set,
            /// all requests will be affected.
            /// </summary>
            public FetchDomain.RequestPattern[]? Patterns
            {
                get; set;
            }
            /// <summary>
            /// If true, authRequired events will be issued and requests will be paused
            /// expecting a call to continueWithAuth.
            /// </summary>
            public bool? HandleAuthRequests
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        public class FailRequestParams : IMethodParams<FailRequestParams, FailRequestResult>
        {
            public string GetMethod()
            {
                return "Fetch.failRequest";

            }
            /// <summary>
            /// An id the client received in requestPaused event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Causes the request to fail with the given reason.
            /// </summary>
            public NetworkDomain.ErrorReason ErrorReason
            {
                get; set;
            }

        }
        public class FailRequestResult
        {

        }
        public class FulfillRequestParams : IMethodParams<FulfillRequestParams, FulfillRequestResult>
        {
            public string GetMethod()
            {
                return "Fetch.fulfillRequest";

            }
            /// <summary>
            /// An id the client received in requestPaused event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// An HTTP response code.
            /// </summary>
            public int ResponseCode
            {
                get; set;
            }
            /// <summary>
            /// Response headers.
            /// </summary>
            public FetchDomain.HeaderEntry[]? ResponseHeaders
            {
                get; set;
            }
            /// <summary>
            /// Alternative way of specifying response headers as a \0-separated
            /// series of name: value pairs. Prefer the above method unless you
            /// need to represent some non-UTF8 values that can't be transmitted
            /// over the protocol as text. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? BinaryResponseHeaders
            {
                get; set;
            }
            /// <summary>
            /// A response body. If absent, original response body will be used if
            /// the request is intercepted at the response stage and empty body
            /// will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? Body
            {
                get; set;
            }
            /// <summary>
            /// A textual representation of responseCode.
            /// If absent, a standard phrase matching responseCode is used.
            /// </summary>
            public string? ResponsePhrase
            {
                get; set;
            }

        }
        public class FulfillRequestResult
        {

        }
        public class ContinueRequestParams : IMethodParams<ContinueRequestParams, ContinueRequestResult>
        {
            public string GetMethod()
            {
                return "Fetch.continueRequest";

            }
            /// <summary>
            /// An id the client received in requestPaused event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// If set, the request url will be modified in a way that's not observable by page.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// If set, the request method is overridden.
            /// </summary>
            public string? Method
            {
                get; set;
            }
            /// <summary>
            /// If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? PostData
            {
                get; set;
            }
            /// <summary>
            /// If set, overrides the request headers.
            /// </summary>
            public FetchDomain.HeaderEntry[]? Headers
            {
                get; set;
            }
            /// <summary>
            /// If set, overrides response interception behavior for this request.
            /// </summary>
            [Experimental]
            public bool? InterceptResponse
            {
                get; set;
            }

        }
        public class ContinueRequestResult
        {

        }
        public class ContinueWithAuthParams : IMethodParams<ContinueWithAuthParams, ContinueWithAuthResult>
        {
            public string GetMethod()
            {
                return "Fetch.continueWithAuth";

            }
            /// <summary>
            /// An id the client received in authRequired event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// Response to  with an authChallenge.
            /// </summary>
            public FetchDomain.AuthChallengeResponse AuthChallengeResponse
            {
                get; set;
            }

        }
        public class ContinueWithAuthResult
        {

        }
        public class ContinueResponseParams : IMethodParams<ContinueResponseParams, ContinueResponseResult>
        {
            public string GetMethod()
            {
                return "Fetch.continueResponse";

            }
            /// <summary>
            /// An id the client received in requestPaused event.
            /// </summary>
            public string RequestId
            {
                get; set;
            }
            /// <summary>
            /// An HTTP response code. If absent, original response code will be used.
            /// </summary>
            public int? ResponseCode
            {
                get; set;
            }
            /// <summary>
            /// A textual representation of responseCode.
            /// If absent, a standard phrase matching responseCode is used.
            /// </summary>
            public string? ResponsePhrase
            {
                get; set;
            }
            /// <summary>
            /// Response headers. If absent, original response headers will be used.
            /// </summary>
            public FetchDomain.HeaderEntry[]? ResponseHeaders
            {
                get; set;
            }
            /// <summary>
            /// Alternative way of specifying response headers as a \0-separated
            /// series of name: value pairs. Prefer the above method unless you
            /// need to represent some non-UTF8 values that can't be transmitted
            /// over the protocol as text. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? BinaryResponseHeaders
            {
                get; set;
            }

        }
        public class ContinueResponseResult
        {

        }
        public class GetResponseBodyParams : IMethodParams<GetResponseBodyParams, GetResponseBodyResult>
        {
            public string GetMethod()
            {
                return "Fetch.getResponseBody";

            }
            /// <summary>
            /// Identifier for the intercepted request to get body for.
            /// </summary>
            public string RequestId
            {
                get; set;
            }

        }
        public class GetResponseBodyResult
        {
            /// <summary>
            /// Response body.
            /// </summary>
            public string Body
            {
                get; set;
            }
            /// <summary>
            /// True, if content was sent as base64.
            /// </summary>
            public bool Base64Encoded
            {
                get; set;
            }

        }
        public class TakeResponseBodyAsStreamParams : IMethodParams<TakeResponseBodyAsStreamParams, TakeResponseBodyAsStreamResult>
        {
            public string GetMethod()
            {
                return "Fetch.takeResponseBodyAsStream";

            }
            /// <summary>
            /// </summary>
            public string RequestId
            {
                get; set;
            }

        }
        public class TakeResponseBodyAsStreamResult
        {
            /// <summary>
            /// </summary>
            public string Stream
            {
                get; set;
            }

        }
        /// <summary>
        /// Stages of the request to handle. Request will intercept before the request is
        /// sent. Response will intercept after the response is received (but before response
        /// body is received).
        /// </summary>
        public enum RequestStage
        {
            [EnumValue("Request")]
            Request = 1,
            [EnumValue("Response")]
            Response = 2,

        }
        /// <summary>
        /// </summary>
        public class RequestPattern
        {
            /// <summary>
            /// Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
            /// backslash. Omitting is equivalent to `"*"`.
            /// </summary>
            public string? UrlPattern
            {
                get; set;
            }
            /// <summary>
            /// If set, only requests for matching resource types will be intercepted.
            /// </summary>
            public NetworkDomain.ResourceType? ResourceType
            {
                get; set;
            }
            /// <summary>
            /// Stage at which to begin intercepting requests. Default is Request.
            /// </summary>
            public FetchDomain.RequestStage? RequestStage
            {
                get; set;
            }

        }
        /// <summary>
        /// Response HTTP header entry
        /// </summary>
        public class HeaderEntry
        {
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Authorization challenge for HTTP status code 401 or 407.
        /// </summary>
        public class AuthChallenge
        {
            /// <summary>
            /// Source of the authentication challenge.
            /// </summary>
            /// <value>
            /// Server,Proxy
            /// </value>
            public string? Source
            {
                get; set;
            }
            /// <summary>
            /// Origin of the challenger.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// The authentication scheme used, such as basic or digest
            /// </summary>
            public string Scheme
            {
                get; set;
            }
            /// <summary>
            /// The realm of the challenge. May be empty.
            /// </summary>
            public string Realm
            {
                get; set;
            }

        }
        /// <summary>
        /// Response to an AuthChallenge.
        /// </summary>
        public class AuthChallengeResponse
        {
            /// <summary>
            /// The decision on what to do in response to the authorization challenge.  Default means
            /// deferring to the default behavior of the net stack, which will likely either the Cancel
            /// authentication or display a popup dialog box.
            /// </summary>
            /// <value>
            /// Default,CancelAuth,ProvideCredentials
            /// </value>
            public string Response
            {
                get; set;
            }
            /// <summary>
            /// The username to provide, possibly empty. Should only be set if response is
            /// ProvideCredentials.
            /// </summary>
            public string? Username
            {
                get; set;
            }
            /// <summary>
            /// The password to provide, possibly empty. Should only be set if response is
            /// ProvideCredentials.
            /// </summary>
            public string? Password
            {
                get; set;
            }

        }

    }
    public class WebAudioDomain : BaseDomain
    {
        public WebAudioDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "WebAudio";

            }

        }
        /// <summary>
        /// Notifies that a new BaseAudioContext has been created.
        /// </summary>
        public event EventHandler<ContextCreatedParams>? ContextCreated;
        /// <summary>
        /// Notifies that an existing BaseAudioContext will be destroyed.
        /// </summary>
        public event EventHandler<ContextWillBeDestroyedParams>? ContextWillBeDestroyed;
        /// <summary>
        /// Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
        /// </summary>
        public event EventHandler<ContextChangedParams>? ContextChanged;
        /// <summary>
        /// Notifies that the construction of an AudioListener has finished.
        /// </summary>
        public event EventHandler<AudioListenerCreatedParams>? AudioListenerCreated;
        /// <summary>
        /// Notifies that a new AudioListener has been created.
        /// </summary>
        public event EventHandler<AudioListenerWillBeDestroyedParams>? AudioListenerWillBeDestroyed;
        /// <summary>
        /// Notifies that a new AudioNode has been created.
        /// </summary>
        public event EventHandler<AudioNodeCreatedParams>? AudioNodeCreated;
        /// <summary>
        /// Notifies that an existing AudioNode has been destroyed.
        /// </summary>
        public event EventHandler<AudioNodeWillBeDestroyedParams>? AudioNodeWillBeDestroyed;
        /// <summary>
        /// Notifies that a new AudioParam has been created.
        /// </summary>
        public event EventHandler<AudioParamCreatedParams>? AudioParamCreated;
        /// <summary>
        /// Notifies that an existing AudioParam has been destroyed.
        /// </summary>
        public event EventHandler<AudioParamWillBeDestroyedParams>? AudioParamWillBeDestroyed;
        /// <summary>
        /// Notifies that two AudioNodes are connected.
        /// </summary>
        public event EventHandler<NodesConnectedParams>? NodesConnected;
        /// <summary>
        /// Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
        /// </summary>
        public event EventHandler<NodesDisconnectedParams>? NodesDisconnected;
        /// <summary>
        /// Notifies that an AudioNode is connected to an AudioParam.
        /// </summary>
        public event EventHandler<NodeParamConnectedParams>? NodeParamConnected;
        /// <summary>
        /// Notifies that an AudioNode is disconnected to an AudioParam.
        /// </summary>
        public event EventHandler<NodeParamDisconnectedParams>? NodeParamDisconnected;
        /// <summary>
        /// Enables the WebAudio domain and starts sending context lifetime events.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Disables the WebAudio domain.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Fetch the realtime data from the registered contexts.
        /// </summary>
        public async ValueTask<GetRealtimeDataResult> GetRealtimeDataAsync(GetRealtimeDataParams getRealtimeDataParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getRealtimeDataParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "contextCreated": RaiseEvent(ContextCreated, messageBytes);
                    break;
                case "contextWillBeDestroyed": RaiseEvent(ContextWillBeDestroyed, messageBytes);
                    break;
                case "contextChanged": RaiseEvent(ContextChanged, messageBytes);
                    break;
                case "audioListenerCreated": RaiseEvent(AudioListenerCreated, messageBytes);
                    break;
                case "audioListenerWillBeDestroyed": RaiseEvent(AudioListenerWillBeDestroyed, messageBytes);
                    break;
                case "audioNodeCreated": RaiseEvent(AudioNodeCreated, messageBytes);
                    break;
                case "audioNodeWillBeDestroyed": RaiseEvent(AudioNodeWillBeDestroyed, messageBytes);
                    break;
                case "audioParamCreated": RaiseEvent(AudioParamCreated, messageBytes);
                    break;
                case "audioParamWillBeDestroyed": RaiseEvent(AudioParamWillBeDestroyed, messageBytes);
                    break;
                case "nodesConnected": RaiseEvent(NodesConnected, messageBytes);
                    break;
                case "nodesDisconnected": RaiseEvent(NodesDisconnected, messageBytes);
                    break;
                case "nodeParamConnected": RaiseEvent(NodeParamConnected, messageBytes);
                    break;
                case "nodeParamDisconnected": RaiseEvent(NodeParamDisconnected, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class ContextCreatedParams
        {
            /// <summary>
            /// </summary>
            public WebAudioDomain.BaseAudioContext Context
            {
                get; set;
            }

        }
        public class ContextWillBeDestroyedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }

        }
        public class ContextChangedParams
        {
            /// <summary>
            /// </summary>
            public WebAudioDomain.BaseAudioContext Context
            {
                get; set;
            }

        }
        public class AudioListenerCreatedParams
        {
            /// <summary>
            /// </summary>
            public WebAudioDomain.AudioListener Listener
            {
                get; set;
            }

        }
        public class AudioListenerWillBeDestroyedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ListenerId
            {
                get; set;
            }

        }
        public class AudioNodeCreatedParams
        {
            /// <summary>
            /// </summary>
            public WebAudioDomain.AudioNode Node
            {
                get; set;
            }

        }
        public class AudioNodeWillBeDestroyedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string NodeId
            {
                get; set;
            }

        }
        public class AudioParamCreatedParams
        {
            /// <summary>
            /// </summary>
            public WebAudioDomain.AudioParam Param
            {
                get; set;
            }

        }
        public class AudioParamWillBeDestroyedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string NodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ParamId
            {
                get; set;
            }

        }
        public class NodesConnectedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string SourceId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string DestinationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? SourceOutputIndex
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? DestinationInputIndex
            {
                get; set;
            }

        }
        public class NodesDisconnectedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string SourceId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string DestinationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? SourceOutputIndex
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? DestinationInputIndex
            {
                get; set;
            }

        }
        public class NodeParamConnectedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string SourceId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string DestinationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? SourceOutputIndex
            {
                get; set;
            }

        }
        public class NodeParamDisconnectedParams
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string SourceId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string DestinationId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double? SourceOutputIndex
            {
                get; set;
            }

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "WebAudio.enable";

            }

        }
        public class EnableResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "WebAudio.disable";

            }

        }
        public class DisableResult
        {

        }
        public class GetRealtimeDataParams : IMethodParams<GetRealtimeDataParams, GetRealtimeDataResult>
        {
            public string GetMethod()
            {
                return "WebAudio.getRealtimeData";

            }
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }

        }
        public class GetRealtimeDataResult
        {
            /// <summary>
            /// </summary>
            public WebAudioDomain.ContextRealtimeData RealtimeData
            {
                get; set;
            }

        }
        /// <summary>
        /// Enum of BaseAudioContext types
        /// </summary>
        public enum ContextType
        {
            [EnumValue("realtime")]
            Realtime = 1,
            [EnumValue("offline")]
            Offline = 2,

        }
        /// <summary>
        /// Enum of AudioContextState from the spec
        /// </summary>
        public enum ContextState
        {
            [EnumValue("suspended")]
            Suspended = 1,
            [EnumValue("running")]
            Running = 2,
            [EnumValue("closed")]
            Closed = 3,

        }
        /// <summary>
        /// Enum of AudioNode::ChannelCountMode from the spec
        /// </summary>
        public enum ChannelCountMode
        {
            [EnumValue("clamped-max")]
            ClampedMax = 1,
            [EnumValue("explicit")]
            Explicit = 2,
            [EnumValue("max")]
            Max = 3,

        }
        /// <summary>
        /// Enum of AudioNode::ChannelInterpretation from the spec
        /// </summary>
        public enum ChannelInterpretation
        {
            [EnumValue("discrete")]
            Discrete = 1,
            [EnumValue("speakers")]
            Speakers = 2,

        }
        /// <summary>
        /// Enum of AudioParam::AutomationRate from the spec
        /// </summary>
        public enum AutomationRate
        {
            [EnumValue("a-rate")]
            ARate = 1,
            [EnumValue("k-rate")]
            KRate = 2,

        }
        /// <summary>
        /// Fields in AudioContext that change in real-time.
        /// </summary>
        public class ContextRealtimeData
        {
            /// <summary>
            /// The current context time in second in BaseAudioContext.
            /// </summary>
            public double CurrentTime
            {
                get; set;
            }
            /// <summary>
            /// The time spent on rendering graph divided by render quantum duration,
            /// and multiplied by 100. 100 means the audio renderer reached the full
            /// capacity and glitch may occur.
            /// </summary>
            public double RenderCapacity
            {
                get; set;
            }
            /// <summary>
            /// A running mean of callback interval.
            /// </summary>
            public double CallbackIntervalMean
            {
                get; set;
            }
            /// <summary>
            /// A running variance of callback interval.
            /// </summary>
            public double CallbackIntervalVariance
            {
                get; set;
            }

        }
        /// <summary>
        /// Protocol object for BaseAudioContext
        /// </summary>
        public class BaseAudioContext
        {
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAudioDomain.ContextType ContextType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAudioDomain.ContextState ContextState
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAudioDomain.ContextRealtimeData? RealtimeData
            {
                get; set;
            }
            /// <summary>
            /// Platform-dependent callback buffer size.
            /// </summary>
            public double CallbackBufferSize
            {
                get; set;
            }
            /// <summary>
            /// Number of output channels supported by audio hardware in use.
            /// </summary>
            public double MaxOutputChannelCount
            {
                get; set;
            }
            /// <summary>
            /// Context sample rate.
            /// </summary>
            public double SampleRate
            {
                get; set;
            }

        }
        /// <summary>
        /// Protocol object for AudioListener
        /// </summary>
        public class AudioListener
        {
            /// <summary>
            /// </summary>
            public string ListenerId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }

        }
        /// <summary>
        /// Protocol object for AudioNode
        /// </summary>
        public class AudioNode
        {
            /// <summary>
            /// </summary>
            public string NodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string NodeType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double NumberOfInputs
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double NumberOfOutputs
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double ChannelCount
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAudioDomain.ChannelCountMode ChannelCountMode
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAudioDomain.ChannelInterpretation ChannelInterpretation
            {
                get; set;
            }

        }
        /// <summary>
        /// Protocol object for AudioParam
        /// </summary>
        public class AudioParam
        {
            /// <summary>
            /// </summary>
            public string ParamId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string NodeId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ContextId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string ParamType
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAudioDomain.AutomationRate Rate
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double DefaultValue
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double MinValue
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double MaxValue
            {
                get; set;
            }

        }

    }
    public class WebAuthnDomain : BaseDomain
    {
        public WebAuthnDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "WebAuthn";

            }

        }
        /// <summary>
        /// Enable the WebAuthn domain and start intercepting credential storage and
        /// retrieval with a virtual authenticator.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Disable the WebAuthn domain.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Creates and adds a virtual authenticator.
        /// </summary>
        public async ValueTask<AddVirtualAuthenticatorResult> AddVirtualAuthenticatorAsync(AddVirtualAuthenticatorParams addVirtualAuthenticatorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addVirtualAuthenticatorParams, cancellationToken);

        }
        /// <summary>
        /// Removes the given authenticator.
        /// </summary>
        public async ValueTask<RemoveVirtualAuthenticatorResult> RemoveVirtualAuthenticatorAsync(RemoveVirtualAuthenticatorParams removeVirtualAuthenticatorParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeVirtualAuthenticatorParams, cancellationToken);

        }
        /// <summary>
        /// Adds the credential to the specified authenticator.
        /// </summary>
        public async ValueTask<AddCredentialResult> AddCredentialAsync(AddCredentialParams addCredentialParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addCredentialParams, cancellationToken);

        }
        /// <summary>
        /// Returns a single credential stored in the given virtual authenticator that
        /// matches the credential ID.
        /// </summary>
        public async ValueTask<GetCredentialResult> GetCredentialAsync(GetCredentialParams getCredentialParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCredentialParams, cancellationToken);

        }
        /// <summary>
        /// Returns all the credentials stored in the given virtual authenticator.
        /// </summary>
        public async ValueTask<GetCredentialsResult> GetCredentialsAsync(GetCredentialsParams getCredentialsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getCredentialsParams, cancellationToken);

        }
        /// <summary>
        /// Removes a credential from the authenticator.
        /// </summary>
        public async ValueTask<RemoveCredentialResult> RemoveCredentialAsync(RemoveCredentialParams removeCredentialParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeCredentialParams, cancellationToken);

        }
        /// <summary>
        /// Clears all the credentials from the specified device.
        /// </summary>
        public async ValueTask<ClearCredentialsResult> ClearCredentialsAsync(ClearCredentialsParams clearCredentialsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearCredentialsParams, cancellationToken);

        }
        /// <summary>
        /// Sets whether User Verification succeeds or fails for an authenticator.
        /// The default is true.
        /// </summary>
        public async ValueTask<SetUserVerifiedResult> SetUserVerifiedAsync(SetUserVerifiedParams setUserVerifiedParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setUserVerifiedParams, cancellationToken);

        }
        /// <summary>
        /// Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
        /// The default is true.
        /// </summary>
        public async ValueTask<SetAutomaticPresenceSimulationResult> SetAutomaticPresenceSimulationAsync(SetAutomaticPresenceSimulationParams setAutomaticPresenceSimulationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAutomaticPresenceSimulationParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.enable";

            }
            /// <summary>
            /// Whether to enable the WebAuthn user interface. Enabling the UI is
            /// recommended for debugging and demo purposes, as it is closer to the real
            /// experience. Disabling the UI is recommended for automated testing.
            /// Supported at the embedder's discretion if UI is available.
            /// Defaults to false.
            /// </summary>
            public bool? EnableUI
            {
                get; set;
            }

        }
        public class EnableResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.disable";

            }

        }
        public class DisableResult
        {

        }
        public class AddVirtualAuthenticatorParams : IMethodParams<AddVirtualAuthenticatorParams, AddVirtualAuthenticatorResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.addVirtualAuthenticator";

            }
            /// <summary>
            /// </summary>
            public WebAuthnDomain.VirtualAuthenticatorOptions Options
            {
                get; set;
            }

        }
        public class AddVirtualAuthenticatorResult
        {
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }

        }
        public class RemoveVirtualAuthenticatorParams : IMethodParams<RemoveVirtualAuthenticatorParams, RemoveVirtualAuthenticatorResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.removeVirtualAuthenticator";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }

        }
        public class RemoveVirtualAuthenticatorResult
        {

        }
        public class AddCredentialParams : IMethodParams<AddCredentialParams, AddCredentialResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.addCredential";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAuthnDomain.Credential Credential
            {
                get; set;
            }

        }
        public class AddCredentialResult
        {

        }
        public class GetCredentialParams : IMethodParams<GetCredentialParams, GetCredentialResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.getCredential";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string CredentialId
            {
                get; set;
            }

        }
        public class GetCredentialResult
        {
            /// <summary>
            /// </summary>
            public WebAuthnDomain.Credential Credential
            {
                get; set;
            }

        }
        public class GetCredentialsParams : IMethodParams<GetCredentialsParams, GetCredentialsResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.getCredentials";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }

        }
        public class GetCredentialsResult
        {
            /// <summary>
            /// </summary>
            public WebAuthnDomain.Credential[] Credentials
            {
                get; set;
            }

        }
        public class RemoveCredentialParams : IMethodParams<RemoveCredentialParams, RemoveCredentialResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.removeCredential";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string CredentialId
            {
                get; set;
            }

        }
        public class RemoveCredentialResult
        {

        }
        public class ClearCredentialsParams : IMethodParams<ClearCredentialsParams, ClearCredentialsResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.clearCredentials";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }

        }
        public class ClearCredentialsResult
        {

        }
        public class SetUserVerifiedParams : IMethodParams<SetUserVerifiedParams, SetUserVerifiedResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.setUserVerified";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsUserVerified
            {
                get; set;
            }

        }
        public class SetUserVerifiedResult
        {

        }
        public class SetAutomaticPresenceSimulationParams : IMethodParams<SetAutomaticPresenceSimulationParams, SetAutomaticPresenceSimulationResult>
        {
            public string GetMethod()
            {
                return "WebAuthn.setAutomaticPresenceSimulation";

            }
            /// <summary>
            /// </summary>
            public string AuthenticatorId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetAutomaticPresenceSimulationResult
        {

        }
        /// <summary>
        /// </summary>
        public enum AuthenticatorProtocol
        {
            [EnumValue("u2f")]
            U2f = 1,
            [EnumValue("ctap2")]
            Ctap2 = 2,

        }
        /// <summary>
        /// </summary>
        public enum Ctap2Version
        {
            [EnumValue("ctap2_0")]
            Ctap2_0 = 1,
            [EnumValue("ctap2_1")]
            Ctap2_1 = 2,

        }
        /// <summary>
        /// </summary>
        public enum AuthenticatorTransport
        {
            [EnumValue("usb")]
            Usb = 1,
            [EnumValue("nfc")]
            Nfc = 2,
            [EnumValue("ble")]
            Ble = 3,
            [EnumValue("cable")]
            Cable = 4,
            [EnumValue("internal")]
            Internal = 5,

        }
        /// <summary>
        /// </summary>
        public class VirtualAuthenticatorOptions
        {
            /// <summary>
            /// </summary>
            public WebAuthnDomain.AuthenticatorProtocol Protocol
            {
                get; set;
            }
            /// <summary>
            /// Defaults to ctap2_0. Ignored if |protocol| == u2f.
            /// </summary>
            public WebAuthnDomain.Ctap2Version? Ctap2Version
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public WebAuthnDomain.AuthenticatorTransport Transport
            {
                get; set;
            }
            /// <summary>
            /// Defaults to false.
            /// </summary>
            public bool? HasResidentKey
            {
                get; set;
            }
            /// <summary>
            /// Defaults to false.
            /// </summary>
            public bool? HasUserVerification
            {
                get; set;
            }
            /// <summary>
            /// If set to true, the authenticator will support the largeBlob extension.
            /// https://w3c.github.io/webauthn#largeBlob
            /// Defaults to false.
            /// </summary>
            public bool? HasLargeBlob
            {
                get; set;
            }
            /// <summary>
            /// If set to true, the authenticator will support the credBlob extension.
            /// https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension
            /// Defaults to false.
            /// </summary>
            public bool? HasCredBlob
            {
                get; set;
            }
            /// <summary>
            /// If set to true, the authenticator will support the minPinLength extension.
            /// https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
            /// Defaults to false.
            /// </summary>
            public bool? HasMinPinLength
            {
                get; set;
            }
            /// <summary>
            /// If set to true, tests of user presence will succeed immediately.
            /// Otherwise, they will not be resolved. Defaults to true.
            /// </summary>
            public bool? AutomaticPresenceSimulation
            {
                get; set;
            }
            /// <summary>
            /// Sets whether User Verification succeeds or fails for an authenticator.
            /// Defaults to false.
            /// </summary>
            public bool? IsUserVerified
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class Credential
        {
            /// <summary>
            /// </summary>
            public string CredentialId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool IsResidentCredential
            {
                get; set;
            }
            /// <summary>
            /// Relying Party ID the credential is scoped to. Must be set when adding a
            /// credential.
            /// </summary>
            public string? RpId
            {
                get; set;
            }
            /// <summary>
            /// The ECDSA P-256 private key in PKCS#8 format. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string PrivateKey
            {
                get; set;
            }
            /// <summary>
            /// An opaque byte sequence with a maximum size of 64 bytes mapping the
            /// credential to a specific user. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? UserHandle
            {
                get; set;
            }
            /// <summary>
            /// Signature counter. This is incremented by one for each successful
            /// assertion.
            /// See https://w3c.github.io/webauthn/#signature-counter
            /// </summary>
            public int SignCount
            {
                get; set;
            }
            /// <summary>
            /// The large blob associated with the credential.
            /// See https://w3c.github.io/webauthn/#sctn-large-blob-extension (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? LargeBlob
            {
                get; set;
            }

        }

    }
    public class MediaDomain : BaseDomain
    {
        public MediaDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Media";

            }

        }
        /// <summary>
        /// This can be called multiple times, and can be used to set / override /
        /// remove player properties. A null propValue indicates removal.
        /// </summary>
        public event EventHandler<PlayerPropertiesChangedParams>? PlayerPropertiesChanged;
        /// <summary>
        /// Send events as a list, allowing them to be batched on the browser for less
        /// congestion. If batched, events must ALWAYS be in chronological order.
        /// </summary>
        public event EventHandler<PlayerEventsAddedParams>? PlayerEventsAdded;
        /// <summary>
        /// Send a list of any messages that need to be delivered.
        /// </summary>
        public event EventHandler<PlayerMessagesLoggedParams>? PlayerMessagesLogged;
        /// <summary>
        /// Send a list of any errors that need to be delivered.
        /// </summary>
        public event EventHandler<PlayerErrorsRaisedParams>? PlayerErrorsRaised;
        /// <summary>
        /// Called whenever a player is created, or when a new agent joins and receives
        /// a list of active players. If an agent is restored, it will receive the full
        /// list of player ids and all events again.
        /// </summary>
        public event EventHandler<PlayersCreatedParams>? PlayersCreated;
        /// <summary>
        /// Enables the Media domain
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Disables the Media domain.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "playerPropertiesChanged": RaiseEvent(PlayerPropertiesChanged, messageBytes);
                    break;
                case "playerEventsAdded": RaiseEvent(PlayerEventsAdded, messageBytes);
                    break;
                case "playerMessagesLogged": RaiseEvent(PlayerMessagesLogged, messageBytes);
                    break;
                case "playerErrorsRaised": RaiseEvent(PlayerErrorsRaised, messageBytes);
                    break;
                case "playersCreated": RaiseEvent(PlayersCreated, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class PlayerPropertiesChangedParams
        {
            /// <summary>
            /// </summary>
            public string PlayerId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public MediaDomain.PlayerProperty[] Properties
            {
                get; set;
            }

        }
        public class PlayerEventsAddedParams
        {
            /// <summary>
            /// </summary>
            public string PlayerId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public MediaDomain.PlayerEvent[] Events
            {
                get; set;
            }

        }
        public class PlayerMessagesLoggedParams
        {
            /// <summary>
            /// </summary>
            public string PlayerId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public MediaDomain.PlayerMessage[] Messages
            {
                get; set;
            }

        }
        public class PlayerErrorsRaisedParams
        {
            /// <summary>
            /// </summary>
            public string PlayerId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public MediaDomain.PlayerError[] Errors
            {
                get; set;
            }

        }
        public class PlayersCreatedParams
        {
            /// <summary>
            /// </summary>
            public string[] Players
            {
                get; set;
            }

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Media.enable";

            }

        }
        public class EnableResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Media.disable";

            }

        }
        public class DisableResult
        {

        }
        /// <summary>
        /// Have one type per entry in MediaLogRecord::Type
        /// Corresponds to kMessage
        /// </summary>
        public class PlayerMessage
        {
            /// <summary>
            /// Keep in sync with MediaLogMessageLevel
            /// We are currently keeping the message level 'error' separate from the
            /// PlayerError type because right now they represent different things,
            /// this one being a DVLOG(ERROR) style log message that gets printed
            /// based on what log level is selected in the UI, and the other is a
            /// representation of a media::PipelineStatus object. Soon however we're
            /// going to be moving away from using PipelineStatus for errors and
            /// introducing a new error type which should hopefully let us integrate
            /// the error log level into the PlayerError type.
            /// </summary>
            /// <value>
            /// error,warning,info,debug
            /// </value>
            public string Level
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Message
            {
                get; set;
            }

        }
        /// <summary>
        /// Corresponds to kMediaPropertyChange
        /// </summary>
        public class PlayerProperty
        {
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Corresponds to kMediaEventTriggered
        /// </summary>
        public class PlayerEvent
        {
            /// <summary>
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Represents logged source line numbers reported in an error.
        /// NOTE: file and line are from chromium c++ implementation code, not js.
        /// </summary>
        public class PlayerErrorSourceLocation
        {
            /// <summary>
            /// </summary>
            public string File
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int Line
            {
                get; set;
            }

        }
        /// <summary>
        /// Corresponds to kMediaError
        /// </summary>
        public class PlayerError
        {
            /// <summary>
            /// </summary>
            public string ErrorType
            {
                get; set;
            }
            /// <summary>
            /// Code is the numeric enum entry for a specific set of error codes, such
            /// as PipelineStatusCodes in media/base/pipeline_status.h
            /// </summary>
            public int Code
            {
                get; set;
            }
            /// <summary>
            /// A trace of where this error was caused / where it passed through.
            /// </summary>
            public MediaDomain.PlayerErrorSourceLocation[] Stack
            {
                get; set;
            }
            /// <summary>
            /// Errors potentially have a root cause error, ie, a DecoderError might be
            /// caused by an WindowsError
            /// </summary>
            public MediaDomain.PlayerError[] Cause
            {
                get; set;
            }
            /// <summary>
            /// Extra data attached to an error, such as an HRESULT, Video Codec, etc.
            /// </summary>
            public object Data
            {
                get; set;
            }

        }

    }
    public class ConsoleDomain : BaseDomain
    {
        public ConsoleDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Console";

            }

        }
        /// <summary>
        /// Issued when new console message is added.
        /// </summary>
        public event EventHandler<MessageAddedParams>? MessageAdded;
        /// <summary>
        /// Does nothing.
        /// </summary>
        public async ValueTask<ClearMessagesResult> ClearMessagesAsync(ClearMessagesParams clearMessagesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(clearMessagesParams, cancellationToken);

        }
        /// <summary>
        /// Disables console domain, prevents further console messages from being reported to the client.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables console domain, sends the messages collected so far to the client by means of the
        /// `messageAdded` notification.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "messageAdded": RaiseEvent(MessageAdded, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class MessageAddedParams
        {
            /// <summary>
            /// Console message that has been added.
            /// </summary>
            public ConsoleDomain.ConsoleMessage Message
            {
                get; set;
            }

        }
        public class ClearMessagesParams : IMethodParams<ClearMessagesParams, ClearMessagesResult>
        {
            public string GetMethod()
            {
                return "Console.clearMessages";

            }

        }
        public class ClearMessagesResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Console.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Console.enable";

            }

        }
        public class EnableResult
        {

        }
        /// <summary>
        /// Console message.
        /// </summary>
        public class ConsoleMessage
        {
            /// <summary>
            /// Message source.
            /// </summary>
            /// <value>
            /// xml,javascript,network,console-api,storage,appcache,rendering,security,other,deprecation,worker
            /// </value>
            public string Source
            {
                get; set;
            }
            /// <summary>
            /// Message severity.
            /// </summary>
            /// <value>
            /// log,warning,error,debug,info
            /// </value>
            public string Level
            {
                get; set;
            }
            /// <summary>
            /// Message text.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// URL of the message origin.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// Line number in the resource that generated this message (1-based).
            /// </summary>
            public int? Line
            {
                get; set;
            }
            /// <summary>
            /// Column number in the resource that generated this message (1-based).
            /// </summary>
            public int? Column
            {
                get; set;
            }

        }

    }
    public class DebuggerDomain : BaseDomain
    {
        public DebuggerDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Debugger";

            }

        }
        /// <summary>
        /// Fired when breakpoint is resolved to an actual script and location.
        /// </summary>
        public event EventHandler<BreakpointResolvedParams>? BreakpointResolved;
        /// <summary>
        /// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
        /// </summary>
        public event EventHandler<PausedParams>? Paused;
        /// <summary>
        /// Fired when the virtual machine resumed execution.
        /// </summary>
        public event EventHandler<ResumedParams>? Resumed;
        /// <summary>
        /// Fired when virtual machine fails to parse the script.
        /// </summary>
        public event EventHandler<ScriptFailedToParseParams>? ScriptFailedToParse;
        /// <summary>
        /// Fired when virtual machine parses script. This event is also fired for all known and uncollected
        /// scripts upon enabling debugger.
        /// </summary>
        public event EventHandler<ScriptParsedParams>? ScriptParsed;
        /// <summary>
        /// Continues execution until specific location is reached.
        /// </summary>
        public async ValueTask<ContinueToLocationResult> ContinueToLocationAsync(ContinueToLocationParams continueToLocationParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(continueToLocationParams, cancellationToken);

        }
        /// <summary>
        /// Disables debugger for given page.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Enables debugger for the given page. Clients should not assume that the debugging has been
        /// enabled until the result for this command is received.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Evaluates expression on a given call frame.
        /// </summary>
        public async ValueTask<EvaluateOnCallFrameResult> EvaluateOnCallFrameAsync(EvaluateOnCallFrameParams evaluateOnCallFrameParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(evaluateOnCallFrameParams, cancellationToken);

        }
        /// <summary>
        /// Returns possible locations for breakpoint. scriptId in start and end range locations should be
        /// the same.
        /// </summary>
        public async ValueTask<GetPossibleBreakpointsResult> GetPossibleBreakpointsAsync(GetPossibleBreakpointsParams getPossibleBreakpointsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getPossibleBreakpointsParams, cancellationToken);

        }
        /// <summary>
        /// Returns source for the script with given id.
        /// </summary>
        public async ValueTask<GetScriptSourceResult> GetScriptSourceAsync(GetScriptSourceParams getScriptSourceParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getScriptSourceParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<DisassembleWasmModuleResult> DisassembleWasmModuleAsync(DisassembleWasmModuleParams disassembleWasmModuleParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disassembleWasmModuleParams, cancellationToken);

        }
        /// <summary>
        /// Disassemble the next chunk of lines for the module corresponding to the
        /// stream. If disassembly is complete, this API will invalidate the streamId
        /// and return an empty chunk. Any subsequent calls for the now invalid stream
        /// will return errors.
        /// </summary>
        [Experimental]
        public async ValueTask<NextWasmDisassemblyChunkResult> NextWasmDisassemblyChunkAsync(NextWasmDisassemblyChunkParams nextWasmDisassemblyChunkParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(nextWasmDisassemblyChunkParams, cancellationToken);

        }
        /// <summary>
        /// This command is deprecated. Use getScriptSource instead.
        /// </summary>
        [Obsolete]
        public async ValueTask<GetWasmBytecodeResult> GetWasmBytecodeAsync(GetWasmBytecodeParams getWasmBytecodeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getWasmBytecodeParams, cancellationToken);

        }
        /// <summary>
        /// Returns stack trace with given `stackTraceId`.
        /// </summary>
        [Experimental]
        public async ValueTask<GetStackTraceResult> GetStackTraceAsync(GetStackTraceParams getStackTraceParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getStackTraceParams, cancellationToken);

        }
        /// <summary>
        /// Stops on the next JavaScript statement.
        /// </summary>
        public async ValueTask<PauseResult> PauseAsync(PauseParams pauseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(pauseParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        [Obsolete]
        public async ValueTask<PauseOnAsyncCallResult> PauseOnAsyncCallAsync(PauseOnAsyncCallParams pauseOnAsyncCallParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(pauseOnAsyncCallParams, cancellationToken);

        }
        /// <summary>
        /// Removes JavaScript breakpoint.
        /// </summary>
        public async ValueTask<RemoveBreakpointResult> RemoveBreakpointAsync(RemoveBreakpointParams removeBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Restarts particular call frame from the beginning. The old, deprecated
        /// behavior of `restartFrame` is to stay paused and allow further CDP commands
        /// after a restart was scheduled. This can cause problems with restarting, so
        /// we now continue execution immediatly after it has been scheduled until we
        /// reach the beginning of the restarted frame.
        /// 
        /// To stay back-wards compatible, `restartFrame` now expects a `mode`
        /// parameter to be present. If the `mode` parameter is missing, `restartFrame`
        /// errors out.
        /// 
        /// The various return values are deprecated and `callFrames` is always empty.
        /// Use the call frames from the `Debugger#paused` events instead, that fires
        /// once V8 pauses at the beginning of the restarted function.
        /// </summary>
        public async ValueTask<RestartFrameResult> RestartFrameAsync(RestartFrameParams restartFrameParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(restartFrameParams, cancellationToken);

        }
        /// <summary>
        /// Resumes JavaScript execution.
        /// </summary>
        public async ValueTask<ResumeResult> ResumeAsync(ResumeParams resumeParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(resumeParams, cancellationToken);

        }
        /// <summary>
        /// Searches for given string in script content.
        /// </summary>
        public async ValueTask<SearchInContentResult> SearchInContentAsync(SearchInContentParams searchInContentParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(searchInContentParams, cancellationToken);

        }
        /// <summary>
        /// Enables or disables async call stacks tracking.
        /// </summary>
        public async ValueTask<SetAsyncCallStackDepthResult> SetAsyncCallStackDepthAsync(SetAsyncCallStackDepthParams setAsyncCallStackDepthParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAsyncCallStackDepthParams, cancellationToken);

        }
        /// <summary>
        /// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
        /// scripts with url matching one of the patterns. VM will try to leave blackboxed script by
        /// performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBlackboxPatternsResult> SetBlackboxPatternsAsync(SetBlackboxPatternsParams setBlackboxPatternsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBlackboxPatternsParams, cancellationToken);

        }
        /// <summary>
        /// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
        /// scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
        /// Positions array contains positions where blackbox state is changed. First interval isn't
        /// blackboxed. Array should be sorted.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBlackboxedRangesResult> SetBlackboxedRangesAsync(SetBlackboxedRangesParams setBlackboxedRangesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBlackboxedRangesParams, cancellationToken);

        }
        /// <summary>
        /// Sets JavaScript breakpoint at a given location.
        /// </summary>
        public async ValueTask<SetBreakpointResult> SetBreakpointAsync(SetBreakpointParams setBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Sets instrumentation breakpoint.
        /// </summary>
        public async ValueTask<SetInstrumentationBreakpointResult> SetInstrumentationBreakpointAsync(SetInstrumentationBreakpointParams setInstrumentationBreakpointParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setInstrumentationBreakpointParams, cancellationToken);

        }
        /// <summary>
        /// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
        /// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
        /// `locations` property. Further matching script parsing will result in subsequent
        /// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
        /// </summary>
        public async ValueTask<SetBreakpointByUrlResult> SetBreakpointByUrlAsync(SetBreakpointByUrlParams setBreakpointByUrlParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBreakpointByUrlParams, cancellationToken);

        }
        /// <summary>
        /// Sets JavaScript breakpoint before each call to the given function.
        /// If another function was created from the same source as a given one,
        /// calling it will also trigger the breakpoint.
        /// </summary>
        [Experimental]
        public async ValueTask<SetBreakpointOnFunctionCallResult> SetBreakpointOnFunctionCallAsync(SetBreakpointOnFunctionCallParams setBreakpointOnFunctionCallParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBreakpointOnFunctionCallParams, cancellationToken);

        }
        /// <summary>
        /// Activates / deactivates all breakpoints on the page.
        /// </summary>
        public async ValueTask<SetBreakpointsActiveResult> SetBreakpointsActiveAsync(SetBreakpointsActiveParams setBreakpointsActiveParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setBreakpointsActiveParams, cancellationToken);

        }
        /// <summary>
        /// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
        /// no exceptions. Initial pause on exceptions state is `none`.
        /// </summary>
        public async ValueTask<SetPauseOnExceptionsResult> SetPauseOnExceptionsAsync(SetPauseOnExceptionsParams setPauseOnExceptionsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setPauseOnExceptionsParams, cancellationToken);

        }
        /// <summary>
        /// Changes return value in top frame. Available only at return break position.
        /// </summary>
        [Experimental]
        public async ValueTask<SetReturnValueResult> SetReturnValueAsync(SetReturnValueParams setReturnValueParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setReturnValueParams, cancellationToken);

        }
        /// <summary>
        /// Edits JavaScript source live.
        /// 
        /// In general, functions that are currently on the stack can not be edited with
        /// a single exception: If the edited function is the top-most stack frame and
        /// that is the only activation of that function on the stack. In this case
        /// the live edit will be successful and a `Debugger.restartFrame` for the
        /// top-most function is automatically triggered.
        /// </summary>
        public async ValueTask<SetScriptSourceResult> SetScriptSourceAsync(SetScriptSourceParams setScriptSourceParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setScriptSourceParams, cancellationToken);

        }
        /// <summary>
        /// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
        /// </summary>
        public async ValueTask<SetSkipAllPausesResult> SetSkipAllPausesAsync(SetSkipAllPausesParams setSkipAllPausesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setSkipAllPausesParams, cancellationToken);

        }
        /// <summary>
        /// Changes value of variable in a callframe. Object-based scopes are not supported and must be
        /// mutated manually.
        /// </summary>
        public async ValueTask<SetVariableValueResult> SetVariableValueAsync(SetVariableValueParams setVariableValueParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setVariableValueParams, cancellationToken);

        }
        /// <summary>
        /// Steps into the function call.
        /// </summary>
        public async ValueTask<StepIntoResult> StepIntoAsync(StepIntoParams stepIntoParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stepIntoParams, cancellationToken);

        }
        /// <summary>
        /// Steps out of the function call.
        /// </summary>
        public async ValueTask<StepOutResult> StepOutAsync(StepOutParams stepOutParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stepOutParams, cancellationToken);

        }
        /// <summary>
        /// Steps over the statement.
        /// </summary>
        public async ValueTask<StepOverResult> StepOverAsync(StepOverParams stepOverParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stepOverParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "breakpointResolved": RaiseEvent(BreakpointResolved, messageBytes);
                    break;
                case "paused": RaiseEvent(Paused, messageBytes);
                    break;
                case "resumed": RaiseEvent(Resumed, messageBytes);
                    break;
                case "scriptFailedToParse": RaiseEvent(ScriptFailedToParse, messageBytes);
                    break;
                case "scriptParsed": RaiseEvent(ScriptParsed, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class BreakpointResolvedParams
        {
            /// <summary>
            /// Breakpoint unique identifier.
            /// </summary>
            public string BreakpointId
            {
                get; set;
            }
            /// <summary>
            /// Actual breakpoint location.
            /// </summary>
            public DebuggerDomain.Location Location
            {
                get; set;
            }

        }
        public class PausedParams
        {
            /// <summary>
            /// Call stack the virtual machine stopped on.
            /// </summary>
            public DebuggerDomain.CallFrame[] CallFrames
            {
                get; set;
            }
            /// <summary>
            /// Pause reason.
            /// </summary>
            /// <value>
            /// ambiguous,assert,CSPViolation,debugCommand,DOM,EventListener,exception,instrumentation,OOM,other,promiseRejection,XHR
            /// </value>
            public string Reason
            {
                get; set;
            }
            /// <summary>
            /// Object containing break-specific auxiliary properties.
            /// </summary>
            public object? Data
            {
                get; set;
            }
            /// <summary>
            /// Hit breakpoints IDs
            /// </summary>
            public string[]? HitBreakpoints
            {
                get; set;
            }
            /// <summary>
            /// Async stack trace, if any.
            /// </summary>
            public RuntimeDomain.StackTrace? AsyncStackTrace
            {
                get; set;
            }
            /// <summary>
            /// Async stack trace, if any.
            /// </summary>
            [Experimental]
            public RuntimeDomain.StackTraceId? AsyncStackTraceId
            {
                get; set;
            }
            /// <summary>
            /// Never present, will be removed.
            /// </summary>
            [Experimental]
            [Obsolete]
            public RuntimeDomain.StackTraceId? AsyncCallStackTraceId
            {
                get; set;
            }

        }
        public class ResumedParams
        {

        }
        public class ScriptFailedToParseParams
        {
            /// <summary>
            /// Identifier of the script parsed.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// URL or name of the script parsed (if any).
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Line offset of the script within the resource with given URL (for script tags).
            /// </summary>
            public int StartLine
            {
                get; set;
            }
            /// <summary>
            /// Column offset of the script within the resource with given URL.
            /// </summary>
            public int StartColumn
            {
                get; set;
            }
            /// <summary>
            /// Last line of the script.
            /// </summary>
            public int EndLine
            {
                get; set;
            }
            /// <summary>
            /// Length of the last line of the script.
            /// </summary>
            public int EndColumn
            {
                get; set;
            }
            /// <summary>
            /// Specifies script creation context.
            /// </summary>
            public int ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// Content hash of the script, SHA-256.
            /// </summary>
            public string Hash
            {
                get; set;
            }
            /// <summary>
            /// Embedder-specific auxiliary data.
            /// </summary>
            public object? ExecutionContextAuxData
            {
                get; set;
            }
            /// <summary>
            /// URL of source map associated with script (if any).
            /// </summary>
            public string? SourceMapURL
            {
                get; set;
            }
            /// <summary>
            /// True, if this script has sourceURL.
            /// </summary>
            public bool? HasSourceURL
            {
                get; set;
            }
            /// <summary>
            /// True, if this script is ES6 module.
            /// </summary>
            public bool? IsModule
            {
                get; set;
            }
            /// <summary>
            /// This script length.
            /// </summary>
            public int? Length
            {
                get; set;
            }
            /// <summary>
            /// JavaScript top stack frame of where the script parsed event was triggered if available.
            /// </summary>
            [Experimental]
            public RuntimeDomain.StackTrace? StackTrace
            {
                get; set;
            }
            /// <summary>
            /// If the scriptLanguage is WebAssembly, the code section offset in the module.
            /// </summary>
            [Experimental]
            public int? CodeOffset
            {
                get; set;
            }
            /// <summary>
            /// The language of the script.
            /// </summary>
            [Experimental]
            public DebuggerDomain.ScriptLanguage? ScriptLanguage
            {
                get; set;
            }
            /// <summary>
            /// The name the embedder supplied for this script.
            /// </summary>
            [Experimental]
            public string? EmbedderName
            {
                get; set;
            }

        }
        public class ScriptParsedParams
        {
            /// <summary>
            /// Identifier of the script parsed.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// URL or name of the script parsed (if any).
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Line offset of the script within the resource with given URL (for script tags).
            /// </summary>
            public int StartLine
            {
                get; set;
            }
            /// <summary>
            /// Column offset of the script within the resource with given URL.
            /// </summary>
            public int StartColumn
            {
                get; set;
            }
            /// <summary>
            /// Last line of the script.
            /// </summary>
            public int EndLine
            {
                get; set;
            }
            /// <summary>
            /// Length of the last line of the script.
            /// </summary>
            public int EndColumn
            {
                get; set;
            }
            /// <summary>
            /// Specifies script creation context.
            /// </summary>
            public int ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// Content hash of the script, SHA-256.
            /// </summary>
            public string Hash
            {
                get; set;
            }
            /// <summary>
            /// Embedder-specific auxiliary data.
            /// </summary>
            public object? ExecutionContextAuxData
            {
                get; set;
            }
            /// <summary>
            /// True, if this script is generated as a result of the live edit operation.
            /// </summary>
            [Experimental]
            public bool? IsLiveEdit
            {
                get; set;
            }
            /// <summary>
            /// URL of source map associated with script (if any).
            /// </summary>
            public string? SourceMapURL
            {
                get; set;
            }
            /// <summary>
            /// True, if this script has sourceURL.
            /// </summary>
            public bool? HasSourceURL
            {
                get; set;
            }
            /// <summary>
            /// True, if this script is ES6 module.
            /// </summary>
            public bool? IsModule
            {
                get; set;
            }
            /// <summary>
            /// This script length.
            /// </summary>
            public int? Length
            {
                get; set;
            }
            /// <summary>
            /// JavaScript top stack frame of where the script parsed event was triggered if available.
            /// </summary>
            [Experimental]
            public RuntimeDomain.StackTrace? StackTrace
            {
                get; set;
            }
            /// <summary>
            /// If the scriptLanguage is WebAssembly, the code section offset in the module.
            /// </summary>
            [Experimental]
            public int? CodeOffset
            {
                get; set;
            }
            /// <summary>
            /// The language of the script.
            /// </summary>
            [Experimental]
            public DebuggerDomain.ScriptLanguage? ScriptLanguage
            {
                get; set;
            }
            /// <summary>
            /// If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
            /// </summary>
            [Experimental]
            public DebuggerDomain.DebugSymbols? DebugSymbols
            {
                get; set;
            }
            /// <summary>
            /// The name the embedder supplied for this script.
            /// </summary>
            [Experimental]
            public string? EmbedderName
            {
                get; set;
            }

        }
        public class ContinueToLocationParams : IMethodParams<ContinueToLocationParams, ContinueToLocationResult>
        {
            public string GetMethod()
            {
                return "Debugger.continueToLocation";

            }
            /// <summary>
            /// Location to continue to.
            /// </summary>
            public DebuggerDomain.Location Location
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            /// <value>
            /// any,current
            /// </value>
            public string? TargetCallFrames
            {
                get; set;
            }

        }
        public class ContinueToLocationResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Debugger.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Debugger.enable";

            }
            /// <summary>
            /// The maximum size in bytes of collected scripts (not referenced by other heap objects)
            /// the debugger can hold. Puts no limit if parameter is omitted.
            /// </summary>
            [Experimental]
            public double? MaxScriptsCacheSize
            {
                get; set;
            }

        }
        public class EnableResult
        {
            /// <summary>
            /// Unique identifier of the debugger.
            /// </summary>
            [Experimental]
            public string DebuggerId
            {
                get; set;
            }

        }
        public class EvaluateOnCallFrameParams : IMethodParams<EvaluateOnCallFrameParams, EvaluateOnCallFrameResult>
        {
            public string GetMethod()
            {
                return "Debugger.evaluateOnCallFrame";

            }
            /// <summary>
            /// Call frame identifier to evaluate on.
            /// </summary>
            public string CallFrameId
            {
                get; set;
            }
            /// <summary>
            /// Expression to evaluate.
            /// </summary>
            public string Expression
            {
                get; set;
            }
            /// <summary>
            /// String object group name to put result into (allows rapid releasing resulting object handles
            /// using `releaseObjectGroup`).
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }
            /// <summary>
            /// Specifies whether command line API should be available to the evaluated expression, defaults
            /// to false.
            /// </summary>
            public bool? IncludeCommandLineAPI
            {
                get; set;
            }
            /// <summary>
            /// In silent mode exceptions thrown during evaluation are not reported and do not pause
            /// execution. Overrides `setPauseOnException` state.
            /// </summary>
            public bool? Silent
            {
                get; set;
            }
            /// <summary>
            /// Whether the result is expected to be a JSON object that should be sent by value.
            /// </summary>
            public bool? ReturnByValue
            {
                get; set;
            }
            /// <summary>
            /// Whether preview should be generated for the result.
            /// </summary>
            [Experimental]
            public bool? GeneratePreview
            {
                get; set;
            }
            /// <summary>
            /// Whether to throw an exception if side effect cannot be ruled out during evaluation.
            /// </summary>
            public bool? ThrowOnSideEffect
            {
                get; set;
            }
            /// <summary>
            /// Terminate execution after timing out (number of milliseconds).
            /// </summary>
            [Experimental]
            public double? Timeout
            {
                get; set;
            }

        }
        public class EvaluateOnCallFrameResult
        {
            /// <summary>
            /// Object wrapper for the evaluation result.
            /// </summary>
            public RuntimeDomain.RemoteObject Result
            {
                get; set;
            }
            /// <summary>
            /// Exception details.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class GetPossibleBreakpointsParams : IMethodParams<GetPossibleBreakpointsParams, GetPossibleBreakpointsResult>
        {
            public string GetMethod()
            {
                return "Debugger.getPossibleBreakpoints";

            }
            /// <summary>
            /// Start of range to search possible breakpoint locations in.
            /// </summary>
            public DebuggerDomain.Location Start
            {
                get; set;
            }
            /// <summary>
            /// End of range to search possible breakpoint locations in (excluding). When not specified, end
            /// of scripts is used as end of range.
            /// </summary>
            public DebuggerDomain.Location? End
            {
                get; set;
            }
            /// <summary>
            /// Only consider locations which are in the same (non-nested) function as start.
            /// </summary>
            public bool? RestrictToFunction
            {
                get; set;
            }

        }
        public class GetPossibleBreakpointsResult
        {
            /// <summary>
            /// List of the possible breakpoint locations.
            /// </summary>
            public DebuggerDomain.BreakLocation[] Locations
            {
                get; set;
            }

        }
        public class GetScriptSourceParams : IMethodParams<GetScriptSourceParams, GetScriptSourceResult>
        {
            public string GetMethod()
            {
                return "Debugger.getScriptSource";

            }
            /// <summary>
            /// Id of the script to get source for.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }

        }
        public class GetScriptSourceResult
        {
            /// <summary>
            /// Script source (empty in case of Wasm bytecode).
            /// </summary>
            public string ScriptSource
            {
                get; set;
            }
            /// <summary>
            /// Wasm bytecode. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string? Bytecode
            {
                get; set;
            }

        }
        public class DisassembleWasmModuleParams : IMethodParams<DisassembleWasmModuleParams, DisassembleWasmModuleResult>
        {
            public string GetMethod()
            {
                return "Debugger.disassembleWasmModule";

            }
            /// <summary>
            /// Id of the script to disassemble
            /// </summary>
            public string ScriptId
            {
                get; set;
            }

        }
        public class DisassembleWasmModuleResult
        {
            /// <summary>
            /// For large modules, return a stream from which additional chunks of
            /// disassembly can be read successively.
            /// </summary>
            public string? StreamId
            {
                get; set;
            }
            /// <summary>
            /// The total number of lines in the disassembly text.
            /// </summary>
            public int TotalNumberOfLines
            {
                get; set;
            }
            /// <summary>
            /// The offsets of all function bodies, in the format [start1, end1,
            /// start2, end2, ...] where all ends are exclusive.
            /// </summary>
            public int[] FunctionBodyOffsets
            {
                get; set;
            }
            /// <summary>
            /// The first chunk of disassembly.
            /// </summary>
            public DebuggerDomain.WasmDisassemblyChunk Chunk
            {
                get; set;
            }

        }
        public class NextWasmDisassemblyChunkParams : IMethodParams<NextWasmDisassemblyChunkParams, NextWasmDisassemblyChunkResult>
        {
            public string GetMethod()
            {
                return "Debugger.nextWasmDisassemblyChunk";

            }
            /// <summary>
            /// </summary>
            public string StreamId
            {
                get; set;
            }

        }
        public class NextWasmDisassemblyChunkResult
        {
            /// <summary>
            /// The next chunk of disassembly.
            /// </summary>
            public DebuggerDomain.WasmDisassemblyChunk Chunk
            {
                get; set;
            }

        }
        public class GetWasmBytecodeParams : IMethodParams<GetWasmBytecodeParams, GetWasmBytecodeResult>
        {
            public string GetMethod()
            {
                return "Debugger.getWasmBytecode";

            }
            /// <summary>
            /// Id of the Wasm script to get source for.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }

        }
        public class GetWasmBytecodeResult
        {
            /// <summary>
            /// Script source. (Encoded as a base64 string when passed over JSON)
            /// </summary>
            public string Bytecode
            {
                get; set;
            }

        }
        public class GetStackTraceParams : IMethodParams<GetStackTraceParams, GetStackTraceResult>
        {
            public string GetMethod()
            {
                return "Debugger.getStackTrace";

            }
            /// <summary>
            /// </summary>
            public RuntimeDomain.StackTraceId StackTraceId
            {
                get; set;
            }

        }
        public class GetStackTraceResult
        {
            /// <summary>
            /// </summary>
            public RuntimeDomain.StackTrace StackTrace
            {
                get; set;
            }

        }
        public class PauseParams : IMethodParams<PauseParams, PauseResult>
        {
            public string GetMethod()
            {
                return "Debugger.pause";

            }

        }
        public class PauseResult
        {

        }
        public class PauseOnAsyncCallParams : IMethodParams<PauseOnAsyncCallParams, PauseOnAsyncCallResult>
        {
            public string GetMethod()
            {
                return "Debugger.pauseOnAsyncCall";

            }
            /// <summary>
            /// Debugger will pause when async call with given stack trace is started.
            /// </summary>
            public RuntimeDomain.StackTraceId ParentStackTraceId
            {
                get; set;
            }

        }
        public class PauseOnAsyncCallResult
        {

        }
        public class RemoveBreakpointParams : IMethodParams<RemoveBreakpointParams, RemoveBreakpointResult>
        {
            public string GetMethod()
            {
                return "Debugger.removeBreakpoint";

            }
            /// <summary>
            /// </summary>
            public string BreakpointId
            {
                get; set;
            }

        }
        public class RemoveBreakpointResult
        {

        }
        public class RestartFrameParams : IMethodParams<RestartFrameParams, RestartFrameResult>
        {
            public string GetMethod()
            {
                return "Debugger.restartFrame";

            }
            /// <summary>
            /// Call frame identifier to evaluate on.
            /// </summary>
            public string CallFrameId
            {
                get; set;
            }
            /// <summary>
            /// The `mode` parameter must be present and set to 'StepInto', otherwise
            /// `restartFrame` will error out.
            /// </summary>
            /// <value>
            /// StepInto
            /// </value>
            [Experimental]
            public string? Mode
            {
                get; set;
            }

        }
        public class RestartFrameResult
        {
            /// <summary>
            /// New stack trace.
            /// </summary>
            [Obsolete]
            public DebuggerDomain.CallFrame[] CallFrames
            {
                get; set;
            }
            /// <summary>
            /// Async stack trace, if any.
            /// </summary>
            [Obsolete]
            public RuntimeDomain.StackTrace? AsyncStackTrace
            {
                get; set;
            }
            /// <summary>
            /// Async stack trace, if any.
            /// </summary>
            [Obsolete]
            public RuntimeDomain.StackTraceId? AsyncStackTraceId
            {
                get; set;
            }

        }
        public class ResumeParams : IMethodParams<ResumeParams, ResumeResult>
        {
            public string GetMethod()
            {
                return "Debugger.resume";

            }
            /// <summary>
            /// Set to true to terminate execution upon resuming execution. In contrast
            /// to Runtime.terminateExecution, this will allows to execute further
            /// JavaScript (i.e. via evaluation) until execution of the paused code
            /// is actually resumed, at which point termination is triggered.
            /// If execution is currently not paused, this parameter has no effect.
            /// </summary>
            public bool? TerminateOnResume
            {
                get; set;
            }

        }
        public class ResumeResult
        {

        }
        public class SearchInContentParams : IMethodParams<SearchInContentParams, SearchInContentResult>
        {
            public string GetMethod()
            {
                return "Debugger.searchInContent";

            }
            /// <summary>
            /// Id of the script to search in.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// String to search for.
            /// </summary>
            public string Query
            {
                get; set;
            }
            /// <summary>
            /// If true, search is case sensitive.
            /// </summary>
            public bool? CaseSensitive
            {
                get; set;
            }
            /// <summary>
            /// If true, treats string parameter as regex.
            /// </summary>
            public bool? IsRegex
            {
                get; set;
            }

        }
        public class SearchInContentResult
        {
            /// <summary>
            /// List of search matches.
            /// </summary>
            public DebuggerDomain.SearchMatch[] Result
            {
                get; set;
            }

        }
        public class SetAsyncCallStackDepthParams : IMethodParams<SetAsyncCallStackDepthParams, SetAsyncCallStackDepthResult>
        {
            public string GetMethod()
            {
                return "Debugger.setAsyncCallStackDepth";

            }
            /// <summary>
            /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
            /// call stacks (default).
            /// </summary>
            public int MaxDepth
            {
                get; set;
            }

        }
        public class SetAsyncCallStackDepthResult
        {

        }
        public class SetBlackboxPatternsParams : IMethodParams<SetBlackboxPatternsParams, SetBlackboxPatternsResult>
        {
            public string GetMethod()
            {
                return "Debugger.setBlackboxPatterns";

            }
            /// <summary>
            /// Array of regexps that will be used to check script url for blackbox state.
            /// </summary>
            public string[] Patterns
            {
                get; set;
            }

        }
        public class SetBlackboxPatternsResult
        {

        }
        public class SetBlackboxedRangesParams : IMethodParams<SetBlackboxedRangesParams, SetBlackboxedRangesResult>
        {
            public string GetMethod()
            {
                return "Debugger.setBlackboxedRanges";

            }
            /// <summary>
            /// Id of the script.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DebuggerDomain.ScriptPosition[] Positions
            {
                get; set;
            }

        }
        public class SetBlackboxedRangesResult
        {

        }
        public class SetBreakpointParams : IMethodParams<SetBreakpointParams, SetBreakpointResult>
        {
            public string GetMethod()
            {
                return "Debugger.setBreakpoint";

            }
            /// <summary>
            /// Location to set breakpoint in.
            /// </summary>
            public DebuggerDomain.Location Location
            {
                get; set;
            }
            /// <summary>
            /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the
            /// breakpoint if this expression evaluates to true.
            /// </summary>
            public string? Condition
            {
                get; set;
            }

        }
        public class SetBreakpointResult
        {
            /// <summary>
            /// Id of the created breakpoint for further reference.
            /// </summary>
            public string BreakpointId
            {
                get; set;
            }
            /// <summary>
            /// Location this breakpoint resolved into.
            /// </summary>
            public DebuggerDomain.Location ActualLocation
            {
                get; set;
            }

        }
        public class SetInstrumentationBreakpointParams : IMethodParams<SetInstrumentationBreakpointParams, SetInstrumentationBreakpointResult>
        {
            public string GetMethod()
            {
                return "Debugger.setInstrumentationBreakpoint";

            }
            /// <summary>
            /// Instrumentation name.
            /// </summary>
            /// <value>
            /// beforeScriptExecution,beforeScriptWithSourceMapExecution
            /// </value>
            public string Instrumentation
            {
                get; set;
            }

        }
        public class SetInstrumentationBreakpointResult
        {
            /// <summary>
            /// Id of the created breakpoint for further reference.
            /// </summary>
            public string BreakpointId
            {
                get; set;
            }

        }
        public class SetBreakpointByUrlParams : IMethodParams<SetBreakpointByUrlParams, SetBreakpointByUrlResult>
        {
            public string GetMethod()
            {
                return "Debugger.setBreakpointByUrl";

            }
            /// <summary>
            /// Line number to set breakpoint at.
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// URL of the resources to set breakpoint on.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
            /// `urlRegex` must be specified.
            /// </summary>
            public string? UrlRegex
            {
                get; set;
            }
            /// <summary>
            /// Script hash of the resources to set breakpoint on.
            /// </summary>
            public string? ScriptHash
            {
                get; set;
            }
            /// <summary>
            /// Offset in the line to set breakpoint at.
            /// </summary>
            public int? ColumnNumber
            {
                get; set;
            }
            /// <summary>
            /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the
            /// breakpoint if this expression evaluates to true.
            /// </summary>
            public string? Condition
            {
                get; set;
            }

        }
        public class SetBreakpointByUrlResult
        {
            /// <summary>
            /// Id of the created breakpoint for further reference.
            /// </summary>
            public string BreakpointId
            {
                get; set;
            }
            /// <summary>
            /// List of the locations this breakpoint resolved into upon addition.
            /// </summary>
            public DebuggerDomain.Location[] Locations
            {
                get; set;
            }

        }
        public class SetBreakpointOnFunctionCallParams : IMethodParams<SetBreakpointOnFunctionCallParams, SetBreakpointOnFunctionCallResult>
        {
            public string GetMethod()
            {
                return "Debugger.setBreakpointOnFunctionCall";

            }
            /// <summary>
            /// Function object id.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Expression to use as a breakpoint condition. When specified, debugger will
            /// stop on the breakpoint if this expression evaluates to true.
            /// </summary>
            public string? Condition
            {
                get; set;
            }

        }
        public class SetBreakpointOnFunctionCallResult
        {
            /// <summary>
            /// Id of the created breakpoint for further reference.
            /// </summary>
            public string BreakpointId
            {
                get; set;
            }

        }
        public class SetBreakpointsActiveParams : IMethodParams<SetBreakpointsActiveParams, SetBreakpointsActiveResult>
        {
            public string GetMethod()
            {
                return "Debugger.setBreakpointsActive";

            }
            /// <summary>
            /// New value for breakpoints active state.
            /// </summary>
            public bool Active
            {
                get; set;
            }

        }
        public class SetBreakpointsActiveResult
        {

        }
        public class SetPauseOnExceptionsParams : IMethodParams<SetPauseOnExceptionsParams, SetPauseOnExceptionsResult>
        {
            public string GetMethod()
            {
                return "Debugger.setPauseOnExceptions";

            }
            /// <summary>
            /// Pause on exceptions mode.
            /// </summary>
            /// <value>
            /// none,uncaught,all
            /// </value>
            public string State
            {
                get; set;
            }

        }
        public class SetPauseOnExceptionsResult
        {

        }
        public class SetReturnValueParams : IMethodParams<SetReturnValueParams, SetReturnValueResult>
        {
            public string GetMethod()
            {
                return "Debugger.setReturnValue";

            }
            /// <summary>
            /// New return value.
            /// </summary>
            public RuntimeDomain.CallArgument NewValue
            {
                get; set;
            }

        }
        public class SetReturnValueResult
        {

        }
        public class SetScriptSourceParams : IMethodParams<SetScriptSourceParams, SetScriptSourceResult>
        {
            public string GetMethod()
            {
                return "Debugger.setScriptSource";

            }
            /// <summary>
            /// Id of the script to edit.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// New content of the script.
            /// </summary>
            public string ScriptSource
            {
                get; set;
            }
            /// <summary>
            /// If true the change will not actually be applied. Dry run may be used to get result
            /// description without actually modifying the code.
            /// </summary>
            public bool? DryRun
            {
                get; set;
            }
            /// <summary>
            /// If true, then `scriptSource` is allowed to change the function on top of the stack
            /// as long as the top-most stack frame is the only activation of that function.
            /// </summary>
            [Experimental]
            public bool? AllowTopFrameEditing
            {
                get; set;
            }

        }
        public class SetScriptSourceResult
        {
            /// <summary>
            /// New stack trace in case editing has happened while VM was stopped.
            /// </summary>
            [Obsolete]
            public DebuggerDomain.CallFrame[]? CallFrames
            {
                get; set;
            }
            /// <summary>
            /// Whether current call stack  was modified after applying the changes.
            /// </summary>
            [Obsolete]
            public bool? StackChanged
            {
                get; set;
            }
            /// <summary>
            /// Async stack trace, if any.
            /// </summary>
            [Obsolete]
            public RuntimeDomain.StackTrace? AsyncStackTrace
            {
                get; set;
            }
            /// <summary>
            /// Async stack trace, if any.
            /// </summary>
            [Obsolete]
            public RuntimeDomain.StackTraceId? AsyncStackTraceId
            {
                get; set;
            }
            /// <summary>
            /// Whether the operation was successful or not. Only `Ok` denotes a
            /// successful live edit while the other enum variants denote why
            /// the live edit failed.
            /// </summary>
            /// <value>
            /// Ok,CompileError,BlockedByActiveGenerator,BlockedByActiveFunction
            /// </value>
            [Experimental]
            public string Status
            {
                get; set;
            }
            /// <summary>
            /// Exception details if any. Only present when `status` is `CompileError`.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class SetSkipAllPausesParams : IMethodParams<SetSkipAllPausesParams, SetSkipAllPausesResult>
        {
            public string GetMethod()
            {
                return "Debugger.setSkipAllPauses";

            }
            /// <summary>
            /// New value for skip pauses state.
            /// </summary>
            public bool Skip
            {
                get; set;
            }

        }
        public class SetSkipAllPausesResult
        {

        }
        public class SetVariableValueParams : IMethodParams<SetVariableValueParams, SetVariableValueResult>
        {
            public string GetMethod()
            {
                return "Debugger.setVariableValue";

            }
            /// <summary>
            /// 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
            /// scope types are allowed. Other scopes could be manipulated manually.
            /// </summary>
            public int ScopeNumber
            {
                get; set;
            }
            /// <summary>
            /// Variable name.
            /// </summary>
            public string VariableName
            {
                get; set;
            }
            /// <summary>
            /// New variable value.
            /// </summary>
            public RuntimeDomain.CallArgument NewValue
            {
                get; set;
            }
            /// <summary>
            /// Id of callframe that holds variable.
            /// </summary>
            public string CallFrameId
            {
                get; set;
            }

        }
        public class SetVariableValueResult
        {

        }
        public class StepIntoParams : IMethodParams<StepIntoParams, StepIntoResult>
        {
            public string GetMethod()
            {
                return "Debugger.stepInto";

            }
            /// <summary>
            /// Debugger will pause on the execution of the first async task which was scheduled
            /// before next pause.
            /// </summary>
            [Experimental]
            public bool? BreakOnAsyncCall
            {
                get; set;
            }
            /// <summary>
            /// The skipList specifies location ranges that should be skipped on step into.
            /// </summary>
            [Experimental]
            public DebuggerDomain.LocationRange[]? SkipList
            {
                get; set;
            }

        }
        public class StepIntoResult
        {

        }
        public class StepOutParams : IMethodParams<StepOutParams, StepOutResult>
        {
            public string GetMethod()
            {
                return "Debugger.stepOut";

            }

        }
        public class StepOutResult
        {

        }
        public class StepOverParams : IMethodParams<StepOverParams, StepOverResult>
        {
            public string GetMethod()
            {
                return "Debugger.stepOver";

            }
            /// <summary>
            /// The skipList specifies location ranges that should be skipped on step over.
            /// </summary>
            [Experimental]
            public DebuggerDomain.LocationRange[]? SkipList
            {
                get; set;
            }

        }
        public class StepOverResult
        {

        }
        /// <summary>
        /// Location in the source code.
        /// </summary>
        public class Location
        {
            /// <summary>
            /// Script identifier as reported in the `Debugger.scriptParsed`.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// Line number in the script (0-based).
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// Column number in the script (0-based).
            /// </summary>
            public int? ColumnNumber
            {
                get; set;
            }

        }
        /// <summary>
        /// Location in the source code.
        /// </summary>
        [Experimental]
        public class ScriptPosition
        {
            /// <summary>
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int ColumnNumber
            {
                get; set;
            }

        }
        /// <summary>
        /// Location range within one script.
        /// </summary>
        [Experimental]
        public class LocationRange
        {
            /// <summary>
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DebuggerDomain.ScriptPosition Start
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public DebuggerDomain.ScriptPosition End
            {
                get; set;
            }

        }
        /// <summary>
        /// JavaScript call frame. Array of call frames form the call stack.
        /// </summary>
        public class CallFrame
        {
            /// <summary>
            /// Call frame identifier. This identifier is only valid while the virtual machine is paused.
            /// </summary>
            public string CallFrameId
            {
                get; set;
            }
            /// <summary>
            /// Name of the JavaScript function called on this call frame.
            /// </summary>
            public string FunctionName
            {
                get; set;
            }
            /// <summary>
            /// Location in the source code.
            /// </summary>
            public DebuggerDomain.Location? FunctionLocation
            {
                get; set;
            }
            /// <summary>
            /// Location in the source code.
            /// </summary>
            public DebuggerDomain.Location Location
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script name or url.
            /// Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
            /// sent `Debugger.scriptParsed` event.
            /// </summary>
            [Obsolete]
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Scope chain for this call frame.
            /// </summary>
            public DebuggerDomain.Scope[] ScopeChain
            {
                get; set;
            }
            /// <summary>
            /// `this` object for this call frame.
            /// </summary>
            public RuntimeDomain.RemoteObject This
            {
                get; set;
            }
            /// <summary>
            /// The value being returned, if the function is at return point.
            /// </summary>
            public RuntimeDomain.RemoteObject? ReturnValue
            {
                get; set;
            }
            /// <summary>
            /// Valid only while the VM is paused and indicates whether this frame
            /// can be restarted or not. Note that a `true` value here does not
            /// guarantee that Debugger#restartFrame with this CallFrameId will be
            /// successful, but it is very likely.
            /// </summary>
            [Experimental]
            public bool? CanBeRestarted
            {
                get; set;
            }

        }
        /// <summary>
        /// Scope description.
        /// </summary>
        public class Scope
        {
            /// <summary>
            /// Scope type.
            /// </summary>
            /// <value>
            /// global,local,with,closure,catch,block,script,eval,module,wasm-expression-stack
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Object representing the scope. For `global` and `with` scopes it represents the actual
            /// object; for the rest of the scopes, it is artificial transient object enumerating scope
            /// variables as its properties.
            /// </summary>
            public RuntimeDomain.RemoteObject Object
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? Name
            {
                get; set;
            }
            /// <summary>
            /// Location in the source code where scope starts
            /// </summary>
            public DebuggerDomain.Location? StartLocation
            {
                get; set;
            }
            /// <summary>
            /// Location in the source code where scope ends
            /// </summary>
            public DebuggerDomain.Location? EndLocation
            {
                get; set;
            }

        }
        /// <summary>
        /// Search match for resource.
        /// </summary>
        public class SearchMatch
        {
            /// <summary>
            /// Line number in resource content.
            /// </summary>
            public double LineNumber
            {
                get; set;
            }
            /// <summary>
            /// Line with match content.
            /// </summary>
            public string LineContent
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        public class BreakLocation
        {
            /// <summary>
            /// Script identifier as reported in the `Debugger.scriptParsed`.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// Line number in the script (0-based).
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// Column number in the script (0-based).
            /// </summary>
            public int? ColumnNumber
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            /// <value>
            /// debuggerStatement,call,return
            /// </value>
            public string? Type
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class WasmDisassemblyChunk
        {
            /// <summary>
            /// The next chunk of disassembled lines.
            /// </summary>
            public string[] Lines
            {
                get; set;
            }
            /// <summary>
            /// The bytecode offsets describing the start of each line.
            /// </summary>
            public int[] BytecodeOffsets
            {
                get; set;
            }

        }
        /// <summary>
        /// Enum of possible script languages.
        /// </summary>
        public enum ScriptLanguage
        {
            [EnumValue("JavaScript")]
            JavaScript = 1,
            [EnumValue("WebAssembly")]
            WebAssembly = 2,

        }
        /// <summary>
        /// Debug symbols available for a wasm script.
        /// </summary>
        public class DebugSymbols
        {
            /// <summary>
            /// Type of the debug symbols.
            /// </summary>
            /// <value>
            /// None,SourceMap,EmbeddedDWARF,ExternalDWARF
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// URL of the external symbol source.
            /// </summary>
            public string? ExternalURL
            {
                get; set;
            }

        }

    }
    public class HeapProfilerDomain : BaseDomain
    {
        public HeapProfilerDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "HeapProfiler";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<AddHeapSnapshotChunkParams>? AddHeapSnapshotChunk;
        /// <summary>
        /// If heap objects tracking has been started then backend may send update for one or more fragments
        /// </summary>
        public event EventHandler<HeapStatsUpdateParams>? HeapStatsUpdate;
        /// <summary>
        /// If heap objects tracking has been started then backend regularly sends a current value for last
        /// seen object id and corresponding timestamp. If the were changes in the heap since last event
        /// then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
        /// </summary>
        public event EventHandler<LastSeenObjectIdParams>? LastSeenObjectId;
        /// <summary>
        /// </summary>
        public event EventHandler<ReportHeapSnapshotProgressParams>? ReportHeapSnapshotProgress;
        /// <summary>
        /// </summary>
        public event EventHandler<ResetProfilesParams>? ResetProfiles;
        /// <summary>
        /// Enables console to refer to the node with given id via $x (see Command Line API for more details
        /// $x functions).
        /// </summary>
        public async ValueTask<AddInspectedHeapObjectResult> AddInspectedHeapObjectAsync(AddInspectedHeapObjectParams addInspectedHeapObjectParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addInspectedHeapObjectParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<CollectGarbageResult> CollectGarbageAsync(CollectGarbageParams collectGarbageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(collectGarbageParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetHeapObjectIdResult> GetHeapObjectIdAsync(GetHeapObjectIdParams getHeapObjectIdParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getHeapObjectIdParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetObjectByHeapObjectIdResult> GetObjectByHeapObjectIdAsync(GetObjectByHeapObjectIdParams getObjectByHeapObjectIdParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getObjectByHeapObjectIdParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<GetSamplingProfileResult> GetSamplingProfileAsync(GetSamplingProfileParams getSamplingProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getSamplingProfileParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StartSamplingResult> StartSamplingAsync(StartSamplingParams startSamplingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startSamplingParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StartTrackingHeapObjectsResult> StartTrackingHeapObjectsAsync(StartTrackingHeapObjectsParams startTrackingHeapObjectsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startTrackingHeapObjectsParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StopSamplingResult> StopSamplingAsync(StopSamplingParams stopSamplingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopSamplingParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StopTrackingHeapObjectsResult> StopTrackingHeapObjectsAsync(StopTrackingHeapObjectsParams stopTrackingHeapObjectsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopTrackingHeapObjectsParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<TakeHeapSnapshotResult> TakeHeapSnapshotAsync(TakeHeapSnapshotParams takeHeapSnapshotParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takeHeapSnapshotParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "addHeapSnapshotChunk": RaiseEvent(AddHeapSnapshotChunk, messageBytes);
                    break;
                case "heapStatsUpdate": RaiseEvent(HeapStatsUpdate, messageBytes);
                    break;
                case "lastSeenObjectId": RaiseEvent(LastSeenObjectId, messageBytes);
                    break;
                case "reportHeapSnapshotProgress": RaiseEvent(ReportHeapSnapshotProgress, messageBytes);
                    break;
                case "resetProfiles": RaiseEvent(ResetProfiles, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class AddHeapSnapshotChunkParams
        {
            /// <summary>
            /// </summary>
            public string Chunk
            {
                get; set;
            }

        }
        public class HeapStatsUpdateParams
        {
            /// <summary>
            /// An array of triplets. Each triplet describes a fragment. The first integer is the fragment
            /// index, the second integer is a total count of objects for the fragment, the third integer is
            /// a total size of the objects for the fragment.
            /// </summary>
            public int[] StatsUpdate
            {
                get; set;
            }

        }
        public class LastSeenObjectIdParams
        {
            /// <summary>
            /// </summary>
            public int LastSeenObjectId
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class ReportHeapSnapshotProgressParams
        {
            /// <summary>
            /// </summary>
            public int Done
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public int Total
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public bool? Finished
            {
                get; set;
            }

        }
        public class ResetProfilesParams
        {

        }
        public class AddInspectedHeapObjectParams : IMethodParams<AddInspectedHeapObjectParams, AddInspectedHeapObjectResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.addInspectedHeapObject";

            }
            /// <summary>
            /// Heap snapshot object id to be accessible by means of $x command line API.
            /// </summary>
            public string HeapObjectId
            {
                get; set;
            }

        }
        public class AddInspectedHeapObjectResult
        {

        }
        public class CollectGarbageParams : IMethodParams<CollectGarbageParams, CollectGarbageResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.collectGarbage";

            }

        }
        public class CollectGarbageResult
        {

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetHeapObjectIdParams : IMethodParams<GetHeapObjectIdParams, GetHeapObjectIdResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.getHeapObjectId";

            }
            /// <summary>
            /// Identifier of the object to get heap object id for.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }

        }
        public class GetHeapObjectIdResult
        {
            /// <summary>
            /// Id of the heap snapshot object corresponding to the passed remote object id.
            /// </summary>
            public string HeapSnapshotObjectId
            {
                get; set;
            }

        }
        public class GetObjectByHeapObjectIdParams : IMethodParams<GetObjectByHeapObjectIdParams, GetObjectByHeapObjectIdResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.getObjectByHeapObjectId";

            }
            /// <summary>
            /// </summary>
            public string ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Symbolic group name that can be used to release multiple objects.
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }

        }
        public class GetObjectByHeapObjectIdResult
        {
            /// <summary>
            /// Evaluation result.
            /// </summary>
            public RuntimeDomain.RemoteObject Result
            {
                get; set;
            }

        }
        public class GetSamplingProfileParams : IMethodParams<GetSamplingProfileParams, GetSamplingProfileResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.getSamplingProfile";

            }

        }
        public class GetSamplingProfileResult
        {
            /// <summary>
            /// Return the sampling profile being collected.
            /// </summary>
            public HeapProfilerDomain.SamplingHeapProfile Profile
            {
                get; set;
            }

        }
        public class StartSamplingParams : IMethodParams<StartSamplingParams, StartSamplingResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.startSampling";

            }
            /// <summary>
            /// Average sample interval in bytes. Poisson distribution is used for the intervals. The
            /// default value is 32768 bytes.
            /// </summary>
            public double? SamplingInterval
            {
                get; set;
            }

        }
        public class StartSamplingResult
        {

        }
        public class StartTrackingHeapObjectsParams : IMethodParams<StartTrackingHeapObjectsParams, StartTrackingHeapObjectsResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.startTrackingHeapObjects";

            }
            /// <summary>
            /// </summary>
            public bool? TrackAllocations
            {
                get; set;
            }

        }
        public class StartTrackingHeapObjectsResult
        {

        }
        public class StopSamplingParams : IMethodParams<StopSamplingParams, StopSamplingResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.stopSampling";

            }

        }
        public class StopSamplingResult
        {
            /// <summary>
            /// Recorded sampling heap profile.
            /// </summary>
            public HeapProfilerDomain.SamplingHeapProfile Profile
            {
                get; set;
            }

        }
        public class StopTrackingHeapObjectsParams : IMethodParams<StopTrackingHeapObjectsParams, StopTrackingHeapObjectsResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.stopTrackingHeapObjects";

            }
            /// <summary>
            /// If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
            /// when the tracking is stopped.
            /// </summary>
            public bool? ReportProgress
            {
                get; set;
            }
            /// <summary>
            /// Deprecated in favor of `exposeInternals`.
            /// </summary>
            [Obsolete]
            public bool? TreatGlobalObjectsAsRoots
            {
                get; set;
            }
            /// <summary>
            /// If true, numerical values are included in the snapshot
            /// </summary>
            public bool? CaptureNumericValue
            {
                get; set;
            }
            /// <summary>
            /// If true, exposes internals of the snapshot.
            /// </summary>
            [Experimental]
            public bool? ExposeInternals
            {
                get; set;
            }

        }
        public class StopTrackingHeapObjectsResult
        {

        }
        public class TakeHeapSnapshotParams : IMethodParams<TakeHeapSnapshotParams, TakeHeapSnapshotResult>
        {
            public string GetMethod()
            {
                return "HeapProfiler.takeHeapSnapshot";

            }
            /// <summary>
            /// If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
            /// </summary>
            public bool? ReportProgress
            {
                get; set;
            }
            /// <summary>
            /// If true, a raw snapshot without artificial roots will be generated.
            /// Deprecated in favor of `exposeInternals`.
            /// </summary>
            [Obsolete]
            public bool? TreatGlobalObjectsAsRoots
            {
                get; set;
            }
            /// <summary>
            /// If true, numerical values are included in the snapshot
            /// </summary>
            public bool? CaptureNumericValue
            {
                get; set;
            }
            /// <summary>
            /// If true, exposes internals of the snapshot.
            /// </summary>
            [Experimental]
            public bool? ExposeInternals
            {
                get; set;
            }

        }
        public class TakeHeapSnapshotResult
        {

        }
        /// <summary>
        /// Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
        /// </summary>
        public class SamplingHeapProfileNode
        {
            /// <summary>
            /// Function location.
            /// </summary>
            public RuntimeDomain.CallFrame CallFrame
            {
                get; set;
            }
            /// <summary>
            /// Allocations size in bytes for the node excluding children.
            /// </summary>
            public double SelfSize
            {
                get; set;
            }
            /// <summary>
            /// Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
            /// </summary>
            public int Id
            {
                get; set;
            }
            /// <summary>
            /// Child nodes.
            /// </summary>
            public HeapProfilerDomain.SamplingHeapProfileNode[] Children
            {
                get; set;
            }

        }
        /// <summary>
        /// A single sample from a sampling profile.
        /// </summary>
        public class SamplingHeapProfileSample
        {
            /// <summary>
            /// Allocation size in bytes attributed to the sample.
            /// </summary>
            public double Size
            {
                get; set;
            }
            /// <summary>
            /// Id of the corresponding profile tree node.
            /// </summary>
            public int NodeId
            {
                get; set;
            }
            /// <summary>
            /// Time-ordered sample ordinal number. It is unique across all profiles retrieved
            /// between startSampling and stopSampling.
            /// </summary>
            public double Ordinal
            {
                get; set;
            }

        }
        /// <summary>
        /// Sampling profile.
        /// </summary>
        public class SamplingHeapProfile
        {
            /// <summary>
            /// </summary>
            public HeapProfilerDomain.SamplingHeapProfileNode Head
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public HeapProfilerDomain.SamplingHeapProfileSample[] Samples
            {
                get; set;
            }

        }

    }
    public class ProfilerDomain : BaseDomain
    {
        public ProfilerDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Profiler";

            }

        }
        /// <summary>
        /// </summary>
        public event EventHandler<ConsoleProfileFinishedParams>? ConsoleProfileFinished;
        /// <summary>
        /// Sent when new profile recording is started using console.profile() call.
        /// </summary>
        public event EventHandler<ConsoleProfileStartedParams>? ConsoleProfileStarted;
        /// <summary>
        /// Reports coverage delta since the last poll (either from an event like this, or from
        /// `takePreciseCoverage` for the current isolate. May only be sent if precise code
        /// coverage has been started. This event can be trigged by the embedder to, for example,
        /// trigger collection of coverage data immediately at a certain point in time.
        /// </summary>
        [Experimental]
        public event EventHandler<PreciseCoverageDeltaUpdateParams>? PreciseCoverageDeltaUpdate;
        /// <summary>
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Collect coverage data for the current isolate. The coverage data may be incomplete due to
        /// garbage collection.
        /// </summary>
        public async ValueTask<GetBestEffortCoverageResult> GetBestEffortCoverageAsync(GetBestEffortCoverageParams getBestEffortCoverageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getBestEffortCoverageParams, cancellationToken);

        }
        /// <summary>
        /// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
        /// </summary>
        public async ValueTask<SetSamplingIntervalResult> SetSamplingIntervalAsync(SetSamplingIntervalParams setSamplingIntervalParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setSamplingIntervalParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StartResult> StartAsync(StartParams startParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startParams, cancellationToken);

        }
        /// <summary>
        /// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
        /// coverage may be incomplete. Enabling prevents running optimized code and resets execution
        /// counters.
        /// </summary>
        public async ValueTask<StartPreciseCoverageResult> StartPreciseCoverageAsync(StartPreciseCoverageParams startPreciseCoverageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startPreciseCoverageParams, cancellationToken);

        }
        /// <summary>
        /// Enable type profile.
        /// </summary>
        [Experimental]
        public async ValueTask<StartTypeProfileResult> StartTypeProfileAsync(StartTypeProfileParams startTypeProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(startTypeProfileParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<StopResult> StopAsync(StopParams stopParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopParams, cancellationToken);

        }
        /// <summary>
        /// Disable precise code coverage. Disabling releases unnecessary execution count records and allows
        /// executing optimized code.
        /// </summary>
        public async ValueTask<StopPreciseCoverageResult> StopPreciseCoverageAsync(StopPreciseCoverageParams stopPreciseCoverageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopPreciseCoverageParams, cancellationToken);

        }
        /// <summary>
        /// Disable type profile. Disabling releases type profile data collected so far.
        /// </summary>
        [Experimental]
        public async ValueTask<StopTypeProfileResult> StopTypeProfileAsync(StopTypeProfileParams stopTypeProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(stopTypeProfileParams, cancellationToken);

        }
        /// <summary>
        /// Collect coverage data for the current isolate, and resets execution counters. Precise code
        /// coverage needs to have started.
        /// </summary>
        public async ValueTask<TakePreciseCoverageResult> TakePreciseCoverageAsync(TakePreciseCoverageParams takePreciseCoverageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takePreciseCoverageParams, cancellationToken);

        }
        /// <summary>
        /// Collect type profile.
        /// </summary>
        [Experimental]
        public async ValueTask<TakeTypeProfileResult> TakeTypeProfileAsync(TakeTypeProfileParams takeTypeProfileParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(takeTypeProfileParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "consoleProfileFinished": RaiseEvent(ConsoleProfileFinished, messageBytes);
                    break;
                case "consoleProfileStarted": RaiseEvent(ConsoleProfileStarted, messageBytes);
                    break;
                case "preciseCoverageDeltaUpdate": RaiseEvent(PreciseCoverageDeltaUpdate, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class ConsoleProfileFinishedParams
        {
            /// <summary>
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// Location of console.profileEnd().
            /// </summary>
            public DebuggerDomain.Location Location
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public ProfilerDomain.Profile Profile
            {
                get; set;
            }
            /// <summary>
            /// Profile title passed as an argument to console.profile().
            /// </summary>
            public string? Title
            {
                get; set;
            }

        }
        public class ConsoleProfileStartedParams
        {
            /// <summary>
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// Location of console.profile().
            /// </summary>
            public DebuggerDomain.Location Location
            {
                get; set;
            }
            /// <summary>
            /// Profile title passed as an argument to console.profile().
            /// </summary>
            public string? Title
            {
                get; set;
            }

        }
        public class PreciseCoverageDeltaUpdateParams
        {
            /// <summary>
            /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Identifier for distinguishing coverage events.
            /// </summary>
            public string Occasion
            {
                get; set;
            }
            /// <summary>
            /// Coverage data for the current isolate.
            /// </summary>
            public ProfilerDomain.ScriptCoverage[] Result
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Profiler.disable";

            }

        }
        public class DisableResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Profiler.enable";

            }

        }
        public class EnableResult
        {

        }
        public class GetBestEffortCoverageParams : IMethodParams<GetBestEffortCoverageParams, GetBestEffortCoverageResult>
        {
            public string GetMethod()
            {
                return "Profiler.getBestEffortCoverage";

            }

        }
        public class GetBestEffortCoverageResult
        {
            /// <summary>
            /// Coverage data for the current isolate.
            /// </summary>
            public ProfilerDomain.ScriptCoverage[] Result
            {
                get; set;
            }

        }
        public class SetSamplingIntervalParams : IMethodParams<SetSamplingIntervalParams, SetSamplingIntervalResult>
        {
            public string GetMethod()
            {
                return "Profiler.setSamplingInterval";

            }
            /// <summary>
            /// New sampling interval in microseconds.
            /// </summary>
            public int Interval
            {
                get; set;
            }

        }
        public class SetSamplingIntervalResult
        {

        }
        public class StartParams : IMethodParams<StartParams, StartResult>
        {
            public string GetMethod()
            {
                return "Profiler.start";

            }

        }
        public class StartResult
        {

        }
        public class StartPreciseCoverageParams : IMethodParams<StartPreciseCoverageParams, StartPreciseCoverageResult>
        {
            public string GetMethod()
            {
                return "Profiler.startPreciseCoverage";

            }
            /// <summary>
            /// Collect accurate call counts beyond simple 'covered' or 'not covered'.
            /// </summary>
            public bool? CallCount
            {
                get; set;
            }
            /// <summary>
            /// Collect block-based coverage.
            /// </summary>
            public bool? Detailed
            {
                get; set;
            }
            /// <summary>
            /// Allow the backend to send updates on its own initiative
            /// </summary>
            public bool? AllowTriggeredUpdates
            {
                get; set;
            }

        }
        public class StartPreciseCoverageResult
        {
            /// <summary>
            /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class StartTypeProfileParams : IMethodParams<StartTypeProfileParams, StartTypeProfileResult>
        {
            public string GetMethod()
            {
                return "Profiler.startTypeProfile";

            }

        }
        public class StartTypeProfileResult
        {

        }
        public class StopParams : IMethodParams<StopParams, StopResult>
        {
            public string GetMethod()
            {
                return "Profiler.stop";

            }

        }
        public class StopResult
        {
            /// <summary>
            /// Recorded profile.
            /// </summary>
            public ProfilerDomain.Profile Profile
            {
                get; set;
            }

        }
        public class StopPreciseCoverageParams : IMethodParams<StopPreciseCoverageParams, StopPreciseCoverageResult>
        {
            public string GetMethod()
            {
                return "Profiler.stopPreciseCoverage";

            }

        }
        public class StopPreciseCoverageResult
        {

        }
        public class StopTypeProfileParams : IMethodParams<StopTypeProfileParams, StopTypeProfileResult>
        {
            public string GetMethod()
            {
                return "Profiler.stopTypeProfile";

            }

        }
        public class StopTypeProfileResult
        {

        }
        public class TakePreciseCoverageParams : IMethodParams<TakePreciseCoverageParams, TakePreciseCoverageResult>
        {
            public string GetMethod()
            {
                return "Profiler.takePreciseCoverage";

            }

        }
        public class TakePreciseCoverageResult
        {
            /// <summary>
            /// Coverage data for the current isolate.
            /// </summary>
            public ProfilerDomain.ScriptCoverage[] Result
            {
                get; set;
            }
            /// <summary>
            /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }

        }
        public class TakeTypeProfileParams : IMethodParams<TakeTypeProfileParams, TakeTypeProfileResult>
        {
            public string GetMethod()
            {
                return "Profiler.takeTypeProfile";

            }

        }
        public class TakeTypeProfileResult
        {
            /// <summary>
            /// Type profile for all scripts since startTypeProfile() was turned on.
            /// </summary>
            public ProfilerDomain.ScriptTypeProfile[] Result
            {
                get; set;
            }

        }
        /// <summary>
        /// Profile node. Holds callsite information, execution statistics and child nodes.
        /// </summary>
        public class ProfileNode
        {
            /// <summary>
            /// Unique id of the node.
            /// </summary>
            public int Id
            {
                get; set;
            }
            /// <summary>
            /// Function location.
            /// </summary>
            public RuntimeDomain.CallFrame CallFrame
            {
                get; set;
            }
            /// <summary>
            /// Number of samples where this node was on top of the call stack.
            /// </summary>
            public int? HitCount
            {
                get; set;
            }
            /// <summary>
            /// Child node ids.
            /// </summary>
            public int[]? Children
            {
                get; set;
            }
            /// <summary>
            /// The reason of being not optimized. The function may be deoptimized or marked as don't
            /// optimize.
            /// </summary>
            public string? DeoptReason
            {
                get; set;
            }
            /// <summary>
            /// An array of source position ticks.
            /// </summary>
            public ProfilerDomain.PositionTickInfo[]? PositionTicks
            {
                get; set;
            }

        }
        /// <summary>
        /// Profile.
        /// </summary>
        public class Profile
        {
            /// <summary>
            /// The list of profile nodes. First item is the root node.
            /// </summary>
            public ProfilerDomain.ProfileNode[] Nodes
            {
                get; set;
            }
            /// <summary>
            /// Profiling start timestamp in microseconds.
            /// </summary>
            public double StartTime
            {
                get; set;
            }
            /// <summary>
            /// Profiling end timestamp in microseconds.
            /// </summary>
            public double EndTime
            {
                get; set;
            }
            /// <summary>
            /// Ids of samples top nodes.
            /// </summary>
            public int[]? Samples
            {
                get; set;
            }
            /// <summary>
            /// Time intervals between adjacent samples in microseconds. The first delta is relative to the
            /// profile startTime.
            /// </summary>
            public int[]? TimeDeltas
            {
                get; set;
            }

        }
        /// <summary>
        /// Specifies a number of samples attributed to a certain source position.
        /// </summary>
        public class PositionTickInfo
        {
            /// <summary>
            /// Source line number (1-based).
            /// </summary>
            public int Line
            {
                get; set;
            }
            /// <summary>
            /// Number of samples attributed to the source line.
            /// </summary>
            public int Ticks
            {
                get; set;
            }

        }
        /// <summary>
        /// Coverage data for a source range.
        /// </summary>
        public class CoverageRange
        {
            /// <summary>
            /// JavaScript script source offset for the range start.
            /// </summary>
            public int StartOffset
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script source offset for the range end.
            /// </summary>
            public int EndOffset
            {
                get; set;
            }
            /// <summary>
            /// Collected execution count of the source range.
            /// </summary>
            public int Count
            {
                get; set;
            }

        }
        /// <summary>
        /// Coverage data for a JavaScript function.
        /// </summary>
        public class FunctionCoverage
        {
            /// <summary>
            /// JavaScript function name.
            /// </summary>
            public string FunctionName
            {
                get; set;
            }
            /// <summary>
            /// Source ranges inside the function with coverage data.
            /// </summary>
            public ProfilerDomain.CoverageRange[] Ranges
            {
                get; set;
            }
            /// <summary>
            /// Whether coverage data for this function has block granularity.
            /// </summary>
            public bool IsBlockCoverage
            {
                get; set;
            }

        }
        /// <summary>
        /// Coverage data for a JavaScript script.
        /// </summary>
        public class ScriptCoverage
        {
            /// <summary>
            /// JavaScript script id.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script name or url.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Functions contained in the script that has coverage data.
            /// </summary>
            public ProfilerDomain.FunctionCoverage[] Functions
            {
                get; set;
            }

        }
        /// <summary>
        /// Describes a type collected during runtime.
        /// </summary>
        [Experimental]
        public class TypeObject
        {
            /// <summary>
            /// Name of a type collected with type profiling.
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        /// <summary>
        /// Source offset and types for a parameter or return value.
        /// </summary>
        [Experimental]
        public class TypeProfileEntry
        {
            /// <summary>
            /// Source offset of the parameter or end of function for return values.
            /// </summary>
            public int Offset
            {
                get; set;
            }
            /// <summary>
            /// The types for this parameter or return value.
            /// </summary>
            public ProfilerDomain.TypeObject[] Types
            {
                get; set;
            }

        }
        /// <summary>
        /// Type profile data collected during runtime for a JavaScript script.
        /// </summary>
        [Experimental]
        public class ScriptTypeProfile
        {
            /// <summary>
            /// JavaScript script id.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script name or url.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// Type profile entries for parameters and return values of the functions in the script.
            /// </summary>
            public ProfilerDomain.TypeProfileEntry[] Entries
            {
                get; set;
            }

        }

    }
    public class RuntimeDomain : BaseDomain
    {
        public RuntimeDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Runtime";

            }

        }
        /// <summary>
        /// Notification is issued every time when binding is called.
        /// </summary>
        [Experimental]
        public event EventHandler<BindingCalledParams>? BindingCalled;
        /// <summary>
        /// Issued when console API was called.
        /// </summary>
        public event EventHandler<ConsoleAPICalledParams>? ConsoleAPICalled;
        /// <summary>
        /// Issued when unhandled exception was revoked.
        /// </summary>
        public event EventHandler<ExceptionRevokedParams>? ExceptionRevoked;
        /// <summary>
        /// Issued when exception was thrown and unhandled.
        /// </summary>
        public event EventHandler<ExceptionThrownParams>? ExceptionThrown;
        /// <summary>
        /// Issued when new execution context is created.
        /// </summary>
        public event EventHandler<ExecutionContextCreatedParams>? ExecutionContextCreated;
        /// <summary>
        /// Issued when execution context is destroyed.
        /// </summary>
        public event EventHandler<ExecutionContextDestroyedParams>? ExecutionContextDestroyed;
        /// <summary>
        /// Issued when all executionContexts were cleared in browser
        /// </summary>
        public event EventHandler<ExecutionContextsClearedParams>? ExecutionContextsCleared;
        /// <summary>
        /// Issued when object should be inspected (for example, as a result of inspect() command line API
        /// call).
        /// </summary>
        public event EventHandler<InspectRequestedParams>? InspectRequested;
        /// <summary>
        /// Add handler to promise with given promise object id.
        /// </summary>
        public async ValueTask<AwaitPromiseResult> AwaitPromiseAsync(AwaitPromiseParams awaitPromiseParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(awaitPromiseParams, cancellationToken);

        }
        /// <summary>
        /// Calls function with given declaration on the given object. Object group of the result is
        /// inherited from the target object.
        /// </summary>
        public async ValueTask<CallFunctionOnResult> CallFunctionOnAsync(CallFunctionOnParams callFunctionOnParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(callFunctionOnParams, cancellationToken);

        }
        /// <summary>
        /// Compiles expression.
        /// </summary>
        public async ValueTask<CompileScriptResult> CompileScriptAsync(CompileScriptParams compileScriptParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(compileScriptParams, cancellationToken);

        }
        /// <summary>
        /// Disables reporting of execution contexts creation.
        /// </summary>
        public async ValueTask<DisableResult> DisableAsync(DisableParams disableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(disableParams, cancellationToken);

        }
        /// <summary>
        /// Discards collected exceptions and console API calls.
        /// </summary>
        public async ValueTask<DiscardConsoleEntriesResult> DiscardConsoleEntriesAsync(DiscardConsoleEntriesParams discardConsoleEntriesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(discardConsoleEntriesParams, cancellationToken);

        }
        /// <summary>
        /// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
        /// When the reporting gets enabled the event will be sent immediately for each existing execution
        /// context.
        /// </summary>
        public async ValueTask<EnableResult> EnableAsync(EnableParams enableParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(enableParams, cancellationToken);

        }
        /// <summary>
        /// Evaluates expression on global object.
        /// </summary>
        public async ValueTask<EvaluateResult> EvaluateAsync(EvaluateParams evaluateParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(evaluateParams, cancellationToken);

        }
        /// <summary>
        /// Returns the isolate id.
        /// </summary>
        [Experimental]
        public async ValueTask<GetIsolateIdResult> GetIsolateIdAsync(GetIsolateIdParams getIsolateIdParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getIsolateIdParams, cancellationToken);

        }
        /// <summary>
        /// Returns the JavaScript heap usage.
        /// It is the total usage of the corresponding isolate not scoped to a particular Runtime.
        /// </summary>
        [Experimental]
        public async ValueTask<GetHeapUsageResult> GetHeapUsageAsync(GetHeapUsageParams getHeapUsageParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getHeapUsageParams, cancellationToken);

        }
        /// <summary>
        /// Returns properties of a given object. Object group of the result is inherited from the target
        /// object.
        /// </summary>
        public async ValueTask<GetPropertiesResult> GetPropertiesAsync(GetPropertiesParams getPropertiesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getPropertiesParams, cancellationToken);

        }
        /// <summary>
        /// Returns all let, const and class variables from global scope.
        /// </summary>
        public async ValueTask<GlobalLexicalScopeNamesResult> GlobalLexicalScopeNamesAsync(GlobalLexicalScopeNamesParams globalLexicalScopeNamesParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(globalLexicalScopeNamesParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        public async ValueTask<QueryObjectsResult> QueryObjectsAsync(QueryObjectsParams queryObjectsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(queryObjectsParams, cancellationToken);

        }
        /// <summary>
        /// Releases remote object with given id.
        /// </summary>
        public async ValueTask<ReleaseObjectResult> ReleaseObjectAsync(ReleaseObjectParams releaseObjectParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(releaseObjectParams, cancellationToken);

        }
        /// <summary>
        /// Releases all remote objects that belong to a given group.
        /// </summary>
        public async ValueTask<ReleaseObjectGroupResult> ReleaseObjectGroupAsync(ReleaseObjectGroupParams releaseObjectGroupParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(releaseObjectGroupParams, cancellationToken);

        }
        /// <summary>
        /// Tells inspected instance to run if it was waiting for debugger to attach.
        /// </summary>
        public async ValueTask<RunIfWaitingForDebuggerResult> RunIfWaitingForDebuggerAsync(RunIfWaitingForDebuggerParams runIfWaitingForDebuggerParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(runIfWaitingForDebuggerParams, cancellationToken);

        }
        /// <summary>
        /// Runs script with given id in a given context.
        /// </summary>
        public async ValueTask<RunScriptResult> RunScriptAsync(RunScriptParams runScriptParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(runScriptParams, cancellationToken);

        }
        /// <summary>
        /// Enables or disables async call stacks tracking.
        /// </summary>
        public async ValueTask<SetAsyncCallStackDepthResult> SetAsyncCallStackDepthAsync(SetAsyncCallStackDepthParams setAsyncCallStackDepthParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setAsyncCallStackDepthParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetCustomObjectFormatterEnabledResult> SetCustomObjectFormatterEnabledAsync(SetCustomObjectFormatterEnabledParams setCustomObjectFormatterEnabledParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setCustomObjectFormatterEnabledParams, cancellationToken);

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public async ValueTask<SetMaxCallStackSizeToCaptureResult> SetMaxCallStackSizeToCaptureAsync(SetMaxCallStackSizeToCaptureParams setMaxCallStackSizeToCaptureParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(setMaxCallStackSizeToCaptureParams, cancellationToken);

        }
        /// <summary>
        /// Terminate current or next JavaScript execution.
        /// Will cancel the termination when the outer-most script execution ends.
        /// </summary>
        [Experimental]
        public async ValueTask<TerminateExecutionResult> TerminateExecutionAsync(TerminateExecutionParams terminateExecutionParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(terminateExecutionParams, cancellationToken);

        }
        /// <summary>
        /// If executionContextId is empty, adds binding with the given name on the
        /// global objects of all inspected contexts, including those created later,
        /// bindings survive reloads.
        /// Binding function takes exactly one argument, this argument should be string,
        /// in case of any other input, function throws an exception.
        /// Each binding function call produces Runtime.bindingCalled notification.
        /// </summary>
        [Experimental]
        public async ValueTask<AddBindingResult> AddBindingAsync(AddBindingParams addBindingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(addBindingParams, cancellationToken);

        }
        /// <summary>
        /// This method does not remove binding function from global object but
        /// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
        /// </summary>
        [Experimental]
        public async ValueTask<RemoveBindingResult> RemoveBindingAsync(RemoveBindingParams removeBindingParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(removeBindingParams, cancellationToken);

        }
        /// <summary>
        /// This method tries to lookup and populate exception details for a
        /// JavaScript Error object.
        /// Note that the stackTrace portion of the resulting exceptionDetails will
        /// only be populated if the Runtime domain was enabled at the time when the
        /// Error was thrown.
        /// </summary>
        [Experimental]
        public async ValueTask<GetExceptionDetailsResult> GetExceptionDetailsAsync(GetExceptionDetailsParams getExceptionDetailsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getExceptionDetailsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            switch (eventName)
            {
                case "bindingCalled": RaiseEvent(BindingCalled, messageBytes);
                    break;
                case "consoleAPICalled": RaiseEvent(ConsoleAPICalled, messageBytes);
                    break;
                case "exceptionRevoked": RaiseEvent(ExceptionRevoked, messageBytes);
                    break;
                case "exceptionThrown": RaiseEvent(ExceptionThrown, messageBytes);
                    break;
                case "executionContextCreated": RaiseEvent(ExecutionContextCreated, messageBytes);
                    break;
                case "executionContextDestroyed": RaiseEvent(ExecutionContextDestroyed, messageBytes);
                    break;
                case "executionContextsCleared": RaiseEvent(ExecutionContextsCleared, messageBytes);
                    break;
                case "inspectRequested": RaiseEvent(InspectRequested, messageBytes);
                    break;
                default: RaiseUnknownEvent(eventName, messageBytes);
                    break;

            }

        }
        public class BindingCalledParams
        {
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string Payload
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the context where the call was made.
            /// </summary>
            public int ExecutionContextId
            {
                get; set;
            }

        }
        public class ConsoleAPICalledParams
        {
            /// <summary>
            /// Type of the call.
            /// </summary>
            /// <value>
            /// log,debug,info,error,warning,dir,dirxml,table,trace,clear,startGroup,startGroupCollapsed,endGroup,assert,profile,profileEnd,count,timeEnd
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Call arguments.
            /// </summary>
            public RuntimeDomain.RemoteObject[] Args
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the context where the call was made.
            /// </summary>
            public int ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// Call timestamp.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// Stack trace captured when the call was made. The async stack chain is automatically reported for
            /// the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
            /// chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
            /// </summary>
            public RuntimeDomain.StackTrace? StackTrace
            {
                get; set;
            }
            /// <summary>
            /// Console context descriptor for calls on non-default console context (not console.*):
            /// 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
            /// on named context.
            /// </summary>
            [Experimental]
            public string? Context
            {
                get; set;
            }

        }
        public class ExceptionRevokedParams
        {
            /// <summary>
            /// Reason describing why exception was revoked.
            /// </summary>
            public string Reason
            {
                get; set;
            }
            /// <summary>
            /// The id of revoked exception, as reported in `exceptionThrown`.
            /// </summary>
            public int ExceptionId
            {
                get; set;
            }

        }
        public class ExceptionThrownParams
        {
            /// <summary>
            /// Timestamp of the exception.
            /// </summary>
            public double Timestamp
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public RuntimeDomain.ExceptionDetails ExceptionDetails
            {
                get; set;
            }

        }
        public class ExecutionContextCreatedParams
        {
            /// <summary>
            /// A newly created execution context.
            /// </summary>
            public RuntimeDomain.ExecutionContextDescription Context
            {
                get; set;
            }

        }
        public class ExecutionContextDestroyedParams
        {
            /// <summary>
            /// Id of the destroyed context
            /// </summary>
            public int ExecutionContextId
            {
                get; set;
            }

        }
        public class ExecutionContextsClearedParams
        {

        }
        public class InspectRequestedParams
        {
            /// <summary>
            /// </summary>
            public RuntimeDomain.RemoteObject Object
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public object Hints
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the context where the call was made.
            /// </summary>
            [Experimental]
            public int? ExecutionContextId
            {
                get; set;
            }

        }
        public class AwaitPromiseParams : IMethodParams<AwaitPromiseParams, AwaitPromiseResult>
        {
            public string GetMethod()
            {
                return "Runtime.awaitPromise";

            }
            /// <summary>
            /// Identifier of the promise.
            /// </summary>
            public string PromiseObjectId
            {
                get; set;
            }
            /// <summary>
            /// Whether the result is expected to be a JSON object that should be sent by value.
            /// </summary>
            public bool? ReturnByValue
            {
                get; set;
            }
            /// <summary>
            /// Whether preview should be generated for the result.
            /// </summary>
            public bool? GeneratePreview
            {
                get; set;
            }

        }
        public class AwaitPromiseResult
        {
            /// <summary>
            /// Promise result. Will contain rejected value if promise was rejected.
            /// </summary>
            public RuntimeDomain.RemoteObject Result
            {
                get; set;
            }
            /// <summary>
            /// Exception details if stack strace is available.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class CallFunctionOnParams : IMethodParams<CallFunctionOnParams, CallFunctionOnResult>
        {
            public string GetMethod()
            {
                return "Runtime.callFunctionOn";

            }
            /// <summary>
            /// Declaration of the function to call.
            /// </summary>
            public string FunctionDeclaration
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the object to call function on. Either objectId or executionContextId should
            /// be specified.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Call arguments. All call arguments must belong to the same JavaScript world as the target
            /// object.
            /// </summary>
            public RuntimeDomain.CallArgument[]? Arguments
            {
                get; set;
            }
            /// <summary>
            /// In silent mode exceptions thrown during evaluation are not reported and do not pause
            /// execution. Overrides `setPauseOnException` state.
            /// </summary>
            public bool? Silent
            {
                get; set;
            }
            /// <summary>
            /// Whether the result is expected to be a JSON object which should be sent by value.
            /// </summary>
            public bool? ReturnByValue
            {
                get; set;
            }
            /// <summary>
            /// Whether preview should be generated for the result.
            /// </summary>
            [Experimental]
            public bool? GeneratePreview
            {
                get; set;
            }
            /// <summary>
            /// Whether execution should be treated as initiated by user in the UI.
            /// </summary>
            public bool? UserGesture
            {
                get; set;
            }
            /// <summary>
            /// Whether execution should `await` for resulting value and return once awaited promise is
            /// resolved.
            /// </summary>
            public bool? AwaitPromise
            {
                get; set;
            }
            /// <summary>
            /// Specifies execution context which global object will be used to call function on. Either
            /// executionContextId or objectId should be specified.
            /// </summary>
            public int? ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// Symbolic group name that can be used to release multiple objects. If objectGroup is not
            /// specified and objectId is, objectGroup will be inherited from object.
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }
            /// <summary>
            /// Whether to throw an exception if side effect cannot be ruled out during evaluation.
            /// </summary>
            [Experimental]
            public bool? ThrowOnSideEffect
            {
                get; set;
            }
            /// <summary>
            /// Whether the result should contain `webDriverValue`, serialized according to
            /// https://w3c.github.io/webdriver-bidi. This is mutually exclusive with `returnByValue`, but
            /// resulting `objectId` is still provided.
            /// </summary>
            [Experimental]
            public bool? GenerateWebDriverValue
            {
                get; set;
            }

        }
        public class CallFunctionOnResult
        {
            /// <summary>
            /// Call result.
            /// </summary>
            public RuntimeDomain.RemoteObject Result
            {
                get; set;
            }
            /// <summary>
            /// Exception details.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class CompileScriptParams : IMethodParams<CompileScriptParams, CompileScriptResult>
        {
            public string GetMethod()
            {
                return "Runtime.compileScript";

            }
            /// <summary>
            /// Expression to compile.
            /// </summary>
            public string Expression
            {
                get; set;
            }
            /// <summary>
            /// Source url to be set for the script.
            /// </summary>
            public string SourceURL
            {
                get; set;
            }
            /// <summary>
            /// Specifies whether the compiled script should be persisted.
            /// </summary>
            public bool PersistScript
            {
                get; set;
            }
            /// <summary>
            /// Specifies in which execution context to perform script run. If the parameter is omitted the
            /// evaluation will be performed in the context of the inspected page.
            /// </summary>
            public int? ExecutionContextId
            {
                get; set;
            }

        }
        public class CompileScriptResult
        {
            /// <summary>
            /// Id of the script.
            /// </summary>
            public string? ScriptId
            {
                get; set;
            }
            /// <summary>
            /// Exception details.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class DisableParams : IMethodParams<DisableParams, DisableResult>
        {
            public string GetMethod()
            {
                return "Runtime.disable";

            }

        }
        public class DisableResult
        {

        }
        public class DiscardConsoleEntriesParams : IMethodParams<DiscardConsoleEntriesParams, DiscardConsoleEntriesResult>
        {
            public string GetMethod()
            {
                return "Runtime.discardConsoleEntries";

            }

        }
        public class DiscardConsoleEntriesResult
        {

        }
        public class EnableParams : IMethodParams<EnableParams, EnableResult>
        {
            public string GetMethod()
            {
                return "Runtime.enable";

            }

        }
        public class EnableResult
        {

        }
        public class EvaluateParams : IMethodParams<EvaluateParams, EvaluateResult>
        {
            public string GetMethod()
            {
                return "Runtime.evaluate";

            }
            /// <summary>
            /// Expression to evaluate.
            /// </summary>
            public string Expression
            {
                get; set;
            }
            /// <summary>
            /// Symbolic group name that can be used to release multiple objects.
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }
            /// <summary>
            /// Determines whether Command Line API should be available during the evaluation.
            /// </summary>
            public bool? IncludeCommandLineAPI
            {
                get; set;
            }
            /// <summary>
            /// In silent mode exceptions thrown during evaluation are not reported and do not pause
            /// execution. Overrides `setPauseOnException` state.
            /// </summary>
            public bool? Silent
            {
                get; set;
            }
            /// <summary>
            /// Specifies in which execution context to perform evaluation. If the parameter is omitted the
            /// evaluation will be performed in the context of the inspected page.
            /// This is mutually exclusive with `uniqueContextId`, which offers an
            /// alternative way to identify the execution context that is more reliable
            /// in a multi-process environment.
            /// </summary>
            public int? ContextId
            {
                get; set;
            }
            /// <summary>
            /// Whether the result is expected to be a JSON object that should be sent by value.
            /// </summary>
            public bool? ReturnByValue
            {
                get; set;
            }
            /// <summary>
            /// Whether preview should be generated for the result.
            /// </summary>
            [Experimental]
            public bool? GeneratePreview
            {
                get; set;
            }
            /// <summary>
            /// Whether execution should be treated as initiated by user in the UI.
            /// </summary>
            public bool? UserGesture
            {
                get; set;
            }
            /// <summary>
            /// Whether execution should `await` for resulting value and return once awaited promise is
            /// resolved.
            /// </summary>
            public bool? AwaitPromise
            {
                get; set;
            }
            /// <summary>
            /// Whether to throw an exception if side effect cannot be ruled out during evaluation.
            /// This implies `disableBreaks` below.
            /// </summary>
            [Experimental]
            public bool? ThrowOnSideEffect
            {
                get; set;
            }
            /// <summary>
            /// Terminate execution after timing out (number of milliseconds).
            /// </summary>
            [Experimental]
            public double? Timeout
            {
                get; set;
            }
            /// <summary>
            /// Disable breakpoints during execution.
            /// </summary>
            [Experimental]
            public bool? DisableBreaks
            {
                get; set;
            }
            /// <summary>
            /// Setting this flag to true enables `let` re-declaration and top-level `await`.
            /// Note that `let` variables can only be re-declared if they originate from
            /// `replMode` themselves.
            /// </summary>
            [Experimental]
            public bool? ReplMode
            {
                get; set;
            }
            /// <summary>
            /// The Content Security Policy (CSP) for the target might block 'unsafe-eval'
            /// which includes eval(), Function(), setTimeout() and setInterval()
            /// when called with non-callable arguments. This flag bypasses CSP for this
            /// evaluation and allows unsafe-eval. Defaults to true.
            /// </summary>
            [Experimental]
            public bool? AllowUnsafeEvalBlockedByCSP
            {
                get; set;
            }
            /// <summary>
            /// An alternative way to specify the execution context to evaluate in.
            /// Compared to contextId that may be reused across processes, this is guaranteed to be
            /// system-unique, so it can be used to prevent accidental evaluation of the expression
            /// in context different than intended (e.g. as a result of navigation across process
            /// boundaries).
            /// This is mutually exclusive with `contextId`.
            /// </summary>
            [Experimental]
            public string? UniqueContextId
            {
                get; set;
            }
            /// <summary>
            /// Whether the result should be serialized according to https://w3c.github.io/webdriver-bidi.
            /// </summary>
            [Experimental]
            public bool? GenerateWebDriverValue
            {
                get; set;
            }

        }
        public class EvaluateResult
        {
            /// <summary>
            /// Evaluation result.
            /// </summary>
            public RuntimeDomain.RemoteObject Result
            {
                get; set;
            }
            /// <summary>
            /// Exception details.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class GetIsolateIdParams : IMethodParams<GetIsolateIdParams, GetIsolateIdResult>
        {
            public string GetMethod()
            {
                return "Runtime.getIsolateId";

            }

        }
        public class GetIsolateIdResult
        {
            /// <summary>
            /// The isolate id.
            /// </summary>
            public string Id
            {
                get; set;
            }

        }
        public class GetHeapUsageParams : IMethodParams<GetHeapUsageParams, GetHeapUsageResult>
        {
            public string GetMethod()
            {
                return "Runtime.getHeapUsage";

            }

        }
        public class GetHeapUsageResult
        {
            /// <summary>
            /// Used heap size in bytes.
            /// </summary>
            public double UsedSize
            {
                get; set;
            }
            /// <summary>
            /// Allocated heap size in bytes.
            /// </summary>
            public double TotalSize
            {
                get; set;
            }

        }
        public class GetPropertiesParams : IMethodParams<GetPropertiesParams, GetPropertiesResult>
        {
            public string GetMethod()
            {
                return "Runtime.getProperties";

            }
            /// <summary>
            /// Identifier of the object to return properties for.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }
            /// <summary>
            /// If true, returns properties belonging only to the element itself, not to its prototype
            /// chain.
            /// </summary>
            public bool? OwnProperties
            {
                get; set;
            }
            /// <summary>
            /// If true, returns accessor properties (with getter/setter) only; internal properties are not
            /// returned either.
            /// </summary>
            [Experimental]
            public bool? AccessorPropertiesOnly
            {
                get; set;
            }
            /// <summary>
            /// Whether preview should be generated for the results.
            /// </summary>
            [Experimental]
            public bool? GeneratePreview
            {
                get; set;
            }
            /// <summary>
            /// If true, returns non-indexed properties only.
            /// </summary>
            [Experimental]
            public bool? NonIndexedPropertiesOnly
            {
                get; set;
            }

        }
        public class GetPropertiesResult
        {
            /// <summary>
            /// Object properties.
            /// </summary>
            public RuntimeDomain.PropertyDescriptor[] Result
            {
                get; set;
            }
            /// <summary>
            /// Internal object properties (only of the element itself).
            /// </summary>
            public RuntimeDomain.InternalPropertyDescriptor[]? InternalProperties
            {
                get; set;
            }
            /// <summary>
            /// Object private properties.
            /// </summary>
            [Experimental]
            public RuntimeDomain.PrivatePropertyDescriptor[]? PrivateProperties
            {
                get; set;
            }
            /// <summary>
            /// Exception details.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class GlobalLexicalScopeNamesParams : IMethodParams<GlobalLexicalScopeNamesParams, GlobalLexicalScopeNamesResult>
        {
            public string GetMethod()
            {
                return "Runtime.globalLexicalScopeNames";

            }
            /// <summary>
            /// Specifies in which execution context to lookup global scope variables.
            /// </summary>
            public int? ExecutionContextId
            {
                get; set;
            }

        }
        public class GlobalLexicalScopeNamesResult
        {
            /// <summary>
            /// </summary>
            public string[] Names
            {
                get; set;
            }

        }
        public class QueryObjectsParams : IMethodParams<QueryObjectsParams, QueryObjectsResult>
        {
            public string GetMethod()
            {
                return "Runtime.queryObjects";

            }
            /// <summary>
            /// Identifier of the prototype to return objects for.
            /// </summary>
            public string PrototypeObjectId
            {
                get; set;
            }
            /// <summary>
            /// Symbolic group name that can be used to release the results.
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }

        }
        public class QueryObjectsResult
        {
            /// <summary>
            /// Array with objects.
            /// </summary>
            public RuntimeDomain.RemoteObject Objects
            {
                get; set;
            }

        }
        public class ReleaseObjectParams : IMethodParams<ReleaseObjectParams, ReleaseObjectResult>
        {
            public string GetMethod()
            {
                return "Runtime.releaseObject";

            }
            /// <summary>
            /// Identifier of the object to release.
            /// </summary>
            public string ObjectId
            {
                get; set;
            }

        }
        public class ReleaseObjectResult
        {

        }
        public class ReleaseObjectGroupParams : IMethodParams<ReleaseObjectGroupParams, ReleaseObjectGroupResult>
        {
            public string GetMethod()
            {
                return "Runtime.releaseObjectGroup";

            }
            /// <summary>
            /// Symbolic object group name.
            /// </summary>
            public string ObjectGroup
            {
                get; set;
            }

        }
        public class ReleaseObjectGroupResult
        {

        }
        public class RunIfWaitingForDebuggerParams : IMethodParams<RunIfWaitingForDebuggerParams, RunIfWaitingForDebuggerResult>
        {
            public string GetMethod()
            {
                return "Runtime.runIfWaitingForDebugger";

            }

        }
        public class RunIfWaitingForDebuggerResult
        {

        }
        public class RunScriptParams : IMethodParams<RunScriptParams, RunScriptResult>
        {
            public string GetMethod()
            {
                return "Runtime.runScript";

            }
            /// <summary>
            /// Id of the script to run.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// Specifies in which execution context to perform script run. If the parameter is omitted the
            /// evaluation will be performed in the context of the inspected page.
            /// </summary>
            public int? ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// Symbolic group name that can be used to release multiple objects.
            /// </summary>
            public string? ObjectGroup
            {
                get; set;
            }
            /// <summary>
            /// In silent mode exceptions thrown during evaluation are not reported and do not pause
            /// execution. Overrides `setPauseOnException` state.
            /// </summary>
            public bool? Silent
            {
                get; set;
            }
            /// <summary>
            /// Determines whether Command Line API should be available during the evaluation.
            /// </summary>
            public bool? IncludeCommandLineAPI
            {
                get; set;
            }
            /// <summary>
            /// Whether the result is expected to be a JSON object which should be sent by value.
            /// </summary>
            public bool? ReturnByValue
            {
                get; set;
            }
            /// <summary>
            /// Whether preview should be generated for the result.
            /// </summary>
            public bool? GeneratePreview
            {
                get; set;
            }
            /// <summary>
            /// Whether execution should `await` for resulting value and return once awaited promise is
            /// resolved.
            /// </summary>
            public bool? AwaitPromise
            {
                get; set;
            }

        }
        public class RunScriptResult
        {
            /// <summary>
            /// Run result.
            /// </summary>
            public RuntimeDomain.RemoteObject Result
            {
                get; set;
            }
            /// <summary>
            /// Exception details.
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        public class SetAsyncCallStackDepthParams : IMethodParams<SetAsyncCallStackDepthParams, SetAsyncCallStackDepthResult>
        {
            public string GetMethod()
            {
                return "Runtime.setAsyncCallStackDepth";

            }
            /// <summary>
            /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
            /// call stacks (default).
            /// </summary>
            public int MaxDepth
            {
                get; set;
            }

        }
        public class SetAsyncCallStackDepthResult
        {

        }
        public class SetCustomObjectFormatterEnabledParams : IMethodParams<SetCustomObjectFormatterEnabledParams, SetCustomObjectFormatterEnabledResult>
        {
            public string GetMethod()
            {
                return "Runtime.setCustomObjectFormatterEnabled";

            }
            /// <summary>
            /// </summary>
            public bool Enabled
            {
                get; set;
            }

        }
        public class SetCustomObjectFormatterEnabledResult
        {

        }
        public class SetMaxCallStackSizeToCaptureParams : IMethodParams<SetMaxCallStackSizeToCaptureParams, SetMaxCallStackSizeToCaptureResult>
        {
            public string GetMethod()
            {
                return "Runtime.setMaxCallStackSizeToCapture";

            }
            /// <summary>
            /// </summary>
            public int Size
            {
                get; set;
            }

        }
        public class SetMaxCallStackSizeToCaptureResult
        {

        }
        public class TerminateExecutionParams : IMethodParams<TerminateExecutionParams, TerminateExecutionResult>
        {
            public string GetMethod()
            {
                return "Runtime.terminateExecution";

            }

        }
        public class TerminateExecutionResult
        {

        }
        public class AddBindingParams : IMethodParams<AddBindingParams, AddBindingResult>
        {
            public string GetMethod()
            {
                return "Runtime.addBinding";

            }
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// If specified, the binding would only be exposed to the specified
            /// execution context. If omitted and `executionContextName` is not set,
            /// the binding is exposed to all execution contexts of the target.
            /// This parameter is mutually exclusive with `executionContextName`.
            /// Deprecated in favor of `executionContextName` due to an unclear use case
            /// and bugs in implementation (crbug.com/1169639). `executionContextId` will be
            /// removed in the future.
            /// </summary>
            [Obsolete]
            public int? ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// If specified, the binding is exposed to the executionContext with
            /// matching name, even for contexts created after the binding is added.
            /// See also `ExecutionContext.name` and `worldName` parameter to
            /// `Page.addScriptToEvaluateOnNewDocument`.
            /// This parameter is mutually exclusive with `executionContextId`.
            /// </summary>
            [Experimental]
            public string? ExecutionContextName
            {
                get; set;
            }

        }
        public class AddBindingResult
        {

        }
        public class RemoveBindingParams : IMethodParams<RemoveBindingParams, RemoveBindingResult>
        {
            public string GetMethod()
            {
                return "Runtime.removeBinding";

            }
            /// <summary>
            /// </summary>
            public string Name
            {
                get; set;
            }

        }
        public class RemoveBindingResult
        {

        }
        public class GetExceptionDetailsParams : IMethodParams<GetExceptionDetailsParams, GetExceptionDetailsResult>
        {
            public string GetMethod()
            {
                return "Runtime.getExceptionDetails";

            }
            /// <summary>
            /// The error object for which to resolve the exception details.
            /// </summary>
            public string ErrorObjectId
            {
                get; set;
            }

        }
        public class GetExceptionDetailsResult
        {
            /// <summary>
            /// </summary>
            public RuntimeDomain.ExceptionDetails? ExceptionDetails
            {
                get; set;
            }

        }
        /// <summary>
        /// Represents the value serialiazed by the WebDriver BiDi specification
        /// https://w3c.github.io/webdriver-bidi.
        /// </summary>
        public class WebDriverValue
        {
            /// <summary>
            /// </summary>
            /// <value>
            /// undefined,null,string,number,boolean,bigint,regexp,date,symbol,array,object,function,map,set,weakmap,weakset,error,proxy,promise,typedarray,arraybuffer,node,window
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public object? Value
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        /// <summary>
        /// Mirror object referencing original JavaScript object.
        /// </summary>
        public class RemoteObject
        {
            /// <summary>
            /// Object type.
            /// </summary>
            /// <value>
            /// object,function,undefined,string,number,boolean,symbol,bigint
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Object subtype hint. Specified for `object` type values only.
            /// NOTE: If you change anything here, make sure to also update
            /// `subtype` in `ObjectPreview` and `PropertyPreview` below.
            /// </summary>
            /// <value>
            /// array,null,node,regexp,date,map,set,weakmap,weakset,iterator,generator,error,proxy,promise,typedarray,arraybuffer,dataview,webassemblymemory,wasmvalue
            /// </value>
            public string? Subtype
            {
                get; set;
            }
            /// <summary>
            /// Object class (constructor) name. Specified for `object` type values only.
            /// </summary>
            public string? ClassName
            {
                get; set;
            }
            /// <summary>
            /// Remote object value in case of primitive values or JSON values (if it was requested).
            /// </summary>
            public object? Value
            {
                get; set;
            }
            /// <summary>
            /// Primitive value which can not be JSON-stringified does not have `value`, but gets this
            /// property.
            /// </summary>
            public string? UnserializableValue
            {
                get; set;
            }
            /// <summary>
            /// String representation of the object.
            /// </summary>
            public string? Description
            {
                get; set;
            }
            /// <summary>
            /// WebDriver BiDi representation of the value.
            /// </summary>
            [Experimental]
            public RuntimeDomain.WebDriverValue? WebDriverValue
            {
                get; set;
            }
            /// <summary>
            /// Unique object identifier (for non-primitive values).
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }
            /// <summary>
            /// Preview containing abbreviated property values. Specified for `object` type values only.
            /// </summary>
            [Experimental]
            public RuntimeDomain.ObjectPreview? Preview
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            [Experimental]
            public RuntimeDomain.CustomPreview? CustomPreview
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class CustomPreview
        {
            /// <summary>
            /// The JSON-stringified result of formatter.header(object, config) call.
            /// It contains json ML array that represents RemoteObject.
            /// </summary>
            public string Header
            {
                get; set;
            }
            /// <summary>
            /// If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
            /// contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
            /// The result value is json ML array.
            /// </summary>
            public string? BodyGetterId
            {
                get; set;
            }

        }
        /// <summary>
        /// Object containing abbreviated remote object value.
        /// </summary>
        [Experimental]
        public class ObjectPreview
        {
            /// <summary>
            /// Object type.
            /// </summary>
            /// <value>
            /// object,function,undefined,string,number,boolean,symbol,bigint
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// Object subtype hint. Specified for `object` type values only.
            /// </summary>
            /// <value>
            /// array,null,node,regexp,date,map,set,weakmap,weakset,iterator,generator,error,proxy,promise,typedarray,arraybuffer,dataview,webassemblymemory,wasmvalue
            /// </value>
            public string? Subtype
            {
                get; set;
            }
            /// <summary>
            /// String representation of the object.
            /// </summary>
            public string? Description
            {
                get; set;
            }
            /// <summary>
            /// True iff some of the properties or entries of the original object did not fit.
            /// </summary>
            public bool Overflow
            {
                get; set;
            }
            /// <summary>
            /// List of the properties.
            /// </summary>
            public RuntimeDomain.PropertyPreview[] Properties
            {
                get; set;
            }
            /// <summary>
            /// List of the entries. Specified for `map` and `set` subtype values only.
            /// </summary>
            public RuntimeDomain.EntryPreview[]? Entries
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class PropertyPreview
        {
            /// <summary>
            /// Property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Object type. Accessor means that the property itself is an accessor property.
            /// </summary>
            /// <value>
            /// object,function,undefined,string,number,boolean,symbol,accessor,bigint
            /// </value>
            public string Type
            {
                get; set;
            }
            /// <summary>
            /// User-friendly property value string.
            /// </summary>
            public string? Value
            {
                get; set;
            }
            /// <summary>
            /// Nested value preview.
            /// </summary>
            public RuntimeDomain.ObjectPreview? ValuePreview
            {
                get; set;
            }
            /// <summary>
            /// Object subtype hint. Specified for `object` type values only.
            /// </summary>
            /// <value>
            /// array,null,node,regexp,date,map,set,weakmap,weakset,iterator,generator,error,proxy,promise,typedarray,arraybuffer,dataview,webassemblymemory,wasmvalue
            /// </value>
            public string? Subtype
            {
                get; set;
            }

        }
        /// <summary>
        /// </summary>
        [Experimental]
        public class EntryPreview
        {
            /// <summary>
            /// Preview of the key. Specified for map-like collection entries.
            /// </summary>
            public RuntimeDomain.ObjectPreview? Key
            {
                get; set;
            }
            /// <summary>
            /// Preview of the value.
            /// </summary>
            public RuntimeDomain.ObjectPreview Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Object property descriptor.
        /// </summary>
        public class PropertyDescriptor
        {
            /// <summary>
            /// Property name or symbol description.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// The value associated with the property.
            /// </summary>
            public RuntimeDomain.RemoteObject? Value
            {
                get; set;
            }
            /// <summary>
            /// True if the value associated with the property may be changed (data descriptors only).
            /// </summary>
            public bool? Writable
            {
                get; set;
            }
            /// <summary>
            /// A function which serves as a getter for the property, or `undefined` if there is no getter
            /// (accessor descriptors only).
            /// </summary>
            public RuntimeDomain.RemoteObject? Get
            {
                get; set;
            }
            /// <summary>
            /// A function which serves as a setter for the property, or `undefined` if there is no setter
            /// (accessor descriptors only).
            /// </summary>
            public RuntimeDomain.RemoteObject? Set
            {
                get; set;
            }
            /// <summary>
            /// True if the type of this property descriptor may be changed and if the property may be
            /// deleted from the corresponding object.
            /// </summary>
            public bool Configurable
            {
                get; set;
            }
            /// <summary>
            /// True if this property shows up during enumeration of the properties on the corresponding
            /// object.
            /// </summary>
            public bool Enumerable
            {
                get; set;
            }
            /// <summary>
            /// True if the result was thrown during the evaluation.
            /// </summary>
            public bool? WasThrown
            {
                get; set;
            }
            /// <summary>
            /// True if the property is owned for the object.
            /// </summary>
            public bool? IsOwn
            {
                get; set;
            }
            /// <summary>
            /// Property symbol object, if the property is of the `symbol` type.
            /// </summary>
            public RuntimeDomain.RemoteObject? Symbol
            {
                get; set;
            }

        }
        /// <summary>
        /// Object internal property descriptor. This property isn't normally visible in JavaScript code.
        /// </summary>
        public class InternalPropertyDescriptor
        {
            /// <summary>
            /// Conventional property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// The value associated with the property.
            /// </summary>
            public RuntimeDomain.RemoteObject? Value
            {
                get; set;
            }

        }
        /// <summary>
        /// Object private field descriptor.
        /// </summary>
        [Experimental]
        public class PrivatePropertyDescriptor
        {
            /// <summary>
            /// Private property name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// The value associated with the private property.
            /// </summary>
            public RuntimeDomain.RemoteObject? Value
            {
                get; set;
            }
            /// <summary>
            /// A function which serves as a getter for the private property,
            /// or `undefined` if there is no getter (accessor descriptors only).
            /// </summary>
            public RuntimeDomain.RemoteObject? Get
            {
                get; set;
            }
            /// <summary>
            /// A function which serves as a setter for the private property,
            /// or `undefined` if there is no setter (accessor descriptors only).
            /// </summary>
            public RuntimeDomain.RemoteObject? Set
            {
                get; set;
            }

        }
        /// <summary>
        /// Represents function call argument. Either remote object id `objectId`, primitive `value`,
        /// unserializable primitive value or neither of (for undefined) them should be specified.
        /// </summary>
        public class CallArgument
        {
            /// <summary>
            /// Primitive value or serializable javascript object.
            /// </summary>
            public object? Value
            {
                get; set;
            }
            /// <summary>
            /// Primitive value which can not be JSON-stringified.
            /// </summary>
            public string? UnserializableValue
            {
                get; set;
            }
            /// <summary>
            /// Remote object handle.
            /// </summary>
            public string? ObjectId
            {
                get; set;
            }

        }
        /// <summary>
        /// Description of an isolated world.
        /// </summary>
        public class ExecutionContextDescription
        {
            /// <summary>
            /// Unique id of the execution context. It can be used to specify in which execution context
            /// script evaluation should be performed.
            /// </summary>
            public int Id
            {
                get; set;
            }
            /// <summary>
            /// Execution context origin.
            /// </summary>
            public string Origin
            {
                get; set;
            }
            /// <summary>
            /// Human readable name describing given context.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// A system-unique execution context identifier. Unlike the id, this is unique across
            /// multiple processes, so can be reliably used to identify specific context while backend
            /// performs a cross-process navigation.
            /// </summary>
            [Experimental]
            public string UniqueId
            {
                get; set;
            }
            /// <summary>
            /// Embedder-specific auxiliary data.
            /// </summary>
            public object? AuxData
            {
                get; set;
            }

        }
        /// <summary>
        /// Detailed information about exception (or error) that was thrown during script compilation or
        /// execution.
        /// </summary>
        public class ExceptionDetails
        {
            /// <summary>
            /// Exception id.
            /// </summary>
            public int ExceptionId
            {
                get; set;
            }
            /// <summary>
            /// Exception text, which should be used together with exception object when available.
            /// </summary>
            public string Text
            {
                get; set;
            }
            /// <summary>
            /// Line number of the exception location (0-based).
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// Column number of the exception location (0-based).
            /// </summary>
            public int ColumnNumber
            {
                get; set;
            }
            /// <summary>
            /// Script ID of the exception location.
            /// </summary>
            public string? ScriptId
            {
                get; set;
            }
            /// <summary>
            /// URL of the exception location, to be used when the script was not reported.
            /// </summary>
            public string? Url
            {
                get; set;
            }
            /// <summary>
            /// JavaScript stack trace if available.
            /// </summary>
            public RuntimeDomain.StackTrace? StackTrace
            {
                get; set;
            }
            /// <summary>
            /// Exception object if available.
            /// </summary>
            public RuntimeDomain.RemoteObject? Exception
            {
                get; set;
            }
            /// <summary>
            /// Identifier of the context where exception happened.
            /// </summary>
            public int? ExecutionContextId
            {
                get; set;
            }
            /// <summary>
            /// Dictionary with entries of meta data that the client associated
            /// with this exception, such as information about associated network
            /// requests, etc.
            /// </summary>
            [Experimental]
            public object? ExceptionMetaData
            {
                get; set;
            }

        }
        /// <summary>
        /// Stack entry for runtime errors and assertions.
        /// </summary>
        public class CallFrame
        {
            /// <summary>
            /// JavaScript function name.
            /// </summary>
            public string FunctionName
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script id.
            /// </summary>
            public string ScriptId
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script name or url.
            /// </summary>
            public string Url
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script line number (0-based).
            /// </summary>
            public int LineNumber
            {
                get; set;
            }
            /// <summary>
            /// JavaScript script column number (0-based).
            /// </summary>
            public int ColumnNumber
            {
                get; set;
            }

        }
        /// <summary>
        /// Call frames for assertions or error messages.
        /// </summary>
        public class StackTrace
        {
            /// <summary>
            /// String label of this stack trace. For async traces this may be a name of the function that
            /// initiated the async call.
            /// </summary>
            public string? Description
            {
                get; set;
            }
            /// <summary>
            /// JavaScript function name.
            /// </summary>
            public RuntimeDomain.CallFrame[] CallFrames
            {
                get; set;
            }
            /// <summary>
            /// Asynchronous JavaScript stack trace that preceded this stack, if available.
            /// </summary>
            public RuntimeDomain.StackTrace? Parent
            {
                get; set;
            }
            /// <summary>
            /// Asynchronous JavaScript stack trace that preceded this stack, if available.
            /// </summary>
            [Experimental]
            public RuntimeDomain.StackTraceId? ParentId
            {
                get; set;
            }

        }
        /// <summary>
        /// If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
        /// allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
        /// </summary>
        [Experimental]
        public class StackTraceId
        {
            /// <summary>
            /// </summary>
            public string Id
            {
                get; set;
            }
            /// <summary>
            /// </summary>
            public string? DebuggerId
            {
                get; set;
            }

        }

    }
    public class SchemaDomain : BaseDomain
    {
        public SchemaDomain(BaseClient client) : base(client)
        {

        }
        public override string DomainName
        {
            get
            {
                return "Schema";

            }

        }
        /// <summary>
        /// Returns supported domains.
        /// </summary>
        public async ValueTask<GetDomainsResult> GetDomainsAsync(GetDomainsParams getDomainsParams, CancellationToken cancellationToken = default)
        {
            return await Client.SendRequestMessageAndWaitResponseResult(getDomainsParams, cancellationToken);

        }
        public override void RaiseEvent(string eventName, Span<byte> messageBytes)
        {
            RaiseUnknownEvent(eventName, messageBytes);

        }
        public class GetDomainsParams : IMethodParams<GetDomainsParams, GetDomainsResult>
        {
            public string GetMethod()
            {
                return "Schema.getDomains";

            }

        }
        public class GetDomainsResult
        {
            /// <summary>
            /// List of supported domains.
            /// </summary>
            public SchemaDomain.Domain[] Domains
            {
                get; set;
            }

        }
        /// <summary>
        /// Description of the protocol domain.
        /// </summary>
        public class Domain
        {
            /// <summary>
            /// Domain name.
            /// </summary>
            public string Name
            {
                get; set;
            }
            /// <summary>
            /// Domain version.
            /// </summary>
            public string Version
            {
                get; set;
            }

        }

    }

}